\chapter{Dataset ops}
\label{\detokenize{basics/101-136-filesystem:dataset-ops}}\label{\detokenize{basics/101-136-filesystem:file-system}}\label{\detokenize{basics/101-136-filesystem:index-0}}\label{\detokenize{basics/101-136-filesystem::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{help}.pdf}\hspace*{\fill}}

\sphinxAtStartPar
After all of the DataLad\sphinxhyphen{}101 lectures and tutorials so far, you really begin to
appreciate the pre\sphinxhyphen{}crafted examples and tasks this book provides.
“Nothing really goes wrong, and if so, it’s intended”, you acknowledge.
“But how does this prepare me for life after the course? I’ve seen a lot of
different errors and know many caveats and principles already, but I certainly
will mess something up at one point. How can I get help, or use the history of
the dataset to undo what I screwed up? Also, I’m not sure whether I know what I
can and cannot do with the files inside of my dataset… What if I would
like to remove one, for example?”

\sphinxAtStartPar
With all of the information about symlinks and object trees,
you might be reluctant to perform usual file system managing
operations, such as copying, moving, renaming or deleting
files or directories with annexed content.

\sphinxAtStartPar
If I renamed one of those books, would the symlink that points
to the file content still be correct? What happens if I’d copy
an annexed file?
If I moved the whole \sphinxcode{\sphinxupquote{books/}} directory? What if I moved
all of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} into a different place on my computer?
What if renamed the whole superdataset?
And how do I remove a file, or directory, or subdataset?

\sphinxAtStartPar
Therefore, there is an extra tutorial today, and you attend.
There is no better way of learning than doing. Here, in the
safe space of the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} course, you can try out all
of the things you would be unsure about or reluctant to try
on the dataset that contains your own, valuable data.

\sphinxAtStartPar
Below you will find common questions about file system
management operations, and each question outlines caveats and
solutions with code examples you can paste into your own terminal.
Because these code snippets will add many commits to your
dataset, we are cleaning up within each segment with
common Git operations that manipulate the datasets
history \textendash{} be sure to execute these commands as well (and
be sure to be in the correct dataset).


\section{Move files}
\label{\detokenize{basics/101-136-filesystem:move-files}}
\index{rename file@\spxentry{rename file}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!rename file@\spxentry{rename file}}\ignorespaces 

\subsection{Rename files}
\label{\detokenize{basics/101-136-filesystem:rename-files}}\label{\detokenize{basics/101-136-filesystem:index-1}}
\sphinxAtStartPar
Let’s try it. In Unix, renaming a file is exactly the same as
moving a file, and uses the \sphinxcode{\sphinxupquote{ mv}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }books/
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }TLCL.pdf\PYG{+w}{ }The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}lh\PYG{+w}{ }The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf
\PYG{g+go}{total 16K}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 131 2019\PYGZhy{}06\PYGZhy{}18 16:13 bash\PYGZus{}guide.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/WF/Gq/✂/MD5E\PYGZhy{}s1198170\PYGZhy{}\PYGZhy{}0ab2c121✂MD5.pdf}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 131 2019\PYGZhy{}06\PYGZhy{}18 16:13 byte\PYGZhy{}of\PYGZhy{}python.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/xF/42/✂/MD5E\PYGZhy{}s4161086\PYGZhy{}\PYGZhy{}c832fc13✂MD5.pdf}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 133 2019\PYGZhy{}06\PYGZhy{}18 16:13 progit.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/G6/Gj/✂/MD5E\PYGZhy{}s12465653\PYGZhy{}\PYGZhy{}05cd7ed5✂MD5.pdf}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 131 2019\PYGZhy{}06\PYGZhy{}18 16:13 The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
Try to open the renamed file, e.g., with
\sphinxcode{\sphinxupquote{evince The\_Linux\_Command\_Line.pdf}}.
This works!

\sphinxAtStartPar
But let’s see what changed in the dataset with this operation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/books/The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf (symlink)}
\PYG{g+go}{  deleted: /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/books/TLCL.pdf (symlink)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can see that the old file is marked as \sphinxcode{\sphinxupquote{deleted}}, and
simultaneously, an \sphinxcode{\sphinxupquote{untracked}} file appears: the renamed
PDF.

\sphinxAtStartPar
While this might appear messy, a \sphinxcode{\sphinxupquote{datalad save}} will clean
all of this up. Therefore, do not panic if you rename a file,
and see a dirty dataset status with deleted and untracked files
\textendash{} \sphinxcode{\sphinxupquote{datalad save}} handles these and other cases really well
under the hood.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}rename the book\PYGZdq{}}
\PYG{g+go}{delete(ok): books/TLCL.pdf (symlink)}
\PYG{g+go}{add(ok): books/The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{datalad save}} command will identify that a file was
renamed, and will summarize this nicely in the resulting commit:

\fvset{hllines={, 8, 9, 10, 11,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYGZhy{}p
\PYG{g+go}{commit d05e0ded✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    rename the book}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/books/TLCL.pdf b/books/The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf}
\PYG{g+go}{similarity index 100\PYGZpc{}}
\PYG{g+go}{rename from books/TLCL.pdf}
\PYG{g+go}{rename to books/The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{datalad save}} commits all modifications when
it’s called without a path specification,
so any other changes will be saved in the same commit as the rename.
If there are unsaved modifications you do not want to commit
together with the file name change, you could give both the
new and the deleted file as a path specification to
\sphinxcode{\sphinxupquote{datalad save}}, even if it feels unintuitive to
save a change that is marked as a deletion in a
\sphinxcode{\sphinxupquote{datalad status}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}rename file\PYGZdq{}}\PYG{+w}{ }oldname\PYG{+w}{ }newname
\end{sphinxVerbatim}

\sphinxAtStartPar
Alternatively, there is also a way to save the name change
only using Git tools only, outlined in the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-gitmv}} {\hyperref[\detokenize{basics/101-136-filesystem:fom-gitmv}]{\sphinxcrossref{\DUrole{std,std-ref}{on faster renaming}}}} (\autopageref*{\detokenize{basics/101-136-filesystem:fom-gitmv}}). If you are a Git user, you will be very familiar with it.

\index{rename file@\spxentry{rename file}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!rename file@\spxentry{rename file}}\ignorespaces \begin{findoutmore}[label={fom-gitmv}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Faster renaming with Git tools}
\label{\detokenize{basics/101-136-filesystem:fom-gitmv}}

\sphinxAtStartPar
Git has built\sphinxhyphen{}in commands that provide a solution in two steps.

\sphinxAtStartPar
If you have followed along with the previous \sphinxcode{\sphinxupquote{datalad save}}, let’s revert the renaming of the the files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{HEAD is now at 39e55c8 add container and execute analysis within container}
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we are checking out how to rename files and commit this operation
using only Git:
A Git\sphinxhyphen{}specific way to rename files is the \sphinxcode{\sphinxupquote{git mv}} command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }mv\PYG{+w}{ }TLCL.pdf\PYG{+w}{ }The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{    added: /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/books/The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf (symlink)}
\PYG{g+go}{  deleted: /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/books/TLCL.pdf (symlink)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can see that the old file is still seen as “deleted”, but the “new”,
renamed file is “added”. A \sphinxcode{\sphinxupquote{git status}} displays the change
in the dataset a bit more accurately:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }status
\PYG{g+go}{On branch main}
\PYG{g+go}{Changes to be committed:}
\PYG{g+go}{  (use \PYGZdq{}git restore \PYGZhy{}\PYGZhy{}staged \PYGZlt{}file\PYGZgt{}...\PYGZdq{} to unstage)}
\PYG{g+go}{	renamed:    TLCL.pdf \PYGZhy{}\PYGZgt{} The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
Because the \sphinxcode{\sphinxupquote{git mv}} places the change directly into the
staging area (the \sphinxstyleemphasis{index}) of Git%
\begin{footnote}\sphinxAtStartFootnote
If you want to learn more about the Git\sphinxhyphen{}specific concepts of \sphinxstyleemphasis{worktree},
\sphinxstyleemphasis{staging area}/\sphinxstyleemphasis{index} or \sphinxstyleemphasis{HEAD}, the upcoming section {\hyperref[\detokenize{basics/101-137-history:history}]{\sphinxcrossref{\DUrole{std,std-ref}{Git things done}}}} (\autopageref*{\detokenize{basics/101-137-history:history}}) will
talk briefly about them and demonstrate helpful commands.
%
\end{footnote},
a subsequent \sphinxcode{\sphinxupquote{git commit \sphinxhyphen{}m "rename book"}} will write the renaming
\textendash{} and only the renaming \textendash{} to the dataset’s history, even if other
(unstaged) modifications are present.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }commit\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}rename book\PYGZdq{}}
\PYG{g+go}{[main 515fcc2] rename book}
\PYG{g+go}{ 1 file changed, 0 insertions(+), 0 deletions(\PYGZhy{})}
\PYG{g+go}{ rename books/\PYGZob{}TLCL.pdf =\PYGZgt{} The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf\PYGZcb{} (100\PYGZpc{})}
\end{sphinxVerbatim}

\sphinxAtStartPar
\dlhbhref{P2B}{Especially when renaming directories with many files, this can be much faster} than a \sphinxcode{\sphinxupquote{mv}} followed by \sphinxcode{\sphinxupquote{datalad save}},


\end{findoutmore}

\sphinxAtStartPar
To summarize, renaming files is easy and worry\sphinxhyphen{}free. Do not be intimidated
by a file marked as deleted \textendash{} a \sphinxcode{\sphinxupquote{datalad save}} will rectify this.
Be mindful of other modifications in your dataset, though, and either supply
appropriate paths to \sphinxcode{\sphinxupquote{datalad save}}, or use Git tools to exclusively save
the name change and nothing else.

\sphinxAtStartPar
Let’s revert this now, to have a clean history.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{HEAD is now at 39e55c8 add container and execute analysis within container}
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\index{move file@\spxentry{move file}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!move file@\spxentry{move file}}\ignorespaces 

\subsection{Move files from or into subdirectories}
\label{\detokenize{basics/101-136-filesystem:move-files-from-or-into-subdirectories}}\label{\detokenize{basics/101-136-filesystem:index-3}}
\sphinxAtStartPar
Let’s move an annexed file from within \sphinxcode{\sphinxupquote{books/}} into the root
of the superdataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }TLCL.pdf\PYG{+w}{ }../TLCL.pdf
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/TLCL.pdf (symlink)}
\PYG{g+go}{  deleted: /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/books/TLCL.pdf (symlink)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In general, this looks exactly like renaming or moving a file
in the same directory. There is a subtle difference though:
Currently, the symlink of the annexed file is broken. There
are two ways to demonstrate this. One is trying to open the
file \textendash{} this will currently fail. The second way is to look
at the symlink:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }TLCL.pdf
\PYG{g+go}{lrwxrwxrwx 1 elena elena 131 2019\PYGZhy{}06\PYGZhy{}18 16:13 TLCL.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first part of the symlink should point into the \sphinxcode{\sphinxupquote{.git/}}
directory, but currently, it does not \textendash{} the symlink still looks
like \sphinxcode{\sphinxupquote{TLCL.pdf}} would be within \sphinxcode{\sphinxupquote{books/}}. Instead of pointing
into \sphinxcode{\sphinxupquote{.git}}, it currently points to \sphinxcode{\sphinxupquote{../.git}}, which is non\sphinxhyphen{}existent,
and even outside of the superdataset. This is why the file
cannot be opened: When any program tries to follow the symlink,
it will not resolve, and an error such as “no file or directory”
will be returned. But do not panic! A \sphinxcode{\sphinxupquote{datalad save}} will
rectify this as well:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}moved book into root\PYGZdq{}}
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }TLCL.pdf
\PYG{g+go}{delete(ok): books/TLCL.pdf (symlink)}
\PYG{g+go}{add(ok): TLCL.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 128 2019\PYGZhy{}06\PYGZhy{}18 16:13 TLCL.pdf \PYGZhy{}\PYGZgt{} .git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
After a \sphinxcode{\sphinxupquote{datalad save}}, the symlink is fixed again.
Therefore, in general, whenever moving or renaming a file,
especially between directories, a \sphinxcode{\sphinxupquote{datalad save}} is
the best option to turn to. Take a look at the
\textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-move-is-change}} {\hyperref[\detokenize{basics/101-136-filesystem:fom-move-is-change}]{\sphinxcrossref{\DUrole{std,std-ref}{on the content impact of a move}}}} (\autopageref*{\detokenize{basics/101-136-filesystem:fom-move-is-change}})
for some more background.

\index{content pointer file@\spxentry{content pointer file}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!content pointer file@\spxentry{content pointer file}}\ignorespaces \begin{findoutmore}[label={fom-move-is-change}, before title={\thetcbcounter\ }, float, floatplacement=tp, check odd page=true]{Why a move between directories is actually a content change}
\label{\detokenize{basics/101-136-filesystem:fom-move-is-change}}

\sphinxAtStartPar
Let’s see how this shows up in the dataset history:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYGZhy{}p
\PYG{g+go}{commit b315f5c4✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    moved book into root}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/TLCL.pdf b/TLCL.pdf}
\PYG{g+go}{new file mode 120000}
\PYG{g+go}{index 0000000..34328e2}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/TLCL.pdf}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1 @@}
\PYG{g+go}{+.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\PYG{g+go}{\PYGZbs{} No newline at end of file}
\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/books/TLCL.pdf b/books/TLCL.pdf}
\PYG{g+go}{deleted file mode 120000}
\PYG{g+go}{index 4c84b61..0000000}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} a/books/TLCL.pdf}
\PYG{g+go}{+++ /dev/null}
\PYG{g+go}{@@ \PYGZhy{}1 +0,0 @@}
\PYG{g+go}{\PYGZhy{}../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\PYG{g+go}{\PYGZbs{} No newline at end of file}
\end{sphinxVerbatim}

\sphinxAtStartPar
As you can see, this action does not show up as a move, but instead
a deletion and addition of a new file. Why? Because the content
that is tracked is the actual symlink, and due to the change in
relative location, the symlink needed to change. Hence, what looks
and feels like a move on the file system for you is actually a
move plus a content change for Git.


\end{findoutmore}

\index{fix@\spxentry{fix}!git\sphinxhyphen{}annex command@\spxentry{git\sphinxhyphen{}annex command}}\index{git\sphinxhyphen{}annex command@\spxentry{git\sphinxhyphen{}annex command}!fix@\spxentry{fix}}\ignorespaces \begin{gitusernote}[label={gun-annex-fix}, before title={\thetcbcounter\ }, float, floatplacement=tp, check odd page=true]{‘datalad save’ internals: ‘git annex fix’}
\label{\detokenize{basics/101-136-filesystem:gun-annex-fix}}

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{datalad save}} command internally uses a \sphinxcode{\sphinxupquote{git commit}} to save changes to a dataset.
\sphinxcode{\sphinxupquote{git commit}} in turn triggers a \sphinxcode{\sphinxupquote{git annex fix}}
command. This git\sphinxhyphen{}annex command fixes up links that have become broken
to again point to annexed content, and is responsible for cleaning up
what needs to be cleaned up. Thanks, git\sphinxhyphen{}annex!


\end{gitusernote}

\sphinxAtStartPar
Finally, let’s clean up:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+go}{HEAD is now at 39e55c8 add container and execute analysis within container}
\end{sphinxVerbatim}

\index{move file to other dataset@\spxentry{move file to other dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!move file to other dataset@\spxentry{move file to other dataset}}\ignorespaces 

\subsection{Moving files across dataset boundaries}
\label{\detokenize{basics/101-136-filesystem:moving-files-across-dataset-boundaries}}\label{\detokenize{basics/101-136-filesystem:index-6}}
\sphinxAtStartPar
Generally speaking, moving files across dataset hierarchies is not advised.
While DataLad blurs the dataset boundaries to ease working in nested dataset,
the dataset boundaries do still exist. If you move a file from one subdataset
into another, or up or down a dataset hierarchy, you will move it out of the
version control it was in (i.e., from one \sphinxcode{\sphinxupquote{.git}} directory into a different
one). From the perspective of the first subdataset, the file will be deleted,
and from the perspective of the receiving dataset, the file will be added to
the dataset, but straight out of nowhere, with none of its potential history
from its original dataset attached to it. Before moving a file, consider whether
\sphinxstyleemphasis{copying} it (outlined in the next but one paragraph) might be a more suitable
alternative.

\sphinxAtStartPar
If you are willing to sacrifice%
\begin{footnote}\sphinxAtStartFootnote
Or rather: split \textendash{} basically, the file is getting a fresh new start.
Think of it as some sort of witness\sphinxhyphen{}protection program with complete
disrespect for provenance…
%
\end{footnote} the file’s history and move it to a
different dataset, the procedure differs between annexed files, and files
stored in Git.

\sphinxAtStartPar
For files that Git manages, moving and saving is simple: Move the file, and
save the resulting changes in \sphinxstyleemphasis{both} affected datasets (this can be done with
one recursive \sphinxcode{\sphinxupquote{datalad save}} from a top\sphinxhyphen{}level dataset, though).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }notes.txt\PYG{+w}{ }midterm\PYGZus{}project/notes.txt
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}r
\PYG{g+go}{ modified: midterm\PYGZus{}project (dataset)}
\PYG{g+go}{untracked: midterm\PYGZus{}project/notes.txt (file)}
\PYG{g+go}{  deleted: notes.txt (file)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}moved notes.txt from root of top\PYGZhy{}ds to midterm subds\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{delete(ok): notes.txt (file)}
\PYG{g+go}{add(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{action summary:}
\PYG{g+go}{  add (ok: 3)}
\PYG{g+go}{  delete (ok: 1)}
\PYG{g+go}{  save (notneeded: 2, ok: 2)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note how the history of \sphinxcode{\sphinxupquote{notes.txt}} does not exist in the subdataset \textendash{} it appears
as if the file was generated at once, instead of successively over the course:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }notes.txt
\PYG{g+go}{commit 1e273c59✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    moved notes.txt from root of top\PYGZhy{}ds to midterm subds}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s undo this change again. It requires a \sphinxcode{\sphinxupquote{git reset}}s in \sphinxstyleemphasis{both} datasets.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} in midterm\PYGZus{}project}
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}

\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} in DataLad\PYGZhy{}101}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}
\PYG{g+go}{HEAD is now at 4f00ad0 [DATALAD RUNCMD] rerun analysis in container}
\PYG{g+go}{HEAD is now at 39e55c8 add container and execute analysis within container}
\end{sphinxVerbatim}

\sphinxAtStartPar
The process is a bit more complex for annexed files. Let’s do it wrong, first:
What happens if we move an annexed file in the same way as \sphinxcode{\sphinxupquote{notes.txt}}?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }books/TLCL.pdf\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}r
\PYG{g+go}{  deleted: books/TLCL.pdf (symlink)}
\PYG{g+go}{ modified: midterm\PYGZus{}project (dataset)}
\PYG{g+go}{untracked: midterm\PYGZus{}project/TLCL.pdf (symlink)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}move annexed file around\PYGZdq{}}
\PYG{g+go}{add(ok): TLCL.pdf (file) [TLCL.pdf is a git\PYGZhy{}annex symlink.]}
\PYG{g+go}{save(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{delete(ok): books/TLCL.pdf (symlink)}
\PYG{g+go}{add(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{action summary:}
\PYG{g+go}{  add (ok: 3)}
\PYG{g+go}{  delete (ok: 1)}
\PYG{g+go}{  save (notneeded: 2, ok: 2)}
\end{sphinxVerbatim}

\sphinxAtStartPar
At this point, this does not look that different to the result of moving
\sphinxcode{\sphinxupquote{notes.txt}}. Note, though, that the deleted and untracked PDFs are symlinks \textendash{}
and therein lies the problem: What was moved was not the file content (which is
still in the annex of the top\sphinxhyphen{}level dataset, \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}), but its symlink that
was stored in Git. After moving the file, the symlink is broken, and git\sphinxhyphen{}annex
has no way of finding out where the file content could be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }annex\PYG{+w}{ }whereis\PYG{+w}{ }TLCL.pdf
\PYG{g+go}{whereis TLCL.pdf (0 copies) failed}
\PYG{g+go}{whereis: 1 failed}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s rewind, and find out how to do it correctly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}
\PYG{g+go}{HEAD is now at 4f00ad0 [DATALAD RUNCMD] rerun analysis in container}
\PYG{g+go}{HEAD is now at 39e55c8 add container and execute analysis within container}
\end{sphinxVerbatim}

\sphinxAtStartPar
The crucial step to remember is to get the annexed file out of the annex prior
to moving it. For this, we need to fall back to git\sphinxhyphen{}annex commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }annex\PYG{+w}{ }unlock\PYG{+w}{ }books/TLCL.pdf
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }books/TLCL.pdf\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}r
\PYG{g+go}{unlock books/TLCL.pdf ok}
\PYG{g+gp+gpVirtualEnv}{(recording state in git...)}
\PYG{g+go}{  deleted: books/TLCL.pdf (file)}
\PYG{g+go}{ modified: midterm\PYGZus{}project (dataset)}
\PYG{g+go}{untracked: midterm\PYGZus{}project/TLCL.pdf (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Afterwards, a (recursive) \sphinxcode{\sphinxupquote{datalad save}} commits the removal of the book from
DataLad\sphinxhyphen{}101, and adds the file content into the annex of \sphinxcode{\sphinxupquote{midterm\_project}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}move book into midterm\PYGZus{}project\PYGZdq{}}
\PYG{g+go}{add(ok): TLCL.pdf (file)}
\PYG{g+go}{save(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{delete(ok): books/TLCL.pdf (file)}
\PYG{g+go}{add(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{action summary:}
\PYG{g+go}{  add (ok: 3)}
\PYG{g+go}{  delete (ok: 1)}
\PYG{g+go}{  save (notneeded: 2, ok: 2)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Even though you did split the file’s history, at least its content is in the
correct dataset now:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }annex\PYG{+w}{ }whereis\PYG{+w}{ }TLCL.pdf
\PYG{g+go}{whereis TLCL.pdf (1 copy)}
\PYG{g+go}{  	✂UUID✂ \PYGZhy{}\PYGZhy{} me@appveyor\PYGZhy{}vm:\PYGZti{}/dl\PYGZhy{}101/DataLad\PYGZhy{}101/midterm\PYGZus{}project [here]}
\PYG{g+go}{ok}
\end{sphinxVerbatim}

\sphinxAtStartPar
But more than showing you how it can be done, if necessary, this paragraph
hopefully convinced you that moving files across dataset boundaries is not
convenient. It can be a confusing and potentially “file\sphinxhyphen{}content\sphinxhyphen{}losing”\sphinxhyphen{}dangerous
process, but it also dissociates a file from its provenance that is captured
in its previous dataset, with no machine\sphinxhyphen{}readable way to learn about the move
easily. A better alternative may be copying files with the \sphinxcode{\sphinxupquote{datalad copy\sphinxhyphen{}file}}
command introduced in detail in the online\sphinxhyphen{}handbook, and demonstrated in the next
but one paragraph. Let’s quickly clean up by moving the file back:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} in midterm\PYGZus{}project}
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }annex\PYG{+w}{ }unannex\PYG{+w}{ }TLCL.pdf
\PYG{g+go}{unannex TLCL.pdf ok}
\PYG{g+gp+gpVirtualEnv}{(recording state in git...)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }TLCL.pdf\PYG{+w}{ }../books
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}move book back from midterm\PYGZus{}project\PYGZdq{}}
\PYG{g+go}{delete(ok): TLCL.pdf (symlink)}
\PYG{g+go}{save(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{add(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{add(ok): books/TLCL.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{action summary:}
\PYG{g+go}{  add (ok: 3)}
\PYG{g+go}{  delete (ok: 1)}
\PYG{g+go}{  save (notneeded: 2, ok: 2)}
\end{sphinxVerbatim}

\index{copy file@\spxentry{copy file}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!copy file@\spxentry{copy file}}\ignorespaces 

\subsection{Copy files}
\label{\detokenize{basics/101-136-filesystem:copy-files}}\label{\detokenize{basics/101-136-filesystem:index-7}}
\sphinxAtStartPar
Let’s create a copy of an annexed file, using the Unix
command \sphinxcode{\sphinxupquote{cp}} to copy.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cp\PYG{+w}{ }books/TLCL.pdf\PYG{+w}{ }copyofTLCL.pdf
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: copyofTLCL.pdf (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
That’s expected. The copy shows up as a new, untracked
file. Let’s save it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add copy of TLCL.pdf\PYGZdq{}}
\PYG{g+go}{add(ok): copyofTLCL.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYGZhy{}p
\PYG{g+go}{commit ebbe6b93✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    add copy of TLCL.pdf}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/copyofTLCL.pdf b/copyofTLCL.pdf}
\PYG{g+go}{new file mode 120000}
\PYG{g+go}{index 0000000..34328e2}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/copyofTLCL.pdf}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1 @@}
\PYG{g+go}{+.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\PYG{g+go}{\PYGZbs{} No newline at end of file}
\end{sphinxVerbatim}

\sphinxAtStartPar
That’s it. For that magic that just happend, read the
\textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-link-copies}} {\hyperref[\detokenize{basics/101-136-filesystem:fom-link-copies}]{\sphinxcrossref{\DUrole{std,std-ref}{on linking identical content}}}} (\autopageref*{\detokenize{basics/101-136-filesystem:fom-link-copies}}).

\index{content pointer file@\spxentry{content pointer file}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!content pointer file@\spxentry{content pointer file}}\ignorespaces \begin{findoutmore}[label={fom-link-copies}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Symlinks!}
\label{\detokenize{basics/101-136-filesystem:fom-link-copies}}

\sphinxAtStartPar
If you have read the additional content in the section
{\hyperref[\detokenize{basics/101-115-symlinks:symlink}]{\sphinxcrossref{\DUrole{std,std-ref}{Data integrity}}}} (\autopageref*{\detokenize{basics/101-115-symlinks:symlink}}), you know that the same file content
is only stored once, and copies of the same file point to
the same location in the object tree.

\sphinxAtStartPar
Let’s check that out:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }copyofTLCL.pdf
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }books/TLCL.pdf
\PYG{g+go}{lrwxrwxrwx 1 elena elena 128 2019\PYGZhy{}06\PYGZhy{}18 16:13 copyofTLCL.pdf \PYGZhy{}\PYGZgt{} .git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 131 2019\PYGZhy{}06\PYGZhy{}18 16:13 books/TLCL.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
Indeed! Apart from their relative location (\sphinxcode{\sphinxupquote{.git}} versus
\sphinxcode{\sphinxupquote{../.git}}) their symlink is identical. Thus, even though two
copies of the book exist in your dataset, your disk needs to
store it only once.

\sphinxAtStartPar
In most cases, this is just an interesting fun\sphinxhyphen{}fact, but beware
when dropping content with \sphinxcode{\sphinxupquote{datalad drop}}
as outlined in {\hyperref[\detokenize{basics/101-136-filesystem:remove}]{\sphinxcrossref{\DUrole{std,std-ref}{Remove annexed content entirely}}}} (\autopageref*{\detokenize{basics/101-136-filesystem:remove}}):
If you drop the content of one copy of a file, all
other copies will lose this content as well.


\end{findoutmore}

\sphinxAtStartPar
Finally, let’s clean up:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+go}{HEAD is now at de2d23c move book back from midterm\PYGZus{}project}
\end{sphinxVerbatim}

\index{copy file to other dataset@\spxentry{copy file to other dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!copy file to other dataset@\spxentry{copy file to other dataset}}\ignorespaces 

\subsection{Copy files across dataset boundaries}
\label{\detokenize{basics/101-136-filesystem:copy-files-across-dataset-boundaries}}\label{\detokenize{basics/101-136-filesystem:index-9}}\label{\detokenize{basics/101-136-filesystem:copyfilefs}}
\sphinxAtStartPar
Instead of moving files across dataset boundaries, \sphinxstyleemphasis{copying} them is an easier
and actually supported method.
The DataLad command that can be used for this is \sphinxcode{\sphinxupquote{datalad copy\sphinxhyphen{}file}}.
This command allows to copy files
(from any dataset or non\sphinxhyphen{}dataset location, annexed or not annexed) into a dataset.
If the file is copied from a dataset and is annexed, its recorded URLs
are added to the new dataset as well, and there is no need for unannex’ing the
or even retrieving its file contents. Let’s see this in action for a file
stored in Git, and a file stored in annex:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }copy\PYGZhy{}file\PYG{+w}{ }notes.txt\PYG{+w}{ }midterm\PYGZus{}project\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+go}{copy\PYGZus{}file(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/notes.txt}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }copy\PYGZhy{}file\PYG{+w}{ }books/bash\PYGZus{}guide.pdf\PYG{+w}{ }midterm\PYGZus{}project\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+go}{copy\PYGZus{}file(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/books/bash\PYGZus{}guide.pdf [/home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/midterm\PYGZus{}project/bash\PYGZus{}guide.pdf]}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Both files have been successfully transferred and saved to the subdataset, and
no unannexing was necessary.
\sphinxcode{\sphinxupquote{notes.txt}} was annexed in the subdataset, though, as this subdataset
was not configured with the \sphinxcode{\sphinxupquote{text2git}} {\hyperref[\detokenize{glossary:term-run-procedure}]{\sphinxtermref{\DUrole{xref,std,std-term}{run procedure}}}}.

\fvset{hllines={, 3, 10,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }tree\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+go}{midterm\PYGZus{}project}
\PYG{g+go}{├── bash\PYGZus{}guide.pdf \PYGZhy{}\PYGZgt{} .git/annex/objects/31/wQ/SHA256E\PYGZhy{}s1198170\PYGZhy{}\PYGZhy{}d08f2c7b✂SHA162d6b24a20cb5abae4d4402c.pdf/SHA256E\PYGZhy{}s1198170\PYGZhy{}\PYGZhy{}d08f2c7b✂SHA162d6b24a20cb5abae4d4402c.pdf}
\PYG{g+go}{├── CHANGELOG.md}
\PYG{g+go}{├── code}
\PYG{g+go}{│   ├── README.md}
\PYG{g+go}{│   └── script.py}
\PYG{g+go}{├── input}
\PYG{g+go}{│   └── iris.csv \PYGZhy{}\PYGZgt{} .git/annex/objects/qz/Jg/✂/MD5E\PYGZhy{}s3975\PYGZhy{}\PYGZhy{}341a3b52✂MD5.csv}
\PYG{g+go}{├── notes.txt \PYGZhy{}\PYGZgt{} .git/annex/objects/p1/jm/✂/MD5E\PYGZhy{}s5080\PYGZhy{}\PYGZhy{}73ec6967✂MD5.txt}
\PYG{g+go}{├── pairwise\PYGZus{}relationships.png \PYGZhy{}\PYGZgt{} .git/annex/objects/q1/gp/✂/MD5E\PYGZhy{}s261062\PYGZhy{}\PYGZhy{}025dc493✂MD5.png}
\PYG{g+go}{├── prediction\PYGZus{}report.csv \PYGZhy{}\PYGZgt{} .git/annex/objects/8q/6M/✂/MD5E\PYGZhy{}s345\PYGZhy{}\PYGZhy{}a88cab39✂MD5.csv}
\PYG{g+go}{└── README.md}

\PYG{g+go}{2 directories, 9 files}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
The subdataset has two new commits as \sphinxcode{\sphinxupquote{datalad copy\sphinxhyphen{}file}} can take care
of saving changes in the copied\sphinxhyphen{}to dataset, and thus the new subdataset state
would need to be saved in the superdataset.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}r
\PYG{g+go}{ modified: midterm\PYGZus{}project (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Still, just as when we \sphinxstyleemphasis{moved} files across dataset boundaries, the files’
provenance record is lost:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }notes.txt
\PYG{g+go}{commit 5b8d330f✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    [DATALAD] Recorded changes}
\end{sphinxVerbatim}

\sphinxAtStartPar
Nevertheless, copying files with \sphinxcode{\sphinxupquote{datalad copy\sphinxhyphen{}file}} is easier and safer
than moving them with standard Unix commands, especially so for annexed files.
A more detailed introduction to \sphinxcode{\sphinxupquote{datalad copy\sphinxhyphen{}file}} and a concrete
use case can be found in the online\sphinxhyphen{}handbook.

\sphinxAtStartPar
Let’s clean up:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}2
\PYG{g+go}{HEAD is now at b2b6855 move book back from midterm\PYGZus{}project}
\end{sphinxVerbatim}


\section{Move datasets}
\label{\detokenize{basics/101-136-filesystem:move-datasets}}
\index{move subdataset@\spxentry{move subdataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!move subdataset@\spxentry{move subdataset}}\ignorespaces 

\subsection{Move/rename a subdirectory or subdataset}
\label{\detokenize{basics/101-136-filesystem:move-rename-a-subdirectory-or-subdataset}}\label{\detokenize{basics/101-136-filesystem:index-10}}
\sphinxAtStartPar
Moving or renaming subdirectories, especially if they are subdatasets,
\sphinxstyleemphasis{can} be a minefield. But in principle, a safe way to proceed is using
the Unix \sphinxcode{\sphinxupquote{ mv}} command to move or rename, and the \sphinxcode{\sphinxupquote{datalad save}}
to clean up afterwards, just as in the examples above. Make sure to
\sphinxstylestrong{not} use \sphinxcode{\sphinxupquote{git mv}}, especially for subdatasets.

\sphinxAtStartPar
Let’s, for example, rename the \sphinxcode{\sphinxupquote{books}} directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }books/\PYG{+w}{ }readings
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: readings (directory)}
\PYG{g+go}{  deleted: books/TLCL.pdf (symlink)}
\PYG{g+go}{  deleted: books/bash\PYGZus{}guide.pdf (symlink)}
\PYG{g+go}{  deleted: books/byte\PYGZhy{}of\PYGZhy{}python.pdf (symlink)}
\PYG{g+go}{  deleted: books/progit.pdf (symlink)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}renamed directory\PYGZdq{}}
\PYG{g+go}{delete(ok): books/TLCL.pdf (symlink)}
\PYG{g+go}{delete(ok): books/bash\PYGZus{}guide.pdf (symlink)}
\PYG{g+go}{delete(ok): books/byte\PYGZhy{}of\PYGZhy{}python.pdf (symlink)}
\PYG{g+go}{delete(ok): books/progit.pdf (symlink)}
\PYG{g+go}{add(ok): readings/TLCL.pdf (file)}
\PYG{g+go}{add(ok): readings/bash\PYGZus{}guide.pdf (file)}
\PYG{g+go}{add(ok): readings/byte\PYGZhy{}of\PYGZhy{}python.pdf (file)}
\PYG{g+go}{add(ok): readings/progit.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is easy, and complication free. Moving (as in: changing the location, instead of
the name) the directory would work in the
same fashion, and a \sphinxcode{\sphinxupquote{datalad save}} would fix broken symlinks afterwards.
Let’s quickly clean this up:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+go}{HEAD is now at de2d23c move book back from midterm\PYGZus{}project}
\end{sphinxVerbatim}

\sphinxAtStartPar
But let’s now try to move the \sphinxcode{\sphinxupquote{longnow}} subdataset into the root of the
superdataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }recordings/longnow\PYG{+w}{ }.
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: longnow (directory)}
\PYG{g+go}{  deleted: recordings/longnow (dataset)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}moved subdataset\PYGZdq{}}
\PYG{g+go}{delete(ok): recordings/longnow (dataset)}
\PYG{g+go}{add(ok): longnow (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\sphinxAtStartPar
This seems fine, and it has indeed worked.
However, \sphinxstyleemphasis{reverting} a commit like this is tricky, at the moment. This could
lead to trouble if you at a later point try to revert or rebase chunks of your
history including this move. Therefore, if you can, try not to move subdatasets
around. For now we’ll clean up in a somewhat “hacky” way: Reverting, and
moving remaining subdataset contents back to their original place by hand
to take care of the unwanted changes the commit reversal introduced.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+go}{warning: unable to rmdir \PYGZsq{}longnow\PYGZsq{}: Directory not empty}
\PYG{g+go}{HEAD is now at de2d23c move book back from midterm\PYGZus{}project}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }\PYGZhy{}f\PYG{+w}{ }longnow\PYG{+w}{ }recordings
\end{sphinxVerbatim}

\sphinxAtStartPar
The take\sphinxhyphen{}home message therefore is that it is best not to move subdatasets,
but very possible to move subdirectories if necessary. In both cases, do not
attempt moving with the \sphinxcode{\sphinxupquote{git mv}}, but stick with \sphinxcode{\sphinxupquote{ mv}} and
a subsequent \sphinxcode{\sphinxupquote{datalad save}}.

\index{move superdataset@\spxentry{move superdataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!move superdataset@\spxentry{move superdataset}}\ignorespaces 

\subsection{Move/rename a superdataset}
\label{\detokenize{basics/101-136-filesystem:move-rename-a-superdataset}}\label{\detokenize{basics/101-136-filesystem:index-11}}
\sphinxAtStartPar
Once created, a DataLad superdataset may not be in an optimal
place on your file system, or have the best name.

\sphinxAtStartPar
After a while, you might think that the dataset would fit much
better into \sphinxcode{\sphinxupquote{/home/user/research\_projects/}} than in
\sphinxcode{\sphinxupquote{/home/user/Documents/tmp/}}. Or maybe at
some point, a long name such as \sphinxcode{\sphinxupquote{My\sphinxhyphen{}very\sphinxhyphen{}first\sphinxhyphen{}DataLad\sphinxhyphen{}project\sphinxhyphen{}wohoo\sphinxhyphen{}I\sphinxhyphen{}am\sphinxhyphen{}so\sphinxhyphen{}excited}}
does not look pretty in your terminal prompt anymore, and going for
\sphinxcode{\sphinxupquote{finance\sphinxhyphen{}2019}} seems more professional.

\sphinxAtStartPar
These will be situations in which you want to rename or move
a superdataset. Will that break anything?

\sphinxAtStartPar
In all standard situations, no, it will be completely fine.
You can use standard Unix commands such as \sphinxcode{\sphinxupquote{mv}} to do it,
and also whichever graphical user interface or explorer you may
use.

\sphinxAtStartPar
Beware of one thing though: If your dataset either is a sibling
or has a sibling with the source being a path, moving or renaming
the dataset will break the linkage between the datasets. This can
be fixed easily though. Let’s demo this.

\index{move subdataset@\spxentry{move subdataset}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!move subdataset@\spxentry{move subdataset}}\ignorespaces 
\sphinxAtStartPar
As section {\hyperref[\detokenize{basics/101-122-config:config}]{\sphinxcrossref{\DUrole{std,std-ref}{Local configuration}}}} (\autopageref*{\detokenize{basics/101-122-config:config}}) explains, each
sibling is registered in \sphinxcode{\sphinxupquote{.git/config}} in a “submodule” section.
Let’s look at how our sibling “roommate” is registered there:

\fvset{hllines={, 18, 19,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }.git/config
\PYG{g+go}{[core]}
\PYG{g+go}{	repositoryformatversion = 0}
\PYG{g+go}{	filemode = true}
\PYG{g+go}{	bare = false}
\PYG{g+go}{	logallrefupdates = true}
\PYG{g+go}{	editor = nano}
\PYG{g+go}{[annex]}
\PYG{g+go}{	uuid = 46b169aa\PYGZhy{}bb91\PYGZhy{}42d6\PYGZhy{}be06\PYGZhy{}355d957fb4f7}
\PYG{g+go}{	version = 10}
\PYG{g+go}{[filter \PYGZdq{}annex\PYGZdq{}]}
\PYG{g+go}{	smudge = git\PYGZhy{}annex smudge \PYGZhy{}\PYGZhy{} \PYGZpc{}f}
\PYG{g+go}{	clean = git\PYGZhy{}annex smudge \PYGZhy{}\PYGZhy{}clean \PYGZhy{}\PYGZhy{} \PYGZpc{}f}
\PYG{g+go}{	process = git\PYGZhy{}annex filter\PYGZhy{}process}
\PYG{g+go}{[submodule \PYGZdq{}recordings/longnow\PYGZdq{}]}
\PYG{g+go}{	active = true}
\PYG{g+go}{	url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\PYG{g+go}{[remote \PYGZdq{}roommate\PYGZdq{}]}
\PYG{g+go}{	url = ../mock\PYGZus{}user/DataLad\PYGZhy{}101}
\PYG{g+go}{	fetch = +refs/heads/*:refs/remotes/roommate/*}
\PYG{g+go}{	annex\PYGZhy{}uuid = ✂UUID✂}
\PYG{g+go}{	annex\PYGZhy{}ignore = false}
\PYG{g+go}{[submodule \PYGZdq{}midterm\PYGZus{}project\PYGZdq{}]}
\PYG{g+go}{	active = true}
\PYG{g+go}{	url = ./midterm\PYGZus{}project}
\PYG{g+go}{[submodule \PYGZdq{}longnow\PYGZdq{}]}
\PYG{g+go}{	active = true}
\PYG{g+go}{	url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
As you can see, its “url” is specified as a relative path. Say your
room mate’s directory is a dataset you would want to move. Let’s see
what happens if we move the dataset such that the path does not point
to the dataset anymore:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} add an intermediate directory}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../mock\PYGZus{}user
\PYG{g+gp}{\PYGZdl{} }mkdir\PYG{+w}{ }onemoredir
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} move your room mates dataset into this new directory}
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }DataLad\PYGZhy{}101\PYG{+w}{ }onemoredir
\end{sphinxVerbatim}

\sphinxAtStartPar
This means that relative to your \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}, your room mates
dataset is not at \sphinxcode{\sphinxupquote{../mock\_user/DataLad\sphinxhyphen{}101}} anymore, but in
\sphinxcode{\sphinxupquote{../mock\_user/onemoredir/DataLad\sphinxhyphen{}101}}. The path specified in
the configuration file is thus wrong now.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} navigate back into your dataset}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../DataLad\PYGZhy{}101
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} attempt a datalad update}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }update
\PYG{g+go}{update(error): . (dataset) [Fetch failed: CommandError(CommandError: \PYGZsq{}git \PYGZhy{}c diff.ignoreSubmodules=none \PYGZhy{}c core.quotepath=false fetch \PYGZhy{}\PYGZhy{}verbose \PYGZhy{}\PYGZhy{}progress \PYGZhy{}\PYGZhy{}no\PYGZhy{}recurse\PYGZhy{}submodules \PYGZhy{}\PYGZhy{}prune roommate\PYGZsq{} failed with exitcode 128 under /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 [err: \PYGZsq{}fatal: \PYGZsq{}../mock\PYGZus{}user/DataLad\PYGZhy{}101\PYGZsq{} does not appear to be a git repository}
\PYG{g+go}{fatal: Could not read from remote repository.}

\PYG{g+go}{Please make sure you have the correct access rights}
\PYG{g+go}{and the repository exists.\PYGZsq{}])] [CommandError: \PYGZsq{}git \PYGZhy{}c diff.ignoreSubmodules=none \PYGZhy{}c core.quotepath=false fetch \PYGZhy{}\PYGZhy{}verbose \PYGZhy{}\PYGZhy{}progress \PYGZhy{}\PYGZhy{}no\PYGZhy{}recurse\PYGZhy{}submodules \PYGZhy{}\PYGZhy{}prune roommate\PYGZsq{} failed with exitcode 128 under /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 [err: \PYGZsq{}fatal: \PYGZsq{}../mock\PYGZus{}user/DataLad\PYGZhy{}101\PYGZsq{} does not appear to be a git repository}
\PYG{g+go}{fatal: Could not read from remote repository.}

\PYG{g+go}{Please make sure you have the correct access rights}
\PYG{g+go}{and the repository exists.\PYGZsq{}]]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here we go:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}fatal: \PYGZsq{}../mock\PYGZus{}user/DataLad\PYGZhy{}101\PYGZsq{} does not appear to be a git repository
 fatal: Could not read from remote repository.
\end{sphinxVerbatim}

\sphinxAtStartPar
Git seems pretty insistent (given the amount of error messages) that
it cannot seem to find a Git repository at the location the \sphinxcode{\sphinxupquote{.git/config}}
file specified. Luckily, we can provide this information. Edit the file with
an editor of your choice and fix the path from
\sphinxcode{\sphinxupquote{url = ../mock\_user/DataLad\sphinxhyphen{}101}} to
\sphinxcode{\sphinxupquote{url = ../mock\_user/onemoredir/DataLad\sphinxhyphen{}101}}.

\sphinxAtStartPar
Below, we are using the stream editor \dlhbhref{W1Q}{sed}
for this operation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }sed\PYG{+w}{ }\PYGZhy{}i\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}s/..\PYGZbs{}/mock\PYGZus{}user\PYGZbs{}/DataLad\PYGZhy{}101/..\PYGZbs{}/mock\PYGZus{}user\PYGZbs{}/onemoredir\PYGZbs{}/DataLad\PYGZhy{}101/\PYGZsq{}}\PYG{+w}{ }.git/config
\end{sphinxVerbatim}

\sphinxAtStartPar
This is how the file looks now:

\fvset{hllines={, 19,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }.git/config
\PYG{g+go}{[core]}
\PYG{g+go}{	repositoryformatversion = 0}
\PYG{g+go}{	filemode = true}
\PYG{g+go}{	bare = false}
\PYG{g+go}{	logallrefupdates = true}
\PYG{g+go}{	editor = nano}
\PYG{g+go}{[annex]}
\PYG{g+go}{	uuid = 46b169aa\PYGZhy{}bb91\PYGZhy{}42d6\PYGZhy{}be06\PYGZhy{}355d957fb4f7}
\PYG{g+go}{	version = 10}
\PYG{g+go}{[filter \PYGZdq{}annex\PYGZdq{}]}
\PYG{g+go}{	smudge = git\PYGZhy{}annex smudge \PYGZhy{}\PYGZhy{} \PYGZpc{}f}
\PYG{g+go}{	clean = git\PYGZhy{}annex smudge \PYGZhy{}\PYGZhy{}clean \PYGZhy{}\PYGZhy{} \PYGZpc{}f}
\PYG{g+go}{	process = git\PYGZhy{}annex filter\PYGZhy{}process}
\PYG{g+go}{[submodule \PYGZdq{}recordings/longnow\PYGZdq{}]}
\PYG{g+go}{	active = true}
\PYG{g+go}{	url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\PYG{g+go}{[remote \PYGZdq{}roommate\PYGZdq{}]}
\PYG{g+go}{	url = ../mock\PYGZus{}user/onemoredir/DataLad\PYGZhy{}101}
\PYG{g+go}{	fetch = +refs/heads/*:refs/remotes/roommate/*}
\PYG{g+go}{	annex\PYGZhy{}uuid = ✂UUID✂}
\PYG{g+go}{	annex\PYGZhy{}ignore = false}
\PYG{g+go}{[submodule \PYGZdq{}midterm\PYGZus{}project\PYGZdq{}]}
\PYG{g+go}{	active = true}
\PYG{g+go}{	url = ./midterm\PYGZus{}project}
\PYG{g+go}{[submodule \PYGZdq{}longnow\PYGZdq{}]}
\PYG{g+go}{	active = true}
\PYG{g+go}{	url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Let’s try to update now:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }update
\PYG{g+go}{update(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Nice! We fixed it!
Therefore, if a dataset you move or rename is known to other
datasets from its path, or identifies siblings with paths,
make sure to adjust them in the \sphinxcode{\sphinxupquote{.git/config}} file.

\sphinxAtStartPar
To clean up, we’ll redo the move of the dataset and the
modification in \sphinxcode{\sphinxupquote{.git/config}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../mock\PYGZus{}user\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }mv\PYG{+w}{ }onemoredir/DataLad\PYGZhy{}101\PYG{+w}{ }.
\PYG{g+gp}{\PYGZdl{} }rm\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }onemoredir
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../DataLad\PYGZhy{}101\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }sed\PYG{+w}{ }\PYGZhy{}i\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}s/..\PYGZbs{}/mock\PYGZus{}user\PYGZbs{}/onemoredir\PYGZbs{}/DataLad\PYGZhy{}101/..\PYGZbs{}/mock\PYGZus{}user\PYGZbs{}/DataLad\PYGZhy{}101/\PYGZsq{}}\PYG{+w}{ }.git/config
\end{sphinxVerbatim}


\section{Stop tracking}
\label{\detokenize{basics/101-136-filesystem:stop-tracking}}
\index{stop tracking file@\spxentry{stop tracking file}!with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}}\index{with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}!stop tracking file@\spxentry{stop tracking file}}\ignorespaces 

\subsection{Get contents out of git\sphinxhyphen{}annex}
\label{\detokenize{basics/101-136-filesystem:get-contents-out-of-git-annex}}\label{\detokenize{basics/101-136-filesystem:index-13}}
\sphinxAtStartPar
Files in your dataset can either be handled by {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} or {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git\sphinxhyphen{}annex}}}}.
Self\sphinxhyphen{}made or predefined configurations to \sphinxcode{\sphinxupquote{.gitattributes}}, defaults, or the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}to\sphinxhyphen{}git}} option to \sphinxcode{\sphinxupquote{datalad save}} allow you to control which tool
does what on up to single\sphinxhyphen{}file basis. Accidentally though, you may give a file of yours
to git\sphinxhyphen{}annex when it was intended to be stored in Git, or you want to get a previously
annexed file into Git.

\sphinxAtStartPar
Consider you intend to share the cropped \sphinxcode{\sphinxupquote{.png}} images you created from the
\sphinxcode{\sphinxupquote{longnow}} logos. Would you publish your \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset so {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}
or {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}, these files would not be available to others, because annexed
dataset contents cannot be published to these services.
Even though you could find a third party service of your choice
and publish your dataset \sphinxstyleemphasis{and} the annexed data as described in  {\hyperref[\detokenize{basics/101-138-sharethirdparty:sharethirdparty}]{\sphinxcrossref{\DUrole{std,std-ref}{Beyond shared infrastructure}}}} (\autopageref*{\detokenize{basics/101-138-sharethirdparty:sharethirdparty}}),
you are feeling lazy today. And since it
is only two files, and they are quite small, you decide to store them in Git \textendash{}
this way, the files would be available without configuring an external data
store.

\sphinxAtStartPar
To get a file out of git\sphinxhyphen{}annex’s hands you need to \sphinxstyleemphasis{unannex} it. This is
done with the git\sphinxhyphen{}annex command \sphinxcode{\sphinxupquote{git annex unannex}}. Let’s see how it
works:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }annex\PYG{+w}{ }unannex\PYG{+w}{ }recordings/*logo\PYGZus{}small.jpg
\PYG{g+go}{unannex recordings/interval\PYGZus{}logo\PYGZus{}small.jpg ok}
\PYG{g+go}{unannex recordings/salt\PYGZus{}logo\PYGZus{}small.jpg ok}
\PYG{g+gp+gpVirtualEnv}{(recording state in git...)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Your dataset notices the unannexing of the files as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }status
\PYG{g+go}{On branch main}
\PYG{g+go}{Changes to be committed:}
\PYG{g+go}{  (use \PYGZdq{}git restore \PYGZhy{}\PYGZhy{}staged \PYGZlt{}file\PYGZgt{}...\PYGZdq{} to unstage)}
\PYG{g+go}{	deleted:    recordings/interval\PYGZus{}logo\PYGZus{}small.jpg}
\PYG{g+go}{	deleted:    recordings/salt\PYGZus{}logo\PYGZus{}small.jpg}

\PYG{g+go}{Untracked files:}
\PYG{g+go}{  (use \PYGZdq{}git add \PYGZlt{}file\PYGZgt{}...\PYGZdq{} to include in what will be committed)}
\PYG{g+go}{	recordings/interval\PYGZus{}logo\PYGZus{}small.jpg}
\PYG{g+go}{	recordings/salt\PYGZus{}logo\PYGZus{}small.jpg}
\end{sphinxVerbatim}

\sphinxAtStartPar
Once files have been unannexed, they are “untracked” again, and you can save them
into Git, either by adding a rule to \sphinxcode{\sphinxupquote{.gitattributes}}, or with
\sphinxcode{\sphinxupquote{datalad save \sphinxhyphen{}\sphinxhyphen{}to\sphinxhyphen{}git}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}\PYGZhy{}to\PYGZhy{}git\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}save cropped logos to Git\PYGZdq{}}\PYG{+w}{ }recordings/*jpg
\PYG{g+go}{add(ok): recordings/interval\PYGZus{}logo\PYGZus{}small.jpg (file)}
\PYG{g+go}{add(ok): recordings/salt\PYGZus{}logo\PYGZus{}small.jpg (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that git\sphinxhyphen{}annex keeps the previously annexed file’s content in the annex for safety, to prevent accidental data loss.
If it is only few and small files that were unannexed, their size in the annex will not matter much.
If it is a lot of files or larger files that were accidentally annexed, you may want to drop the left\sphinxhyphen{}behind content using \sphinxcode{\sphinxupquote{git annex unused}} and \sphinxcode{\sphinxupquote{git annex dropunused}}.

\index{remove dataset annex@\spxentry{remove dataset annex}!with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}}\index{with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}!remove dataset annex@\spxentry{remove dataset annex}}\ignorespaces 

\subsection{Get all content out of the annex (remove the annex)}
\label{\detokenize{basics/101-136-filesystem:get-all-content-out-of-the-annex-remove-the-annex}}\label{\detokenize{basics/101-136-filesystem:uninit}}\label{\detokenize{basics/101-136-filesystem:index-14}}
\sphinxAtStartPar
In case you want to get all annexed contents out of a Dataset at once, you could turn to \dlhbhref{B1G}{git annex uninit}.
It is a command that can be used to stop using git annex entirely in a given dataset.
Running this command will unannex every file in the repository, remove all of git\sphinxhyphen{}annex’s other data, and remove the {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} branch, leaving you with a normal Git repository plus the previously annexed files.

\sphinxAtStartPar
Note a \sphinxcode{\sphinxupquote{datalad push}} will reinstate the git\sphinxhyphen{}annex branch \sphinxstyleemphasis{if} your dataset has siblings that still contain the annex branch.


\subsection{Delete (annexed) files}
\label{\detokenize{basics/101-136-filesystem:delete-annexed-files}}
\sphinxAtStartPar
Removing annexed file content from a dataset is possible in two different ways:
Either by removing the file from the current state of the repository
(which Git calls the \sphinxstyleemphasis{worktree}) but keeping the content in the history
of the dataset, or by removing content entirely from a dataset and its
history.

\index{remove file@\spxentry{remove file}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!remove file@\spxentry{remove file}}\ignorespaces 

\subsubsection{Removing a file, but keeping content in history}
\label{\detokenize{basics/101-136-filesystem:removing-a-file-but-keeping-content-in-history}}\label{\detokenize{basics/101-136-filesystem:index-15}}
\sphinxAtStartPar
An \sphinxcode{\sphinxupquote{rm \textless{}file\textgreater{}}} or \sphinxcode{\sphinxupquote{rm \sphinxhyphen{}rf \textless{}directory\textgreater{}}} with a subsequent \sphinxcode{\sphinxupquote{datalad save}}
will remove a file or directory, and save its removal. The file content however will
still be in the history of the dataset, and the file can be brought back to existence
by going back into the history of the dataset or reverting the removal commit:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} download a file}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }download\PYGZhy{}url\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Added flower mosaic from wikimedia\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }https://upload.wikimedia.org/wikipedia/commons/a/a5/Flower\PYGZus{}poster\PYGZus{}2.jpg\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}path\PYG{+w}{ }flowers.jpg
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }flowers.jpg
\PYG{g+go}{download\PYGZus{}url(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/flowers.jpg (file)}
\PYG{g+go}{add(ok): flowers.jpg (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 128 2019\PYGZhy{}06\PYGZhy{}18 16:13  2013 flowers.jpg \PYGZhy{}\PYGZgt{} .git/annex/objects/7q/9Z/✂/MD5E\PYGZhy{}s4487679\PYGZhy{}\PYGZhy{}3898ef0e✂MD5.jpg}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} removal is easy:}
\PYG{g+gp}{\PYGZdl{} }rm\PYG{+w}{ }flowers.jpg
\end{sphinxVerbatim}

\sphinxAtStartPar
This will lead to a dirty dataset status:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{  deleted: flowers.jpg (symlink)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If a removal happened by accident, a \sphinxcode{\sphinxupquote{git checkout \sphinxhyphen{}\sphinxhyphen{} flowers.jpg}} would undo
the removal at this stage. To stick with the removal and clean up the dataset
state, \sphinxcode{\sphinxupquote{datalad save}} will suffice:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}removed file again\PYGZdq{}}
\PYG{g+go}{delete(ok): flowers.jpg (symlink)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This commits the deletion of the file in the dataset’s history.
If this commit is reverted, the file comes back to existence:

\fvset{hllines={, 6,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+gp}{\PYGZdl{} }ls
\PYG{g+go}{HEAD is now at 682d11f Added flower mosaic from wikimedia}
\PYG{g+go}{books}
\PYG{g+go}{code}
\PYG{g+go}{flowers.jpg}
\PYG{g+go}{midterm\PYGZus{}project}
\PYG{g+go}{notes.txt}
\PYG{g+go}{recordings}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
In other words, with an \sphinxcode{\sphinxupquote{ rm}} and subsequent \sphinxcode{\sphinxupquote{datalad save}},
the symlink is removed, but the content is retained in the history.

\index{drop@\spxentry{drop}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!drop@\spxentry{drop}}\index{remove file@\spxentry{remove file}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!remove file@\spxentry{remove file}}\ignorespaces 

\subsubsection{Remove annexed content entirely}
\label{\detokenize{basics/101-136-filesystem:remove-annexed-content-entirely}}\label{\detokenize{basics/101-136-filesystem:remove}}\label{\detokenize{basics/101-136-filesystem:index-16}}
\sphinxAtStartPar
The command to remove file content entirely and irreversibly from a repository is
the \sphinxcode{\sphinxupquote{datalad drop}} command.
This command will delete the content stored in the annex of the dataset,
and can be very helpful to make a dataset more lean if the file content is
either irrelevant or can be retrieved from other sources easily. Think about a
situation in which a very large result file is computed by default
in some analysis, but is not relevant for any project, and can thus be removed.
Or if only the results of an analysis need to be kept, but the file contents from
its input datasets can be dropped at these input datasets are backed\sphinxhyphen{}up else
where. Because the command works on annexed contents, it will drop file \sphinxstyleemphasis{content}
from a dataset, but it will retain the symlink for this file (as this symlink
is stored in Git).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad drop}} can take any number of files.
If an entire dataset is specified, all file content in sub\sphinxhyphen{}\sphinxstyleemphasis{directories} is
dropped automatically, but for content in sub\sphinxhyphen{}\sphinxstyleemphasis{datasets} to be dropped, the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}r/\sphinxhyphen{}\sphinxhyphen{}recursive}} flag has to be included.
By default, DataLad will not drop any content that does not have at least
one verified remote copy that the content could be retrieved from again.
It is possible to drop the downloaded image, because thanks to
\sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}} its original location in the web is known:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }drop\PYG{+w}{ }flowers.jpg
\PYG{g+go}{drop(ok): flowers.jpg (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Currently, the file content is gone, but the symlink still exist. Opening the
remaining symlink will fail, but the content can be obtained easily again with
\sphinxcode{\sphinxupquote{datalad get}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }flowers.jpg
\PYG{g+go}{get(ok): flowers.jpg (file) [from web...]}
\end{sphinxVerbatim}

\sphinxAtStartPar
If a file has no verified remote copies, DataLad will only drop its
content if the user enforces it using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}reckless {[}MODE{]}}} option, where \sphinxcode{\sphinxupquote{{[}MODE{]}}} is either \sphinxcode{\sphinxupquote{modification}} (drop despite unsaved modifications), \sphinxcode{\sphinxupquote{availability}} (drop even though no other copy is known), \sphinxcode{\sphinxupquote{undead}} (only for datasets; would drop a dataset without announcing its death to linked dataset clones) or \sphinxcode{\sphinxupquote{kill}} (no safety checks at all are run).
We will demonstrate this by generating an empty file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }dd\PYG{+w}{ }\PYG{k}{if}\PYG{o}{=}/dev/zero\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }head\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }\PYG{l+m}{18520}\PYG{+w}{ }\PYGZgt{}\PYG{+w}{ }a.pdf
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add some file\PYGZdq{}}\PYG{+w}{ }a.pdf
\PYG{g+go}{add(ok): a.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
DataLad will safeguard dropping content that it cannot retrieve again:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }drop\PYG{+w}{ }a.pdf
\PYG{g+go}{drop(error): a.pdf (file) [unsafe; Could only verify the existence of 0 out of 1 necessary copy; (Use \PYGZhy{}\PYGZhy{}reckless availability to override this check, or adjust numcopies.)]}
\end{sphinxVerbatim}

\sphinxAtStartPar
But with \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}reckless availability}} it will work:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }drop\PYG{+w}{ }\PYGZhy{}\PYGZhy{}reckless\PYG{+w}{ }availability\PYG{+w}{ }a.pdf
\PYG{g+go}{drop(ok): a.pdf (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note though that this file content is irreversibly gone now, and
even going back in time in the history of the dataset will not bring it
back into existence.

\sphinxAtStartPar
Finally, let’s clean up:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}2
\PYG{g+go}{HEAD is now at c278f6a save cropped logos to Git}
\end{sphinxVerbatim}

\index{remove file@\spxentry{remove file}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!remove file@\spxentry{remove file}}\ignorespaces 

\subsection{Delete content stored in Git}
\label{\detokenize{basics/101-136-filesystem:delete-content-stored-in-git}}\label{\detokenize{basics/101-136-filesystem:index-17}}
\sphinxAtStartPar
It is much harder to delete dataset content that is stored in Git compared to
content stored in git\sphinxhyphen{}annex.
Operations such as \sphinxcode{\sphinxupquote{rm}} or \sphinxcode{\sphinxupquote{git rm}} remove the file from the \sphinxstyleemphasis{worktree},
but not from its history, and they can be brought back to life just as annexed
contents that were solely \sphinxcode{\sphinxupquote{rm}}\textquotesingle{}ed. There is also no straightforward
Git equivalent of \sphinxcode{\sphinxupquote{drop}}.
To accomplish a complete removal of a file from a dataset, we recommend the external tool
\dlhbhref{G2N}{git\sphinxhyphen{}filter\sphinxhyphen{}repo}.
It is a powerful and potentially very dangerous tool to rewrite Git history.

\sphinxAtStartPar
Usually, removing files stored in Git completely
is not a common or recommended operation, as it involves quite aggressive
rewriting of the dataset history. Sometimes, however, sensitive files, for example
private {\hyperref[\detokenize{glossary:term-SSH-key}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH key}}}}s or passwords, or too many or too large files are
accidentally saved into Git, and \sphinxstyleemphasis{need} to get out of the dataset history.
The command \sphinxcode{\sphinxupquote{git\sphinxhyphen{}filter\sphinxhyphen{}repo \textless{}path\sphinxhyphen{}specification\textgreater{} \sphinxhyphen{}\sphinxhyphen{}force}} will “filter\sphinxhyphen{}out”,
i.e., remove all files \sphinxstylestrong{but the ones specified} in \sphinxcode{\sphinxupquote{\textless{}path\sphinxhyphen{}specification\textgreater{}}}
from the dataset’s history. An advanced chapter in the online\sphinxhyphen{}handbook
shows an example invocation.


\section{Remove datasets}
\label{\detokenize{basics/101-136-filesystem:remove-datasets}}
\index{uninstall dataset@\spxentry{uninstall dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!uninstall dataset@\spxentry{uninstall dataset}}\index{drop dataset@\spxentry{drop dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!drop dataset@\spxentry{drop dataset}}\index{drop@\spxentry{drop}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!drop@\spxentry{drop}}\ignorespaces 

\subsection{Uninstall or delete subdatasets}
\label{\detokenize{basics/101-136-filesystem:uninstall-or-delete-subdatasets}}\label{\detokenize{basics/101-136-filesystem:index-18}}
\sphinxAtStartPar
Depending on the exact aim, different commands are relevant for
deleting a DataLad subdataset.
One way to uninstall a dataset is the \sphinxcode{\sphinxupquote{datalad drop}} command.
To work on datasets, \sphinxcode{\sphinxupquote{drop}} needs to be parametrized with \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}what all}}.
If needed, add \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}recursive}} in case the dataset contains subdatasets, and a
fitting \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}reckless}} mode, such as \sphinxcode{\sphinxupquote{datalad drop \sphinxhyphen{}\sphinxhyphen{}what all \sphinxhyphen{}\sphinxhyphen{}reckless kill \sphinxhyphen{}\sphinxhyphen{}recursive}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} clone a subdataset \PYGZhy{} the content is irrelevant, so why not a cloud :)}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }clone\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{ }https://github.com/datalad\PYGZhy{}datasets/disneyanimation\PYGZhy{}cloud.git\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{ }cloud
\PYG{g+go}{[INFO] Remote origin not usable by git\PYGZhy{}annex; setting annex\PYGZhy{}ignore}
\PYG{g+go}{install(ok): cloud (dataset)}
\PYG{g+go}{add(ok): cloud (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
To uninstall the dataset, you can use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }drop\PYG{+w}{ }\PYGZhy{}\PYGZhy{}what\PYG{+w}{ }all\PYG{+w}{ }\PYGZhy{}\PYGZhy{}reckless\PYG{+w}{ }\PYG{n+nb}{kill}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}recursive\PYG{+w}{ }cloud
\PYG{g+go}{uninstall(ok): cloud (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}reckless kill}} sounds bad, but is harmless here: we just clones this dataset, and we know we did not do anything locally that is worth keeping.

\sphinxAtStartPar
Note that the dataset is still known in the dataset, and not completely removed.
A \sphinxcode{\sphinxupquote{datalad get {[}\sphinxhyphen{}n/\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}data{]} cloud}} would install the dataset again.

\index{remove@\spxentry{remove}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!remove@\spxentry{remove}}\ignorespaces 
\sphinxAtStartPar
In case one wants to fully delete a subdataset from a dataset, the
\sphinxcode{\sphinxupquote{datalad remove}} command is relevant%
\begin{footnote}\sphinxAtStartFootnote
This is indeed the only case in which \sphinxcode{\sphinxupquote{datalad remove}} is
relevant. For all other cases of content deletion a normal \sphinxcode{\sphinxupquote{rm}}
with a subsequent \sphinxcode{\sphinxupquote{datalad save}} works best.
%
\end{footnote}.
It needs a pointer to the root of the superdataset with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}d/\sphinxhyphen{}\sphinxhyphen{}dataset}}
flag, a path to the subdataset to be removed, and optionally a commit message
(\sphinxcode{\sphinxupquote{\sphinxhyphen{}m/\sphinxhyphen{}\sphinxhyphen{}message}}) or recursive specification (\sphinxcode{\sphinxupquote{\sphinxhyphen{}r/\sphinxhyphen{}\sphinxhyphen{}recursive}}).
To remove a subdataset, we will install the uninstalled subdataset again, and
subsequently remove it with the \sphinxcode{\sphinxupquote{datalad remove}} command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }cloud
\PYG{g+go}{[INFO] Remote origin not usable by git\PYGZhy{}annex; setting annex\PYGZhy{}ignore}
\PYG{g+go}{install(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/cloud (dataset) [Installed subdataset in order to get /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/cloud]}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} delete the subdataset}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }remove\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}remove obsolete subds\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }cloud
\PYG{g+go}{uninstall(ok): cloud (dataset)}
\PYG{g+go}{remove(ok): cloud (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that for both commands a pointer to the \sphinxstyleemphasis{current directory} will not work.
\sphinxcode{\sphinxupquote{datalad remove .}} or \sphinxcode{\sphinxupquote{datalad drop .}} will fail, even if
the command is executed in a subdataset instead of the top\sphinxhyphen{}level
superdataset \textendash{} you need to execute the command from a higher\sphinxhyphen{}level directory.

\index{uninstall superdataset@\spxentry{uninstall superdataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!uninstall superdataset@\spxentry{uninstall superdataset}}\index{drop superdataset@\spxentry{drop superdataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!drop superdataset@\spxentry{drop superdataset}}\ignorespaces 

\subsection{Delete a superdataset}
\label{\detokenize{basics/101-136-filesystem:delete-a-superdataset}}\label{\detokenize{basics/101-136-filesystem:index-20}}
\sphinxAtStartPar
If for whatever reason you at one point tried to remove a DataLad dataset,
whether with a GUI or the command line call \sphinxcode{\sphinxupquote{rm \sphinxhyphen{}rf \textless{}directory\textgreater{}}}, you likely
have seen permission denied errors such as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{rm: cannot remove \PYGZsq{}\PYGZlt{}directory\PYGZgt{}/.git/annex/objects/Mz/M1/MD5E\PYGZhy{}s422982\PYGZhy{}\PYGZhy{}2977b5c6ea32de1f98689bc42613aac7.jpg/MD5E\PYGZhy{}s422982\PYGZhy{}\PYGZhy{}2977b5c6ea32de1f98689bc42613aac7.jpg\PYGZsq{}: Permission denied}
\PYG{g+go}{rm: cannot remove \PYGZsq{}\PYGZlt{}directory\PYGZgt{}/.git/annex/objects/FP/wv/MD5E\PYGZhy{}s543180\PYGZhy{}\PYGZhy{}6209797211280fc0a95196b0f781311e.jpg/MD5E\PYGZhy{}s543180\PYGZhy{}\PYGZhy{}6209797211280fc0a95196b0f781311e.jpg\PYGZsq{}: Permission denied}
\PYG{g+go}{ [...]}
\end{sphinxVerbatim}

\sphinxAtStartPar
This error indicates that there is write\sphinxhyphen{}protected content within \sphinxcode{\sphinxupquote{.git}} that
cannot not be deleted. What is this write\sphinxhyphen{}protected content? It’s the file content
stored in the object tree of git\sphinxhyphen{}annex. If you want, you can re\sphinxhyphen{}read the section on
{\hyperref[\detokenize{basics/101-115-symlinks:symlink}]{\sphinxcrossref{\DUrole{std,std-ref}{Data integrity}}}} (\autopageref*{\detokenize{basics/101-115-symlinks:symlink}}) to find out how git\sphinxhyphen{}annex revokes write permission for the user
to protect the file content given to it. To remove a dataset with annexed content
one has to regain write permissions to everything in the dataset. This is done
with the Unix \sphinxcode{\sphinxupquote{chmod}} command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }chmod\PYG{+w}{ }\PYGZhy{}R\PYG{+w}{ }u+w\PYG{+w}{ }\PYGZlt{}dataset\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
This \sphinxstyleemphasis{recursively} (\sphinxcode{\sphinxupquote{\sphinxhyphen{}R}}, i.e., throughout all files and (sub)directories) gives users
(\sphinxcode{\sphinxupquote{u}}) write permissions (\sphinxcode{\sphinxupquote{+w}}) for the dataset.

\sphinxAtStartPar
Afterwards, \sphinxcode{\sphinxupquote{rm \sphinxhyphen{}rf \textless{}dataset\textgreater{}}} will succeed.

\sphinxAtStartPar
However, instead of \sphinxcode{\sphinxupquote{rm \sphinxhyphen{}rf}}, a faster way to remove a dataset is using \sphinxcode{\sphinxupquote{datalad drop}}: Run \sphinxcode{\sphinxupquote{datalad drop \sphinxhyphen{}d \textless{}dataset\textgreater{}}} outside of the
superdataset to remove a top\sphinxhyphen{}level dataset with all its contents. Likely,
both  \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}recursive}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}reckless {[}availability|undead|kill{]}}} flags are necessary
to traverse into subdatasets and to remove content that does not have verified remotes.
\begin{importantnote}[before title={\thetcbcounter\ }, check odd page=true]{Deleting a dataset clone cannot be undone!}

\sphinxAtStartPar
Be aware that deleting a dataset clone in which ever way will
irrevocably delete the clone, it’s contents, and it’s history.
Unless another clone still exists elsewhere, the dataset will be gone forever.


\end{importantnote}


\section{Summary}
\label{\detokenize{basics/101-136-filesystem:summary}}
\sphinxAtStartPar
To sum up, file system management operations are safe and easy.
Even if you are currently confused about one or two operations,
worry not \textendash{} the take\sphinxhyphen{}home\sphinxhyphen{}message is simple: Use \sphinxcode{\sphinxupquote{datalad save}}
whenever you move or rename files. Be mindful that a \sphinxcode{\sphinxupquote{datalad status}}
can appear unintuitive or that symlinks can break if annexed files are moved,
but all of these problems are solved after a \sphinxcode{\sphinxupquote{datalad save}} command.
Apart from this command, having a clean dataset status prior to doing anything
is your friend as well. It will make sure that you have a neat and organized
commit history, and no accidental commits of changes unrelated to your file
system management operations. The only operation you should beware of is
moving subdatasets around \textendash{} this can be a minefield.
With all of these experiences and tips, you feel confident that you know
how to handle your datasets files and directories well and worry\sphinxhyphen{}free.

\sphinxstepscope


