%% Generated by Sphinx.
\def\sphinxdocclass{book}
\documentclass[letterpaper,10pt,english,twoside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}
\input{preamble_start.sty}
\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}


\input{fontpkg.sty}



\usepackage[,numfigreset=1,mathnumfig]{sphinx}
\sphinxsetup{
% for now a tiny space of marginal notes, because we only use it for icons
marginpar=10mm,%
% small margins due to page-number concerns for a printed book
hmargin=15mm,%
vmargin=15mm,%
verbatimforcewraps,%
verbatimwithframe=true,%
VerbatimColor={rgb}{1,1,1},%
VerbatimBorderColor={rgb}{.8,.8,.8},%
VerbatimHighlightColor={named}{LightGray},%
TitleColor={named}{Black},%
hintBorderColor={named}{LightCoral},%
InnerLinkColor={named}{Black},%
OuterLinkColor={named}{Black},%
attentionborder=3pt,%
attentionBorderColor={named}{Crimson},%
attentionBgColor={named}{FloralWhite},%
noteborder=2pt,%
noteBorderColor={named}{Orange},%
cautionborder=3pt,%
cautionBorderColor={named}{Cyan},%
cautionBgColor={named}{LightCyan}%
}
\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}


\input{preamble_end.sty}

\title{The DataLad Handbook}
\date{Dec 01, 2023}
\release{0.18+909.gaabff48e}
\author{}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{datalad_logo_wide_bw.pdf}\par}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\newcommand{\withauthors}{\mbox{Laura Waite}, \mbox{Kyle Meyer}, \mbox{Marisa Heckner}, \mbox{Benjamin Poldrack}, \mbox{Yaroslav Halchenko}, \mbox{Chris Markiewicz}, \mbox{Pattarawat Chormai}, \mbox{Lisa N. Mochalski}, \mbox{Lisa Wiersch}, \mbox{Jean-Baptiste Poline}, \mbox{Nevena Kraljevic}, \mbox{Alex Waite}, \mbox{Lya K. Paas}, \mbox{Niels Reuter}, \mbox{Peter Vavra}, \mbox{Tobias Kadelka}, \mbox{Peer Herholz}, \mbox{Alexandre Hutton}, \mbox{Sarah Oliveira}, \mbox{Dorian Pustina}, \mbox{Hamzah Hamid Baagil}, \mbox{Tristan Glatard}, \mbox{Giulia Ippoliti}, \mbox{Christian Mönch}, \mbox{Togaru Surya Teja}, \mbox{Dorien Huijser}, \mbox{Ariel Rokem}, \mbox{Remi Gau}, \mbox{Judith Bomba}, \mbox{Konrad Hinsen}, \mbox{Wu Jianxiao}, \mbox{Małgorzata Wierzba}, \mbox{Stefan Appelhoff}, \mbox{Michael Joseph}, \mbox{Tamara Cook}, \mbox{Stephan Heunis}, \mbox{Joerg Stadler}, \mbox{Sin Kim}, \mbox{Oscar Esteban}, \mbox{Michał Szczepanik}, \mbox{Eduard Ort}, \mbox{Myrskyta}, \mbox{Thomas Guiot}, \mbox{Julius Breuer}, \mbox{Ikko Ashimine}, \mbox{Arshitha Basavaraj}, \mbox{Anthony J Veltri}, \mbox{Isil Bilgin}, \mbox{Julian Kosciessa}, \mbox{Isaac To}, \mbox{Austin Macdonald}, \mbox{Christopher S. Hall}, \mbox{John C. Ford}, \mbox{Julien Colomb}, \mbox{Danny Garside}}
\input{titlepage.sty}
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{book_main::doc}}


\mainmatter

% page header setup
% page numbers at the outer edges
% chapter and section names at the inner edges,
% such that an open double-page reads: chapter...section
 \fancyhead[LE]{\small\thepage}
 \fancyhead[RO]{\small\thepage}
 \fancyhead[RE]{\small\nouppercase{\leftmark}}
 \fancyhead[LO]{\small\nouppercase{\rightmark}}
 \fancyfoot{}
 \fancyfoot[LE]{}
 \renewcommand*{\footrule}{}%

\sphinxstepscope


\chapter{A brief overview of DataLad}
\label{\detokenize{intro/philosophy:a-brief-overview-of-datalad}}\label{\detokenize{intro/philosophy:philo}}\label{\detokenize{intro/philosophy::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{design_objectives}.pdf}\hspace*{\fill}}

\sphinxAtStartPar
There can be numerous reasons why you ended up with this book in front of
you \textendash{} We do not know who you are, or why you are here.
You could have any background, any amount of previous experience with
DataLad, any individual application to use it for,
any level of maturity in your own mental concept of what DataLad
is, and any motivational strength to dig into this software.

\sphinxAtStartPar
All this brief section tries to do is to provide a minimal, abstract explanation
of what DataLad is, to give you, whoever you may be, some idea of what kind of
tool you will learn to master in this book, and to combat some prejudices
or presumptions about DataLad one could have.

\sphinxAtStartPar
To make it short, DataLad (\sphinxhref{https://datalad.org}{www.datalad.org}) is a software tool developed to aid with everything
related to the evolution of digital objects.

\sphinxAtStartPar
It is \sphinxstylestrong{not only keeping track of code}, it is
\sphinxstylestrong{not only keeping track of data}, it is
\sphinxstylestrong{not only making sharing, retrieving and linking data (and metadata) easy},
but it assists with the combination of all things
necessary in the digital workflow of data and science.

\sphinxAtStartPar
As built\sphinxhyphen{}in, but \sphinxstyleemphasis{optional} features, DataLad yields \sphinxhref{https://www.go-fair.org}{FAIR} resources \textendash{} for example
{\hyperref[\detokenize{glossary:term-metadata}]{\sphinxtermref{\DUrole{xref,std,std-term}{metadata}}}} and {\hyperref[\detokenize{glossary:term-provenance}]{\sphinxtermref{\DUrole{xref,std,std-term}{provenance}}}} \textendash{} and anything (or everything)
can be easily shared \sphinxstyleemphasis{should the user want this}.


\section{On data}
\label{\detokenize{intro/philosophy:on-data}}
\sphinxAtStartPar
Everyone uses data. But once it exists, it does not suffice for most data
to simply reside unchanged in a single location for eternity.

\sphinxAtStartPar
Most \sphinxstylestrong{data need to be shared} \textendash{} may it be a digital collection of family
photos, a genomics database between researchers around the world, or inventory
lists of one company division to another. Some data are public and should be
accessible to everyone.  Other data should circulate only among a select few.
There are various ways to distribute data, from emailing files to sending
physical storage media, from pointers to data locations on shared file systems
to using cloud computing or file hosting services. But what if there was an
easy, \sphinxstylestrong{generic way of sharing and obtaining data}?

\sphinxAtStartPar
Most \sphinxstylestrong{data changes and evolves}. A scientist extends a data collection or
performs computations on it. When applying for a new job, you update your
personal CV.  The documents required for an audit need to comply to a new
version of a common naming standard and the data files are thus renamed.  It may
be easy to change data, but it can be difficult to revert a change, get
information on previous states of this data, or even simply find out how a piece
of data came into existence. This latter aspect, the {\hyperref[\detokenize{glossary:term-provenance}]{\sphinxtermref{\DUrole{xref,std,std-term}{provenance}}}} of data
\textendash{} information on its lineage and \sphinxstyleemphasis{how} it came to be in its current state \textendash{} is
often key to understanding or establishing trust in data.  In collaborative
fields that work with small\sphinxhyphen{}sized data such as Wikipedia pages or software
development, {\hyperref[\detokenize{glossary:term-version-control}]{\sphinxtermref{\DUrole{xref,std,std-term}{version control}}}} tools are established and indispensable. These
tools allow users to keep track of changes, view previous states, or restore
older versions.  How about a \sphinxstylestrong{version control system for data}?

\sphinxAtStartPar
If data are shared as copies \sphinxstyleemphasis{of one state} of their history, \sphinxstylestrong{keeping all shared
copies up\sphinxhyphen{}to\sphinxhyphen{}date} once the original data change or evolve is at
best tedious, but likely impossible. What about ways to easily \sphinxstylestrong{update data and
its shared copies}?

\sphinxAtStartPar
The world is full of data. The public and private sector make use of it to
understand, improve, and innovate the complex world we live in.  Currently, this
process is far from optimal.  In order for society to get the most out of public
data collections, public \sphinxstylestrong{data need to be} \sphinxhref{https://www.go-fair.org}{FAIR}: Findable,
Accessible, Interoperable, and Reusable. Apart from easy ways to share or update
shared copies of data, extensive \sphinxstylestrong{metadata} is required to identify data, link
data collections together, and make them findable and searchable in a
standardized way. Can we also easily \sphinxstylestrong{attach metadata to our data and its
evolution}?

\sphinxAtStartPar
\sphinxstylestrong{DataLad} is a general purpose tool for managing everything involved in the
digital workflow of using data \textendash{} regardless of the data’s type, content, size,
location, generation, or development.  It provides functionality to share,
search, obtain, and version control data in a distributed fashion, and it aids
managing the evolution of digital objects in a way that fulfills the \sphinxhref{https://www.go-fair.org}{FAIR}
principles.


\section{The DataLad philosophy}
\label{\detokenize{intro/philosophy:the-datalad-philosophy}}
\sphinxAtStartPar
From a software point of view, DataLad is a command line tool, with an additional
Python API to use its features within your software and scripts.
While being a general, multi\sphinxhyphen{}purpose tool, there are also plenty of extensions
that provide helpful, domain specific features that may very well fit your precise use case.

\sphinxAtStartPar
But beyond software facts, DataLad is built up on a handful of principles. It is this underlying philosophy
that captures the spirit of what DataLad is, and here is a brief overview on it.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{DataLad only cares (knows) about two things: Datasets and files.}
A DataLad dataset is a collection of files in folders.
And a file is the smallest unit any dataset can contain. Thus, a DataLad
dataset has the same structure as any directory on your computer, and
DataLad itself can be conceptualized as a content\sphinxhyphen{}management system that operates
on the units of files. As most people
in any field work with files on their computer, at its core,
\sphinxstylestrong{DataLad is a completely domain\sphinxhyphen{}agnostic, general\sphinxhyphen{}purpose tool to manage data}.
You can use it whether you have a PhD in Neuroscience and want to
\sphinxhref{https://github.com/datalad-datasets/bmmr-t1w-250um}{share one of the largest whole brain MRI images in the world},
organize your private music library, or keep track of all
\sphinxhref{https://imgflip.com/memesearch?q=cat}{cat memes}
on the internet.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{A dataset is a Git repository}.
All features of the {\hyperref[\detokenize{glossary:term-version-control}]{\sphinxtermref{\DUrole{xref,std,std-term}{version control}}}} system {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}}
also apply to everything managed by DataLad \textendash{} plus many more.
If you do not know or use Git yet, there is no need to panic \textendash{} there is no necessity to
learn all of Git to follow along in learning and using DataLad. You will
experience much of Git working its magic underneath the hood when you use DataLad,
and will soon start to appreciate its features. Later, you may want to know more
on how DataLad uses Git as a fundamental layer and learn some of Git.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{A DataLad dataset can take care of managing and version controlling arbitrarily large data}.
To do this, it has an optional \sphinxstyleemphasis{annex} for (large) file content.
Thanks to this {\hyperref[\detokenize{glossary:term-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{annex}}}}, DataLad can easily track files that are many TB or PB in size
(something that Git could not do, and allows you to transform, work with, and restore previous
versions of data, while capturing all {\hyperref[\detokenize{glossary:term-provenance}]{\sphinxtermref{\DUrole{xref,std,std-term}{provenance}}}},
or share it with whomever you want). At the same time, DataLad does all of the magic
necessary to get this awesome feature to work quietly in the background.
The annex is set\sphinxhyphen{}up automatically, and the tool {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}
(\sphinxurl{https://git-annex.branchable.com}) manages it all underneath the hood. Worry\sphinxhyphen{}free
large\sphinxhyphen{}content data management? Check!

\item {} 
\sphinxAtStartPar
Deep in the core of DataLad lies the social principle to
\sphinxstylestrong{minimize custom procedures and data structures}. DataLad will not transform
your files into something that only DataLad or a specialized tool can read.
A PDF file (or any other type of
file) stays a PDF file (or whatever other type of file it was)
whether it is managed by DataLad or not. This guarantees that users will not lose
data or access if DataLad would vanish from their system (or from the face of the
Earth). Using DataLad thus does not require or generate
data structures that can only be used or read with DataLad \textendash{} DataLad does not
tie you down, it liberates you.

\item {} 
\sphinxAtStartPar
Furthermore, DataLad is developed for \sphinxstylestrong{complete decentralization}.
There is no required central server or service necessary to use DataLad. In this
way, no central infrastructure needs to be maintained (or paid for).
Your own laptop is the perfect place for your DataLad project to live, as is your
institution’s web server, or any other common computational infrastructure you
might be using.

\item {} 
\sphinxAtStartPar
Simultaneously, though, DataLad aims to
\sphinxstylestrong{maximize the (re\sphinxhyphen{})use of existing 3rd\sphinxhyphen{}party data resources and infrastructure}.
Users \sphinxstyleemphasis{can} use existing central infrastructures should they want to.
DataLad works with any infrastructure from {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}} to
\sphinxhref{https://www.dropbox.com}{Dropbox}, \sphinxhref{https://figshare.com}{Figshare}
or institutional repositories,
enabling users to harvest all of the advantages of their preferred
infrastructure without tying anyone down to central services.

\end{enumerate}

\sphinxAtStartPar
These principles hopefully gave you some idea of what to expect from DataLad,
cleared some worries that you might have had, and highlighted what DataLad is and what
it is not.
But now, let’s get ready to \sphinxstyleemphasis{use} DataLad. For this, the next
section will show you how to use this book.

\sphinxstepscope


\chapter{How to use this book}
\label{\detokenize{intro/narrative:how-to-use-this-book}}\label{\detokenize{intro/narrative::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{right_direction}.pdf}\hspace*{\fill}}


\section{For whom this book is written}
\label{\detokenize{intro/narrative:for-whom-this-book-is-written}}
\sphinxAtStartPar
This book is not the DataLad documentation, and it is also
not an explanation of the computational magic that happens in the background.
Instead, it is a procedurally oriented, hands\sphinxhyphen{}on crash\sphinxhyphen{}course that invites
you to fire up your terminal and follow along.

\sphinxAtStartPar
\sphinxstylestrong{If you are interested in learning how to use DataLad, this book is for you.}

\sphinxAtStartPar
You do not need to be a programmer, computer scientist, or Linux\sphinxhyphen{}crank.
If you have never touched your computer’s shell before, you will be fine.
No knowledge about {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} or {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} is required or necessary.
Regardless of your background and personal use cases for DataLad, this
book will show you the principles of DataLad, and from chapter {\hyperref[\detokenize{basics/101-101-create:createds}]{\sphinxcrossref{\DUrole{std,std-ref}{Create a dataset}}}} (\autopageref*{\detokenize{basics/101-101-create:createds}}) onwards,
you will be using them.


\section{How to read this book}
\label{\detokenize{intro/narrative:how-to-read-this-book}}
\sphinxAtStartPar
First of all: be excited. DataLad can help you to manage your digital data
workflow in various ways, and in this book you will use many of them right
from the start.
There are many topics you can explore, if you wish:
local or collaborative workflows, reproducible analyses, data publishing, and so on.
If anything seems particularly exciting, you can go ahead, read it, \sphinxstyleemphasis{and do it}.
Therefore, \sphinxstylestrong{grab your computer, and be ready to use it}.

\sphinxAtStartPar
Every chapter will give you different challenges, starting from basic local
workflows to more advanced commands, and you will see your skills increase
with each. While learning, it will be easy to
\sphinxstylestrong{find use cases in your own work for the commands you come across}.

\sphinxAtStartPar
Throughout the book numerous \sphinxstyleemphasis{terms} for concepts and technical components
are used. They are all defined in a {\hyperref[\detokenize{glossary:glossary}]{\sphinxcrossref{\DUrole{std,std-ref}{Glossary}}}} (\autopageref*{\detokenize{glossary:glossary}}), and are printed
with a glossary icon, such as {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}}, or {\hyperref[\detokenize{glossary:term-commit-message}]{\sphinxtermref{\DUrole{xref,std,std-term}{commit message}}}}.
Links to external resources have a superscript that you can find in the “Links” collection at the end of the book.
And internal links reference the page number of the box, section, or chapter in question.

\sphinxAtStartPar
As this book aims to be a practical guide it includes as many hands\sphinxhyphen{}on examples
as we can fit into it. Code snippets look like this, and you should
\sphinxstylestrong{copy them into your own terminal to try them out}, but you can also
\sphinxstylestrong{modify them to fit your custom needs in your own use cases}.
Note how we distinguish \sphinxcode{\sphinxupquote{comments (\$ \#)}} from \sphinxcode{\sphinxupquote{commands (\$)}} and their output
in the example below (it shows the creation of a DataLad dataset):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} This is a comment used for additional explanations.}
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} Otherwise, anything preceded by \PYGZdl{} is a command to try.}
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} If the line starts with no \PYGZdl{}, it is an output of a command.}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }create\PYG{+w}{ }myfirstrepo
\PYG{g+go}{[INFO   ] Creating a new annex repo at /home/me/DataLad\PYGZhy{}101}
\PYG{g+go}{create(ok): /home/me/DataLad\PYGZhy{}101 (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
When copying code snippets into your own terminal, do not copy the leading
\sphinxcode{\sphinxupquote{\$}} \textendash{} this only indicates that the line is a command, and would lead to an
error when executed.
Don’t worry {\hyperref[\detokenize{intro/narrative:fom-lazy}]{\sphinxcrossref{\DUrole{std,std-ref}{if you do not want to code along}}}} (\autopageref*{\detokenize{intro/narrative:fom-lazy}}), though.

\sphinxAtStartPar
Whenever you see a ✂ symbol, command output has been shortened for better readability.
In the example below, the commit {\hyperref[\detokenize{glossary:term-shasum}]{\sphinxtermref{\DUrole{xref,std,std-term}{shasum}}}} has been shortened and marked with \sphinxcode{\sphinxupquote{✂SHA1}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}reverse
\PYG{g+go}{commit 8df130bb✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}
\end{sphinxVerbatim}

\sphinxAtStartPar
This book’s content matches the \sphinxstyleemphasis{Basics} part of the online\sphinxhyphen{}handbook.
It introduces core DataLad functionality and challenges you to use it.
The covered topics are a good start, if you want to learn how to use DataLad.
They can be read from start to finish.
The online\sphinxhyphen{}handbook has additional parts that you are welcome to check
out, too:
In the \sphinxstyleemphasis{Advanced} part you will find features or workflows that go beyond the
Basics.
And in the last part, \sphinxstyleemphasis{Use cases}, you will find concrete examples of
DataLad applications for general inspiration.

\sphinxAtStartPar
Note that many challenges can have straightforward and basic solutions,
but a lot of additional options or improvements are possible.
Sometimes one could get lost in all of the available DataLad functionality,
or in some interesting backgrounds about a command.
For this reason we put all of the basics in plain sight, and those basics
will let you master a given task and get along comfortably.
Having the basics will be your multi\sphinxhyphen{}purpose swiss army knife.
But if you want to have the special knowledge for a very peculiar type
of problem set or that extra increase in skill or understanding,
you’ll have to do a detour into some of the “hidden” parts of the book:
When there are command options or explanations that go beyond basics and
best practices, we put them in special boxes in order
to not be too distracting for anyone only interested in the basics.
You can decide for yourself whether you want to check them out:

\sphinxAtStartPar
“Find\sphinxhyphen{}out\sphinxhyphen{}more” boxes contain general additional information:
\begin{findoutmore}[label={fom-intro}, before title={\thetcbcounter\ }, check odd page=true]{For curious minds}
\label{\detokenize{intro/narrative:fom-intro}}

\sphinxAtStartPar
Sections like this contain content that goes beyond the basics
necessary to complete a challenge.


\end{findoutmore}

\sphinxAtStartPar
“Git user notes” elaborate on technical details from under the hood:
\begin{gitusernote}[before title={\thetcbcounter\ }, check odd page=true]{For (future) Git experts}

\sphinxAtStartPar
DataLad uses {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} and {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} underneath the hood. Readers that
are familiar with these tools can find occasional notes on how a DataLad   command links to a Git(\sphinxhyphen{}annex) command or concept in boxes like this.
There is, however, absolutely no knowledge of Git or git\sphinxhyphen{}annex necessary
to follow this book. You will, though, encounter Git commands throughout
the book when there is no better alternative, and executing those commands will
suffice to follow along.


\end{gitusernote}

\sphinxAtStartPar
If you are a Windows user with a native (i.e., not \sphinxhref{https://en.wikipedia.org/wiki/Windows\_Subsystem\_for\_Linux}{Windows Subsystem for Linux (WSL)}\sphinxhyphen{}based) DataLad installation, pay close attention to the special notes in so\sphinxhyphen{}called “Windows\sphinxhyphen{}Wits”:
\begin{windowswit}[before title={\thetcbcounter\ }, check odd page=true]{For Windows users only}

\sphinxAtStartPar
A range of file system issues can affect the behavior of DataLad or its underlying tools on Windows.
If necessary, this book provides workarounds for problems, explanations, or at least apologies for those inconveniences.
If you want to help us make the online\sphinxhyphen{}handbook or DataLad better for Windows users, please \sphinxhref{https://github.com/datalad-handbook/book/issues/new}{get in touch} \textendash{} every little improvement or bug report can help.


\end{windowswit}

\sphinxAtStartPar
Apart from the core DataLad commands introduced in this book, DataLad also comes with many extensions and is continuously developed and improved.
More recent or more advanced features, or features from extensions are added to the online\sphinxhyphen{}handbook frequently.
If you are looking for a feature but cannot find it in this introduction, please take a look at the web version, the DataLad \sphinxhref{https://docs.datalad.org}{documentation}, or the various extensions’ documentations.


\subsection{What you will learn in this book}
\label{\detokenize{intro/narrative:what-you-will-learn-in-this-book}}
\sphinxAtStartPar
This book will teach you simple, yet advanced principles of data
management for reproducible, comprehensible, transparent, and
\sphinxhref{https://www.go-fair.org}{FAIR} data
projects. It does so with hands\sphinxhyphen{}on tool use of DataLad and its
underlying software, blended with clear explanations of relevant
theoretical backgrounds whenever necessary, and by demonstrating
organizational and procedural guidelines and standards for data
related projects on concrete examples.

\sphinxAtStartPar
You will learn how to create, consume, structure, share, publish, and use
\sphinxstyleemphasis{DataLad datasets}: modular, reusable components that can be version\sphinxhyphen{}controlled,
linked, and that are able to capture and track full provenance of their
contents, if used correctly.

\sphinxAtStartPar
After studying this book, these are some of the main
things you will know how to do, and understand why doing them is useful:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Version\sphinxhyphen{}control} data objects, regardless of size, keep track of
and \sphinxstylestrong{update} (from) their sources and shared copies, and capture the
\sphinxstylestrong{provenance} of all data objects whether you consume them from any source
or create them yourself.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Build up complete projects} with data as independent, version\sphinxhyphen{}controlled,
provenance\sphinxhyphen{}tracked, and linked DataLad dataset(s) that allow \sphinxstylestrong{distribution},
modular \sphinxstylestrong{reuse}, and are \sphinxstylestrong{transparent} both in their structure and their
development to their current and future states.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Bind} modular components into complete data analysis projects, and comply
to procedural and organizational principles that will help to create transparent
and comprehensible projects to ease \sphinxstylestrong{collaboration} and \sphinxstylestrong{reproducibility}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Share} complete data objects, version\sphinxhyphen{}controlled as a whole, but including
modular components (such as data) in a way that preserves the history,
provenance, and linkage of its components.

\end{itemize}

\sphinxAtStartPar
After having read this book, you will find it easy to create, build up, and
share intuitively structured and version\sphinxhyphen{}controlled data projects that
fulfill high standards for reproducibility and FAIRness. You are able to
decide for yourself how deep you want to delve into the DataLad world
based on your individual use cases, and with every section you will learn
more about state\sphinxhyphen{}of\sphinxhyphen{}the\sphinxhyphen{}art data management.


\subsection{The storyline}
\label{\detokenize{intro/narrative:the-storyline}}
\sphinxAtStartPar
Most of the sections in the upcoming chapter follow a continuous \sphinxstylestrong{narrative}.
This narrative aims to be as domain\sphinxhyphen{}agnostic and relatable as possible, but
it also needs to be able to showcase all of the principles and commands
of DataLad. Therefore, together we will build up a DataLad project for the
fictional educational course \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}.

\sphinxAtStartPar
Envision yourself in the last educational course you took or taught.
You have probably created some files with notes you took, a directory
with slides or books for further reading, and a place where you stored
assignments and their solutions. This is what we will be doing as well.
This project will start with creating the necessary directory structures,
populating them by \sphinxcode{\sphinxupquote{installing}} and \sphinxcode{\sphinxupquote{creating}} several
{\hyperref[\detokenize{glossary:term-DataLad-subdataset}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad subdataset}}}}s, adding files and changing their content,
and executing simple scripts with input data to create results we can
share and publish with DataLad.

\begin{figure}[tbp]
\centering

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{student}.pdf}
\end{figure}
\begin{findoutmore}[label={fom-lazy}, before title={\thetcbcounter\ }, float, check odd page=true]{I cannot/do not want to code along…}
\label{\detokenize{intro/narrative:fom-lazy}}

\sphinxAtStartPar
If you do not want to follow along and only read, there is a showroom dataset
of the complete DataLad\sphinxhyphen{}101 project at
\sphinxhref{https://github.com/datalad-handbook/DataLad-101}{github.com/datalad\sphinxhyphen{}handbook/DataLad\sphinxhyphen{}101}.
This dataset contains a separate {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} for each section that introduced changes
in the repository. The branches have the names of the sections, e.g.,
\sphinxcode{\sphinxupquote{sct\_create\_a\_dataset}} marks the repository state at the end of “Create a dataset”. You can checkout a branch with \sphinxtitleref{git checkout \textless{}branch\sphinxhyphen{}name\textgreater{}}
to explore how the dataset looks like at the end of a given section.

\sphinxAtStartPar
Note that this “public” dataset has a number of limitations, but it is useful
for an overview of the dataset history (and thus the actions performed throughout
the “course”), a good display of how many and what files will be present in the
end of the book, and a demonstration of how subdatasets are linked.


\end{findoutmore}


\section{Let’s get going!}
\label{\detokenize{intro/narrative:let-s-get-going}}
\sphinxAtStartPar
If you have DataLad installed, you can dive straight into chapter {\hyperref[\detokenize{basics/101-101-create:createds}]{\sphinxcrossref{\DUrole{std,std-ref}{Create a dataset}}}} (\autopageref*{\detokenize{basics/101-101-create:createds}}).
For everyone new, there are the sections {\hyperref[\detokenize{intro/howto:howto}]{\sphinxcrossref{\DUrole{std,std-ref}{The command line}}}} (\autopageref*{\detokenize{intro/howto:howto}}) as a minimal tutorial
to using the shell and {\hyperref[\detokenize{intro/installation:install}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation and configuration}}}} (\autopageref*{\detokenize{intro/installation:install}}) to get your DataLad installation set up.

\sphinxstepscope


\chapter{Installation and configuration}
\label{\detokenize{intro/installation:installation-and-configuration}}\label{\detokenize{intro/installation:install}}\label{\detokenize{intro/installation::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{interior_design}.pdf}\hspace*{\fill}}

\index{installation@\spxentry{installation}!DataLad@\spxentry{DataLad}}\ignorespaces 

\section{Install DataLad}
\label{\detokenize{intro/installation:install-datalad}}\label{\detokenize{intro/installation:index-0}}\begin{importantnote}[before title={\thetcbcounter\ }, check odd page=true]{Feedback on installation instructions}

\sphinxAtStartPar
The installation methods presented in this chapter are based on experience
and have been tested carefully. However, operating systems and other
software are continuously evolving, and these guides might have become
outdated. Be sure to check out the online\sphinxhyphen{}handbook for up\sphinxhyphen{}to\sphinxhyphen{}date information.


\end{importantnote}

\sphinxAtStartPar
In general, the DataLad installation requires Python 3 (see the
\textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-py2v3}} {\hyperref[\detokenize{intro/installation:fom-py2v3}]{\sphinxcrossref{\DUrole{std,std-ref}{on the difference between Python 2 and 3}}}} (\autopageref*{\detokenize{intro/installation:fom-py2v3}}) to learn
why this is required), {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}}, and {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}, and for some
functionality \sphinxhref{https://7-zip.org}{7\sphinxhyphen{}Zip}.  The instructions below detail how
to install the core DataLad tool and its dependencies on common operating
systems. They do not cover the various {\hyperref[\detokenize{glossary:term-DataLad-extension}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad extension}}}}s that need to be installed separately, if desired.

\index{determine version@\spxentry{determine version}!with Python@\spxentry{with Python}}\index{with Python@\spxentry{with Python}!determine version@\spxentry{determine version}}\ignorespaces \begin{findoutmore}[label={fom-py2v3}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Python 2, Python 3, what’s the difference?}
\label{\detokenize{intro/installation:fom-py2v3}}

\sphinxAtStartPar
DataLad requires Python 3.8, or a more recent version, to be installed on your system.
The easiest way to verify that this is the case is to open a terminal and type \sphinxcode{\sphinxupquote{ python}} to start a Python session:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }python
\PYG{g+go}{Python 3.9.1+ (default, Jan 20 2021, 14:49:22)}
\PYG{g+go}{[GCC 10.2.1 20210110] on linux}
\PYG{g+go}{Type \PYGZdq{}help\PYGZdq{}, \PYGZdq{}copyright\PYGZdq{}, \PYGZdq{}credits\PYGZdq{} or \PYGZdq{}license\PYGZdq{} for more information.}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If this fails, or reports a Python version with a leading \sphinxcode{\sphinxupquote{2}}, such as \sphinxcode{\sphinxupquote{Python 2.7.18}}, try starting \sphinxcode{\sphinxupquote{ python3}}, which some systems use to disambiguate between Python 2 and Python 3.
If this fails, too, you need to obtain a recent release of Python 3. On Windows, attempting to run commands that are not installed might cause a Windows Store window to pop up.
If this happens, Python may not yet be installed. Please check the {\hyperref[\detokenize{intro/installation:windows-10-and-11}]{\sphinxcrossref{Windows 10 and 11}}} (\autopageref*{\detokenize{intro/installation:windows-10-and-11}}) installation instructions, and \sphinxstyleemphasis{do not} install Python via the Windows Store.

\sphinxAtStartPar
Python 2 is an outdated, in technical terms “deprecated”, version of Python.
Although it still exist as the default Python version on many systems, it is no longer maintained since 2020, and thus, most software has dropped support for Python 2.
If you only run Python 2 on your system, most Python software, including DataLad, will be incompatible, and hence unusable,  resulting in errors during installation and execution.

\sphinxAtStartPar
But does that mean that you should uninstall Python 2?  \sphinxstylestrong{No}!  Keep it installed, especially if you are using Linux or MacOS.
Python 2 existed for 20 years and numerous software has been written for it.
It is quite likely that some basic operating system components or legacy software on your computer is depending on it, and uninstalling a preinstalled Python 2 from your system will likely render it unusable.
Install Python 3, and have both versions coexist peacefully.


\end{findoutmore}

\sphinxAtStartPar
The following sections provide targeted installation instructions for a set of
common scenarios, operating systems, or platforms.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{install}.pdf}\hspace*{\fill}}

\index{install DataLad@\spxentry{install DataLad}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!install DataLad@\spxentry{install DataLad}}\ignorespaces 

\subsection{Windows 10 and 11}
\label{\detokenize{intro/installation:windows-10-and-11}}\label{\detokenize{intro/installation:index-2}}
\sphinxAtStartPar
There are countless ways to install software on Windows. Here we describe \sphinxstyleemphasis{one}
possible approach that should work on any Windows computer, like one that you
may have just bought.
\begin{description}
\sphinxlineitem{Python:}
\index{install Python@\spxentry{install Python}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!install Python@\spxentry{install Python}}\index{installation@\spxentry{installation}!Python@\spxentry{Python}}\ignorespaces 
\sphinxAtStartPar
Windows itself does not ship with Python, it must be installed separately.
If you already did that, please check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-py2v3}} {\hyperref[\detokenize{intro/installation:fom-py2v3}]{\sphinxcrossref{\DUrole{std,std-ref}{on Python
versions}}}} (\autopageref*{\detokenize{intro/installation:fom-py2v3}}), if it matches the requirements. Otherwise, head over
to the \sphinxhref{https://www.python.org/downloads}{download section of the Python website}, and download an installer. Unless you
have specific requirements, go with the 64bit installer of the latest
Python 3 release.
\begin{windowswit}[before title={\thetcbcounter\ }, check odd page=true]{Avoid installing Python from the Windows store}

\sphinxAtStartPar
We recommend to \sphinxstylestrong{not} install Python via the Windows store, even if it
opens after you typed \sphinxcode{\sphinxupquote{ python}}, as this version requires
additional configurations by hand (in particular of your \sphinxcode{\sphinxupquote{\$PATH}}
{\hyperref[\detokenize{glossary:term-environment-variable}]{\sphinxtermref{\DUrole{xref,std,std-term}{environment variable}}}}).


\end{windowswit}

\sphinxAtStartPar
When you run the installer, make sure to select the \sphinxstyleemphasis{Add Python to PATH} option,
as this is required for subsequent installation steps and interactive use later on.
Other than that, using the default installation settings is just fine.
\begin{windowswit}[before title={\thetcbcounter\ }, check odd page=true]{Verify Python installation}

\sphinxAtStartPar
It is not uncommon for multiple Python installations to co\sphinxhyphen{}exist on a Windows machine, because particular applications can ship their own.
Such alternative installations may even be or become the default.
This can cause confusing behavior, because each Python installation will have different package versions installed.

\sphinxAtStartPar
To verify if there are multiple installations, open the windows command line \sphinxcode{\sphinxupquote{cmd.exe}} and run \sphinxcode{\sphinxupquote{where python}}.
This will list all variants of \sphinxcode{\sphinxupquote{python.exe}}.
There will be one in \sphinxcode{\sphinxupquote{WindowsApps}}, which is only a link to the Windows app store.
Make sure the Python version that you installed is listed too.

\sphinxAtStartPar
If there are multiple Python installation, you can tell which one is default by running this command in \sphinxcode{\sphinxupquote{cmd.exe}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}} \PYG{n}{python} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{import sys; print(sys.executable)}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will print the path of the default \sphinxcode{\sphinxupquote{python.exe}}.
If the output is not matching the expected Python installation, likely the \sphinxcode{\sphinxupquote{\$PATH}} environment variable needs to be adjusted.
This can be done in the Windows system properties.
It is sufficient to move the entries created by the Python installer to the start of the declaration list.


\end{windowswit}

\sphinxlineitem{Git:}
\index{install Git@\spxentry{install Git}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!install Git@\spxentry{install Git}}\index{installation@\spxentry{installation}!Git@\spxentry{Git}}\ignorespaces 
\sphinxAtStartPar
Windows also does not come with Git. If you happen to have it installed already,
please check if you have configured it for command line use. You should be able
to open the Windows command prompt and run a command like \sphinxcode{\sphinxupquote{ git \sphinxhyphen{}\sphinxhyphen{}version}}.
It should return a version number and not an error.

\sphinxAtStartPar
To install Git, visit the \sphinxhref{https://git-scm.com/download/win}{Git website} and
download an installer. If in doubt, go with the 64bit installer of the latest
version. The installer itself provides various customization options. We
recommend to leave the defaults as they are, in particular the target
directory, but configure the following settings (they are distributed over
multiple dialogs):
\begin{itemize}
\item {} 
\sphinxAtStartPar
Select \sphinxstyleemphasis{Git from the command line and also from 3rd\sphinxhyphen{}party software}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Enable file system caching}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Select Use external OpenSSH}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Enable symbolic links}

\end{itemize}

\sphinxlineitem{Git\sphinxhyphen{}annex:}
\index{install git\sphinxhyphen{}annex@\spxentry{install git\sphinxhyphen{}annex}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!install git\sphinxhyphen{}annex@\spxentry{install git\sphinxhyphen{}annex}}\index{installation@\spxentry{installation}!git\sphinxhyphen{}annex@\spxentry{git\sphinxhyphen{}annex}}\ignorespaces 
\sphinxAtStartPar
There are two convenient ways to install git\sphinxhyphen{}annex. The first is \sphinxhref{https://git-annex.branchable.com/install/Windows}{downloading the installer from git\sphinxhyphen{}annex’ homepage}. The other is to deploy git\sphinxhyphen{}annex via the \sphinxhref{https://github.com/datalad/datalad-installer}{DataLad installer}.
The latter option requires the installation of the \sphinxcode{\sphinxupquote{datalad\sphinxhyphen{}installer}} Python package.
Once Python is available, it can be done with the Python package manager
\sphinxcode{\sphinxupquote{ pip}}. Open a command prompt and run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZgt{}} python \PYGZhy{}m pip install datalad\PYGZhy{}installer
\end{sphinxVerbatim}

\sphinxAtStartPar
Afterwards, open another command prompt in administrator mode and run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZgt{}} datalad\PYGZhy{}installer git\PYGZhy{}annex \PYGZhy{}m datalad/git\PYGZhy{}annex:release
\end{sphinxVerbatim}

\sphinxAtStartPar
This will download a recent git\sphinxhyphen{}annex, and configure it for your Git installation.
The admin command prompt can be closed afterwards, all other steps do not need it.

\sphinxAtStartPar
For \sphinxhref{https://git-annex.branchable.com/projects/datalad/bugs-done/Windows\_\_58\_\_\_substantial\_per-file\_cost\_for\_\_\_96\_\_add\_\_96\_\_}{performance improvements}, regardless of which installation method you chose, we recommend to also set the following git\sphinxhyphen{}annex configuration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZgt{}} git config \PYGZhy{}\PYGZhy{}global filter.annex.process \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{git\PYGZhy{}annex filter\PYGZhy{}process}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxlineitem{DataLad:}
\sphinxAtStartPar
With Python, Git, and git\sphinxhyphen{}annex installed, DataLad can be installed, and later also
upgraded using \sphinxcode{\sphinxupquote{ pip}} by running:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZgt{}} python \PYGZhy{}m pip install datalad
\end{sphinxVerbatim}

\sphinxlineitem{7\sphinxhyphen{}Zip (optional, but highly recommended):}
\index{install 7\sphinxhyphen{}zip@\spxentry{install 7\sphinxhyphen{}zip}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!install 7\sphinxhyphen{}zip@\spxentry{install 7\sphinxhyphen{}zip}}\index{installation@\spxentry{installation}!7\sphinxhyphen{}Zip@\spxentry{7\sphinxhyphen{}Zip}}\ignorespaces 
\sphinxAtStartPar
Download it from the \sphinxhref{https://7-zip.org}{7\sphinxhyphen{}zip website} (64bit
installer when in doubt), and install it into the default target directory.

\end{description}

\sphinxAtStartPar
There are many other ways to install DataLad on Windows, check for example the
\textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-wsl2}} {\hyperref[\detokenize{intro/installation:ww-wsl2}]{\sphinxcrossref{\DUrole{std,std-ref}{on the Windows Subsystem 2 for Linux}}}} (\autopageref*{\detokenize{intro/installation:ww-wsl2}}).
One attractive alternative approach is {\hyperref[\detokenize{intro/installation:conda}]{\sphinxcrossref{Conda}}} (\autopageref*{\detokenize{intro/installation:conda}}), a completely different approach is to install the {\hyperref[\detokenize{glossary:term-DataLad-Gooey}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad Gooey}}}}, which is a standalone installation of DataLad’s graphical application (see \sphinxhref{https://docs.datalad.org/projects/gooey}{the DataLad Gooey documentation} for installation instructions).

\index{install DataLad@\spxentry{install DataLad}!on WSL2@\spxentry{on WSL2}}\index{on WSL2@\spxentry{on WSL2}!install DataLad@\spxentry{install DataLad}}\ignorespaces \begin{windowswit}[label={ww-wsl2}, before title={\thetcbcounter\ }, check odd page=true]{Install DataLad using the Windows Subsystem 2 for Linux}
\label{\detokenize{intro/installation:ww-wsl2}}

\sphinxAtStartPar
With the Windows Subsystem for Linux, you will be able to use a Unix system
despite being on Windows.  You need to have a recent build of Windows in
order to get WSL2 \textendash{} we do not recommend WSL1.

\sphinxAtStartPar
You can find out how to install the Windows Subsystem for Linux at
\sphinxhref{https://learn.microsoft.com/en-us/windows/wsl/install}{docs.microsoft.com}.
Afterwards, proceed with your installation as described in the installation instructions
for Linux.


\end{windowswit}

\sphinxAtStartPar
Using DataLad on Windows has a few peculiarities. In general, DataLad can feel a bit
sluggish on non\sphinxhyphen{}WSL2 Windows systems. This is due to various file system issues
that also affect the version control system {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} itself, which DataLad
relies on. The core functionality of DataLad works, and you should be able to
follow most contents covered in this book.  You will notice, however, that some
Unix commands displayed in examples may not work, and that terminal output can
look different from what is displayed in the code examples of the book, and
that some dependencies for additional functionality are not available for
Windows. Dedicated notes,
“\sphinxcode{\sphinxupquote{Windows\sphinxhyphen{}wit}}s”, contain important information, alternative commands, or
warnings, and an overview of useful Windows commands and general information is included in {\hyperref[\detokenize{intro/howto:howto}]{\sphinxcrossref{\DUrole{std,std-ref}{The command line}}}} (\autopageref*{\detokenize{intro/howto:howto}}).

\index{install DataLad@\spxentry{install DataLad}!on Mac@\spxentry{on Mac}}\index{on Mac@\spxentry{on Mac}!install DataLad@\spxentry{install DataLad}}\ignorespaces 

\subsection{Mac (incl. M1)}
\label{\detokenize{intro/installation:mac-incl-m1}}\label{\detokenize{intro/installation:mac}}\label{\detokenize{intro/installation:index-8}}
\sphinxAtStartPar
Modern Macs come with a compatible Python 3 version installed by default. The
\textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-py2v3}} {\hyperref[\detokenize{intro/installation:fom-py2v3}]{\sphinxcrossref{\DUrole{std,std-ref}{on Python versions}}}} (\autopageref*{\detokenize{intro/installation:fom-py2v3}}) has instructions on how to
confirm that.

\sphinxAtStartPar
DataLad is available via OS X’s \sphinxhref{https://brew.sh}{homebrew} package manager.
First, install the homebrew package manager, which requires \sphinxhref{https://apps.apple.com/us/app/xcode/id497799835}{Xcode} to be installed from the
Mac App Store.

\sphinxAtStartPar
Next, install datalad and its dependencies:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }brew\PYG{+w}{ }install\PYG{+w}{ }datalad
\end{sphinxVerbatim}

\sphinxAtStartPar
Alternatively, you can exclusively use \sphinxcode{\sphinxupquote{ brew}} for DataLad’s non\sphinxhyphen{}Python
dependencies, and then check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-macosx-pip}} {\hyperref[\detokenize{intro/installation:fom-macosx-pip}]{\sphinxcrossref{\DUrole{std,std-ref}{on how to install DataLad via
Python\textquotesingle{}s package manager}}}} (\autopageref*{\detokenize{intro/installation:fom-macosx-pip}}).
\begin{findoutmore}[label={fom-macosx-pip}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Install DataLad via pip on macOS}
\label{\detokenize{intro/installation:fom-macosx-pip}}

\sphinxAtStartPar
If Git/git\sphinxhyphen{}annex are installed already (via brew), DataLad can also be
installed via Python’s package manager \sphinxcode{\sphinxupquote{pip}}, which should be installed
by default on your system:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }python\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }datalad
\end{sphinxVerbatim}

\sphinxAtStartPar
Some macOS versions may use \sphinxcode{\sphinxupquote{python3}} instead of \sphinxcode{\sphinxupquote{python}} \textendash{} use {\hyperref[\detokenize{glossary:term-tab-completion}]{\sphinxtermref{\DUrole{xref,std,std-term}{tab
completion}}}} to find out which is installed.

\sphinxAtStartPar
Recent macOS versions may warn after installation that scripts were installed
into locations that were not on \sphinxcode{\sphinxupquote{PATH}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
The script chardetect is installed in
\PYGZsq{}/Users/MYUSERNAME/Library/Python/3.11/bin\PYGZsq{} which is not on PATH.
Consider adding this directory to PATH or, if you prefer to
suppress this warning, use \PYGZhy{}\PYGZhy{}no\PYGZhy{}warn\PYGZhy{}script\PYGZhy{}location.
\end{sphinxVerbatim}

\sphinxAtStartPar
To fix this, add these paths to the \sphinxcode{\sphinxupquote{\$PATH}} environment variable.
You can do this for your own user account by adding something like the following
to the \sphinxstyleemphasis{profile} file of your shell (exchange the user name accordingly):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{export}\PYG{+w}{ }\PYG{n+nv}{PATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}PATH}:/Users/MYUSERNAME/Library/Python/3.11/bin
\end{sphinxVerbatim}

\sphinxAtStartPar
If you use a {\hyperref[\detokenize{glossary:term-bash}]{\sphinxtermref{\DUrole{xref,std,std-term}{bash}}}} shell, this may be \sphinxcode{\sphinxupquote{\textasciitilde{}/.bashrc}} or
\sphinxcode{\sphinxupquote{\textasciitilde{}/.bash\_profile}}, if you are using a {\hyperref[\detokenize{glossary:term-zsh}]{\sphinxtermref{\DUrole{xref,std,std-term}{zsh}}}} shell, it may be
\sphinxcode{\sphinxupquote{\textasciitilde{}/.zshrc}} or \sphinxcode{\sphinxupquote{\textasciitilde{}/.zprofile}}. Find out which shell you are using by
typing \sphinxcode{\sphinxupquote{echo \$SHELL}} into your terminal.

\sphinxAtStartPar
Alternatively, you could configure it \sphinxstyleemphasis{system\sphinxhyphen{}wide}, i.e., for all users of
your computer by adding the path
\sphinxcode{\sphinxupquote{/Users/MYUSERNAME/Library/Python/3.11/bin}} to the file \sphinxcode{\sphinxupquote{/etc/paths}},
e.g., with the editor {\hyperref[\detokenize{glossary:term-nano}]{\sphinxtermref{\DUrole{xref,std,std-term}{nano}}}} (requires using \sphinxcode{\sphinxupquote{sudo}} and authenticating
with your password):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }sudo\PYG{+w}{ }nano\PYG{+w}{ }/etc/paths
\end{sphinxVerbatim}

\sphinxAtStartPar
The contents of this file could look like this afterwards (the last line was
added):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{/usr/local/bin}
\PYG{g+go}{/usr/bin}
\PYG{g+go}{/bin}
\PYG{g+go}{/usr/sbin}
\PYG{g+go}{/sbin}
\PYG{g+go}{/Users/MYUSERNAME/Library/Python/3.11/bin}
\end{sphinxVerbatim}


\end{findoutmore}

\index{install DataLad@\spxentry{install DataLad}!on Debian/Ubuntu@\spxentry{on Debian/Ubuntu}}\index{on Debian/Ubuntu@\spxentry{on Debian/Ubuntu}!install DataLad@\spxentry{install DataLad}}\ignorespaces 

\subsection{Linux: (Neuro)Debian, Ubuntu, and similar systems}
\label{\detokenize{intro/installation:linux-neuro-debian-ubuntu-and-similar-systems}}\label{\detokenize{intro/installation:index-9}}
\sphinxAtStartPar
DataLad is part of the Debian and Ubuntu operating systems. However, the
particular DataLad version included in a release may be a bit older (check the
versions for \sphinxhref{https://packages.debian.org/datalad}{Debian} and \sphinxhref{https://packages.ubuntu.com/datalad}{Ubuntu} to see which ones are available).

\sphinxAtStartPar
For some recent releases of Debian\sphinxhyphen{}based operating systems, \sphinxhref{https://neuro.debian.net}{NeuroDebian} provides more recent DataLad versions (check the
\sphinxhref{https://neuro.debian.net/pkgs/datalad.html}{availability table}).  In order to
install from NeuroDebian, follow \sphinxhref{https://neuro.debian.net/install\_pkg.html?p=datalad}{its installation documentation}, which only requires
copy\sphinxhyphen{}pasting three lines into a terminal.  Also, should you be confused by the
name: enabling this repository will not do any harm if your field is not
neuroscience.

\sphinxAtStartPar
Whichever repository you end up using, the following command installs DataLad
and all of its software dependencies (including {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} and \sphinxhref{https://p7zip.sourceforge.net}{p7zip}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }sudo\PYG{+w}{ }apt\PYGZhy{}get\PYG{+w}{ }install\PYG{+w}{ }datalad
\end{sphinxVerbatim}

\sphinxAtStartPar
The command above will also upgrade existing installations to the most recent
available version.

\index{install DataLad@\spxentry{install DataLad}!on Redhat/Fedora@\spxentry{on Redhat/Fedora}}\index{on Redhat/Fedora@\spxentry{on Redhat/Fedora}!install DataLad@\spxentry{install DataLad}}\ignorespaces 

\subsection{Linux: CentOS, Redhat, Fedora, or similar systems}
\label{\detokenize{intro/installation:linux-centos-redhat-fedora-or-similar-systems}}\label{\detokenize{intro/installation:index-10}}
\sphinxAtStartPar
For CentOS, Redhat, Fedora, or similar distributions, there is an \sphinxhref{https://git-annex.branchable.com/install/rpm\_standalone}{RPM package for git\sphinxhyphen{}annex}.  A
suitable version of Python and {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} should come with the operating
system, although some servers may run fairly old releases.

\sphinxAtStartPar
DataLad itself can be installed via \sphinxcode{\sphinxupquote{pip}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }python\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }datalad
\end{sphinxVerbatim}

\sphinxAtStartPar
Alternatively, DataLad can be installed together with {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} and
{\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} via {\hyperref[\detokenize{intro/installation:conda}]{\sphinxcrossref{Conda}}} (\autopageref*{\detokenize{intro/installation:conda}}).

\index{install DataLad@\spxentry{install DataLad}!on HPC@\spxentry{on HPC}}\index{on HPC@\spxentry{on HPC}!install DataLad@\spxentry{install DataLad}}\ignorespaces 

\subsection{Linux\sphinxhyphen{}machines with no root access (e.g. HPC systems)}
\label{\detokenize{intro/installation:linux-machines-with-no-root-access-e-g-hpc-systems}}\label{\detokenize{intro/installation:norootinstall}}\label{\detokenize{intro/installation:index-11}}
\sphinxAtStartPar
The most convenient user\sphinxhyphen{}based installation can be achieved via {\hyperref[\detokenize{intro/installation:conda}]{\sphinxcrossref{Conda}}} (\autopageref*{\detokenize{intro/installation:conda}}).

\index{install DataLad@\spxentry{install DataLad}!with Conda@\spxentry{with Conda}}\index{with Conda@\spxentry{with Conda}!install DataLad@\spxentry{install DataLad}}\ignorespaces 

\subsection{Conda}
\label{\detokenize{intro/installation:conda}}\label{\detokenize{intro/installation:index-12}}\label{\detokenize{intro/installation:id1}}
\sphinxAtStartPar
Conda is a software distribution available for all major operating systems, and
its \sphinxhref{https://docs.conda.io/miniconda.html}{Miniconda} installer
offers a convenient way to bootstrap a DataLad installation. Importantly, it
does not require admin/root access to a system.

\sphinxAtStartPar
\sphinxhref{https://docs.conda.io/projects/conda/en/latest/user-guide/install/index.html}{Detailed, platform\sphinxhyphen{}specific installation instructions} are available
in the Conda documentation. In short: download and run the installer, or, from
the command line, run

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }wget\PYG{+w}{ }https://repo.anaconda.com/miniconda/Miniconda3\PYGZhy{}latest\PYGZhy{}\PYGZlt{}YOUR\PYGZhy{}OS\PYGZgt{}\PYGZhy{}x86\PYGZus{}64.sh
\PYG{g+gp}{\PYGZdl{} }bash\PYG{+w}{ }Miniconda3\PYGZhy{}latest\PYGZhy{}\PYGZlt{}YOUR\PYGZhy{}OS\PYGZgt{}\PYGZhy{}x86\PYGZus{}64.sh
\end{sphinxVerbatim}

\sphinxAtStartPar
In the above call, replace \sphinxcode{\sphinxupquote{\textless{}YOUR\sphinxhyphen{}OS\textgreater{}}} with an identifier for your operating
system, such as “Linux” or “MacOSX”.  During the installation, you will need to
accept a license agreement (press Enter to scroll down, and type “yes” and
Enter to accept), confirm the installation into the default directory, and you
should respond “yes” to the prompt \sphinxcode{\sphinxupquote{“Do you wish the installer to initialize
Miniconda3 by running conda init? {[}yes|no{]}”}}.  Afterwards, you can remove the
installation script by running \sphinxcode{\sphinxupquote{rm ./Miniconda3\sphinxhyphen{}latest\sphinxhyphen{}*\sphinxhyphen{}x86\_64.sh}}.

\sphinxAtStartPar
The installer automatically configures the shell to make conda\sphinxhyphen{}installed tools
accessible, so no further configuration is necessary.  Once Conda is installed,
the DataLad package can be installed from the \sphinxcode{\sphinxupquote{conda\sphinxhyphen{}forge}} channel:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }conda\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }conda\PYGZhy{}forge\PYG{+w}{ }datalad
\end{sphinxVerbatim}

\sphinxAtStartPar
In general, all of DataLad’s software dependencies are automatically installed, too.
This makes a conda\sphinxhyphen{}based deployment very convenient. A from\sphinxhyphen{}scratch DataLad installation
on a HPC system, as a normal user, is done in three lines:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }wget\PYG{+w}{ }https://repo.anaconda.com/miniconda/Miniconda3\PYGZhy{}latest\PYGZhy{}Linux\PYGZhy{}x86\PYGZus{}64.sh
\PYG{g+gp}{\PYGZdl{} }bash\PYG{+w}{ }Miniconda3\PYGZhy{}latest\PYGZhy{}Linux\PYGZhy{}x86\PYGZus{}64.sh
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} acknowledge license, keep everything at default}
\PYG{g+gp}{\PYGZdl{} }conda\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }conda\PYGZhy{}forge\PYG{+w}{ }datalad
\end{sphinxVerbatim}

\sphinxAtStartPar
In case a dependency is not available from Conda (e.g., there is no git\sphinxhyphen{}annex
package for Windows in Conda), please refer to the platform\sphinxhyphen{}specific
instructions above.

\sphinxAtStartPar
To update an existing installation with conda, use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }conda\PYG{+w}{ }update\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }conda\PYGZhy{}forge\PYG{+w}{ }datalad
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxhref{https://github.com/datalad/datalad-installer}{DataLad installer} also supports setting up a Conda environment, in case
a suitable Python version is already available.

\index{install DataLad@\spxentry{install DataLad}!with pip@\spxentry{with pip}}\index{with pip@\spxentry{with pip}!install DataLad@\spxentry{install DataLad}}\ignorespaces 

\subsection{Using Python’s package manager \sphinxstyleliteralintitle{\sphinxupquote{pip}}}
\label{\detokenize{intro/installation:using-python-s-package-manager-pip}}\label{\detokenize{intro/installation:pipinstall}}\label{\detokenize{intro/installation:index-13}}
\sphinxAtStartPar
As mentioned above, DataLad can be installed via Python’s package manager \sphinxhref{https://pip.pypa.io}{pip}.  \sphinxcode{\sphinxupquote{pip}} comes with any Python distribution
from \sphinxhref{https://www.python.org}{python.org}, and is available as a system\sphinxhyphen{}package
in nearly all GNU/Linux distributions.

\sphinxAtStartPar
If you have Python and \sphinxcode{\sphinxupquote{pip}} set up, to automatically install DataLad and
most of its software dependencies, type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }python\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }datalad
\end{sphinxVerbatim}

\sphinxAtStartPar
If this results in a \sphinxcode{\sphinxupquote{permission denied}} error, you can install DataLad into
a user’s home directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }python\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}\PYGZhy{}user\PYG{+w}{ }datalad
\end{sphinxVerbatim}

\sphinxAtStartPar
On some systems, you may need to call \sphinxcode{\sphinxupquote{python3}} instead of \sphinxcode{\sphinxupquote{python}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }python3\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }datalad
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} or, in case of a \PYGZdq{}permission denied error\PYGZdq{}:}
\PYG{g+gp}{\PYGZdl{} }python3\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }\PYGZhy{}\PYGZhy{}user\PYG{+w}{ }datalad
\end{sphinxVerbatim}

\sphinxAtStartPar
An existing installation can be upgraded with \sphinxcode{\sphinxupquote{python \sphinxhyphen{}m pip install \sphinxhyphen{}U datalad}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pip}} is not able to install non\sphinxhyphen{}Python software, such as 7\sphinxhyphen{}zip or
{\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}.  But you can install the \sphinxhref{https://github.com/datalad/datalad-installer}{DataLad installer} via a \sphinxcode{\sphinxupquote{python \sphinxhyphen{}m pip install datalad\sphinxhyphen{}installer}}. This is a command\sphinxhyphen{}line tool that aids installation
of DataLad and its key software dependencies on a range of platforms.

\index{configure user identity@\spxentry{configure user identity}!with Git@\spxentry{with Git}|spxpagem}\ignorespaces 

\section{Initial configuration}
\label{\detokenize{intro/installation:initial-configuration}}\label{\detokenize{intro/installation:installconfig}}\label{\detokenize{intro/installation:index-14}}
\sphinxAtStartPar
Initial configurations only concern the setup of a {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} identity. If you
are a Git\sphinxhyphen{}user, you should hence be good to go.

\begin{figure}[tbp]
\centering

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{gitidentity}.pdf}
\end{figure}

\sphinxAtStartPar
If you have not used the version control system Git before, you will need to
tell Git some information about you. This needs to be done only once.
In the following example, exchange \sphinxcode{\sphinxupquote{Bob McBobFace}} with your own name, and
\sphinxcode{\sphinxupquote{bob@example.com}} with your own email address.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} enter your home directory using the \PYGZti{} shortcut}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }\PYGZti{}
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}\PYGZhy{}global\PYG{+w}{ }\PYGZhy{}\PYGZhy{}add\PYG{+w}{ }user.name\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Bob McBobFace\PYGZdq{}}
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}\PYGZhy{}global\PYG{+w}{ }\PYGZhy{}\PYGZhy{}add\PYG{+w}{ }user.email\PYG{+w}{ }bob@example.com
\end{sphinxVerbatim}

\sphinxAtStartPar
This information is used to track changes in the DataLad projects you will
be working on. Based on this information, changes you make are associated
with your name and email address, and you should use a real email address
and name \textendash{} it does not establish a lot of trust nor is it helpful after a few
years if your history, especially in a collaborative project, shows
that changes were made by \sphinxcode{\sphinxupquote{Anonymous}} with the email
\sphinxcode{\sphinxupquote{youdontgetmy@email.fu}}.
And do not worry, you won’t get any emails from Git or DataLad.

\sphinxstepscope

\index{terminal@\spxentry{terminal}|spxpagem}\index{shell@\spxentry{shell}|spxpagem}\index{command Line@\spxentry{command Line}|spxpagem}\index{what is@\spxentry{what is}!command line@\spxentry{command line}}\index{command line@\spxentry{command line}!what is@\spxentry{what is}}\index{what is@\spxentry{what is}!terminal@\spxentry{terminal}}\index{terminal@\spxentry{terminal}!what is@\spxentry{what is}}\index{what is@\spxentry{what is}!shell@\spxentry{shell}}\index{shell@\spxentry{shell}!what is@\spxentry{what is}}\ignorespaces 

\chapter{The command line}
\label{\detokenize{intro/howto:the-command-line}}\label{\detokenize{intro/howto:howto}}\label{\detokenize{intro/howto:index-0}}\label{\detokenize{intro/howto::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{typewriter}.pdf}\hspace*{\fill}}

\sphinxAtStartPar
This chapter aims at providing novices with general basics about the shell, common Unix
commands and their Windows equivalent, and some general file system facts.
This chapter is also a place to return to and (re\sphinxhyphen{})read if you come across a
non\sphinxhyphen{}DataLad command or principle you want to remind yourself of.
If you are already familiar with the shell and know the difference between an absolute
and a relative path, you can safely skip this chapter.

\sphinxAtStartPar
While there is a graphical user interface for DataLad (the {\hyperref[\detokenize{glossary:term-DataLad-Gooey}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad Gooey}}}}), this book will first and foremost focus on teaching DataLad concepts without the overhead of a user\sphinxhyphen{}interface, using DataLad’s most powerful interface on the \sphinxstyleemphasis{command line}.
This means that the code examples in this book show no buttons to click on, but a set of commands and options users type into their \sphinxstyleemphasis{terminal}.
If you are not used to working with command\sphinxhyphen{}line tools, DataLad can appear intimidating.
Luckily, the set of possible commands is limited, and even without prior experience with a shell, one can get used to it fairly quickly.

\begin{figure}[tbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{shell}.png}
\caption{A terminal window in a standard desktop environment.}\label{\detokenize{intro/howto:id1}}\end{figure}

\sphinxAtStartPar
The shell (also called a terminal, console, or CLI) is an interactive,
text based interface. If you have used Matlab or IPython, then you are already familiar
with the basics of a command line interface.
On Unix\sphinxhyphen{}like systems (e.g., running Linux or macOS), the shell application is usually called “terminal”.
On Windows systems, several different interfaces exist: The “CMD” Command Prompt and the Powershell are natively installed, and the Git Bash (provided by Git for Windows) or Anaconda prompt CLI (provided by Anaconda or Miniconda) can come with the installation of the respective software tool.
We recommend using CMD, or, if you have them installed already and prefer them over the CMD, the Git Bash or Anaconda prompt.
As later parts in this section will show, shells under Windows may use different commands than shells under Linux and macOS systems.


\section{Command syntax}
\label{\detokenize{intro/howto:command-syntax}}
\sphinxAtStartPar
Interactions with the shell take the form of commands, text\sphinxhyphen{}based instructions to your computer.
Commands are case sensitive and follow the syntax of:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{command} \PYG{p}{[}\PYG{n}{options}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{arguments}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Whenever you see some example code in the code snippets of this book, make sure
that you capitalize exactly as shown if you try it out yourself.
The options modify the behavior of the program, and are usually preceded by \sphinxcode{\sphinxupquote{\sphinxhyphen{}}} or \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}}} on Unix\sphinxhyphen{}like systems.
In this example

\index{use command options@\spxentry{use command options}!in a terminal@\spxentry{in a terminal}}\index{in a terminal@\spxentry{in a terminal}!use command options@\spxentry{use command options}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{intro/howto:index-1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }output.txt
\PYG{g+go}{\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 me me 25165824 Dec 14 17:15 output.txt}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ls}} is the \sphinxstyleemphasis{command}. The \sphinxstyleemphasis{option} \sphinxcode{\sphinxupquote{\sphinxhyphen{}l}} tells \sphinxcode{\sphinxupquote{ls}} to use a long listing format and
thus display more information.
\sphinxcode{\sphinxupquote{output.txt}} is the \sphinxstyleemphasis{argument} — the file that \sphinxcode{\sphinxupquote{ls}} is listing.
The difference between options preceded by \sphinxcode{\sphinxupquote{\sphinxhyphen{}}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}}} is their length:
Usually, all options starting with a single dash are single letters. Often,
a long, double\sphinxhyphen{}dashed option exists for these short options as well. For example,
to list the size of a file in a \sphinxstyleemphasis{human\sphinxhyphen{}readable} format, supply the short option
\sphinxcode{\sphinxupquote{\sphinxhyphen{}h}}, or, alternatively, its longer form, \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}human\sphinxhyphen{}readable}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}lh\PYG{+w}{ }output.txt\PYG{+w}{    }\PYG{c+c1}{\PYGZsh{} note that short options can be combined!}
\PYG{g+gp}{\PYGZsh{} }or\PYG{+w}{ }alternatively
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }\PYGZhy{}\PYGZhy{}human\PYGZhy{}readable\PYG{+w}{ }output.txt
\PYG{g+go}{\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 me me 24M Dec 14 17:15 output.txt}
\end{sphinxVerbatim}

\sphinxAtStartPar
A command may have many of those options (often called “flags”) that modify their behavior.
On Windows, options of native Windows commands can be preceded by a \sphinxcode{\sphinxupquote{/}} instead of dashes, for example, \sphinxcode{\sphinxupquote{dir /p output.txt}}.
There are too many to even consider memorizing. Remember the ones you use often,
and the rest you will lookup in their documentation or via your favorite search engine.
DataLad commands naturally also come with many options, and in the next chapters
and later examples you will get to see many of them.


\section{Basic commands}
\label{\detokenize{intro/howto:basic-commands}}
\sphinxAtStartPar
The following commands, split between Unix\sphinxhyphen{}like (e.g., Linux, macOS) and Windows environments, can appear in our examples or are generally useful to know:
They can help you to \sphinxstyleemphasis{explore and navigate} in your file system, copy, move, or remove files, or create new directories.
Note that the Git Bash on Windows emulates a Unix environment in which you could use Unix commands despite being on Windows.

\index{terminal commands@\spxentry{terminal commands}!on Unix\sphinxhyphen{}like systems@\spxentry{on Unix\sphinxhyphen{}like systems}}\index{on Unix\sphinxhyphen{}like systems@\spxentry{on Unix\sphinxhyphen{}like systems}!terminal commands@\spxentry{terminal commands}}\ignorespaces 

\subsection{Unix\sphinxhyphen{}like systems or environments}
\label{\detokenize{intro/howto:unix-like-systems-or-environments}}\label{\detokenize{intro/howto:index-2}}\begin{description}
\sphinxlineitem{\sphinxcode{\sphinxupquote{ls \sphinxhyphen{}lah \textless{}folder\textgreater{}}}}
\sphinxAtStartPar
list the contents of a folder, including hidden files (\sphinxhyphen{}a), and all their information (\sphinxhyphen{}l);
print file sizes in human readable units (\sphinxhyphen{}h)

\sphinxlineitem{\sphinxcode{\sphinxupquote{cd \textless{}folder\textgreater{}}}}
\sphinxAtStartPar
change to another folder

\sphinxlineitem{\sphinxcode{\sphinxupquote{cp \textless{}from\textgreater{} \textless{}to\textgreater{}}}}
\sphinxAtStartPar
copy a file

\sphinxlineitem{\sphinxcode{\sphinxupquote{cp \sphinxhyphen{}R \textless{}from\textgreater{} \textless{}to\textgreater{}}}}
\sphinxAtStartPar
copy a folder and its contents (\sphinxhyphen{}R)

\sphinxlineitem{\sphinxcode{\sphinxupquote{mv \textless{}from\textgreater{} \textless{}to\textgreater{}}}}
\sphinxAtStartPar
move/rename a file or folder

\sphinxlineitem{\sphinxcode{\sphinxupquote{rm \textless{}file\textgreater{}}}}
\sphinxAtStartPar
delete a file

\sphinxlineitem{\sphinxcode{\sphinxupquote{rm \sphinxhyphen{}Rv \textless{}folder\textgreater{}}}}
\sphinxAtStartPar
delete a folder and its contents (\sphinxhyphen{}R) and list each file as it’s being deleted (\sphinxhyphen{}v)

\sphinxlineitem{\sphinxcode{\sphinxupquote{mkdir \textless{}folder\textgreater{}}}}
\sphinxAtStartPar
create a folder

\sphinxlineitem{\sphinxcode{\sphinxupquote{rmdir \textless{}folder\textgreater{}}}}
\sphinxAtStartPar
delete an empty folder

\sphinxlineitem{\sphinxcode{\sphinxupquote{export NAME=Value}}}
\sphinxAtStartPar
Set an {\hyperref[\detokenize{glossary:term-environment-variable}]{\sphinxtermref{\DUrole{xref,std,std-term}{environment variable}}}} \sphinxcode{\sphinxupquote{NAME}} to \sphinxcode{\sphinxupquote{Value}} for your current terminal session

\end{description}

\index{terminal commands@\spxentry{terminal commands}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!terminal commands@\spxentry{terminal commands}}\ignorespaces 

\subsection{Windows systems}
\label{\detokenize{intro/howto:windows-systems}}\label{\detokenize{intro/howto:index-3}}\begin{description}
\sphinxlineitem{\sphinxcode{\sphinxupquote{dir \textless{}folder\textgreater{}}}}
\sphinxAtStartPar
list the contents of a folder including hidden files

\sphinxlineitem{\sphinxcode{\sphinxupquote{cd \textless{}folder\textgreater{}}}}
\sphinxAtStartPar
change to another folder

\sphinxlineitem{\sphinxcode{\sphinxupquote{copy \textless{}from\textgreater{} \textless{}to\textgreater{}}}}
\sphinxAtStartPar
copy a file

\sphinxlineitem{\sphinxcode{\sphinxupquote{ren \textless{}oldname\textgreater{} \textless{}newname\textgreater{}}}}
\sphinxAtStartPar
rename a file or folder

\sphinxlineitem{\sphinxcode{\sphinxupquote{mv \textless{}from\textgreater{} \textless{}to\textgreater{}}}}
\sphinxAtStartPar
move a file or folder

\sphinxlineitem{\sphinxcode{\sphinxupquote{del \textless{}file\textgreater{}}}}
\sphinxAtStartPar
delete a file

\sphinxlineitem{\sphinxcode{\sphinxupquote{rmdir /s \textless{}folder\textgreater{}}}}
\sphinxAtStartPar
delete a folder and its contents (\sphinxcode{\sphinxupquote{/s}})

\sphinxlineitem{\sphinxcode{\sphinxupquote{md \textless{}folder\textgreater{}}}}
\sphinxAtStartPar
create a folder

\sphinxlineitem{\sphinxcode{\sphinxupquote{rmdir \textless{}folder\textgreater{}}}}
\sphinxAtStartPar
delete an empty folder

\sphinxlineitem{\sphinxcode{\sphinxupquote{set NAME=Value}}}
\sphinxAtStartPar
Set an {\hyperref[\detokenize{glossary:term-environment-variable}]{\sphinxtermref{\DUrole{xref,std,std-term}{environment variable}}}} \sphinxcode{\sphinxupquote{NAME}} to \sphinxcode{\sphinxupquote{Value}} for your current terminal session

\end{description}

\index{paths@\spxentry{paths}|spxpagem}\index{what is@\spxentry{what is}!prompt@\spxentry{prompt}}\index{prompt@\spxentry{prompt}!what is@\spxentry{what is}}\ignorespaces 

\section{The prompt}
\label{\detokenize{intro/howto:the-prompt}}\label{\detokenize{intro/howto:index-4}}
\sphinxAtStartPar
When you first login on the command line, you are greeted with “the prompt”,
and it will likely look similar to this:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{me@muninn: \textasciitilde{}\$}}

\sphinxAtStartPar
This says I am the user \sphinxcode{\sphinxupquote{me}} on the machine \sphinxcode{\sphinxupquote{muninn}} and I am in the folder \sphinxcode{\sphinxupquote{\textasciitilde{}}},
which is shorthand for the current user’s home folder (in this case \sphinxcode{\sphinxupquote{/home/me}}).

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\$}} sign indicates that the prompt is interactive and awaiting user input.
In this book, we will use \sphinxcode{\sphinxupquote{\$}} as a shorthand for the prompt, to allow
the reader to quickly differentiate between lines containing commands vs the
output of those commands.

\index{paths@\spxentry{paths}|spxpagem}\index{what is@\spxentry{what is}!path@\spxentry{path}}\index{path@\spxentry{path}!what is@\spxentry{what is}}\ignorespaces 

\section{Paths}
\label{\detokenize{intro/howto:paths}}\label{\detokenize{intro/howto:index-5}}
\sphinxAtStartPar
Paths look different on Unix\sphinxhyphen{}like and Windows systems.
Most prominently, the \sphinxstyleemphasis{path separators}, i.e., the symbol distinguishing directories in path, are back slashes (\sphinxcode{\sphinxupquote{\textbackslash{}}}) on Windows and front slashes (\sphinxcode{\sphinxupquote{/}}) on Unix\sphinxhyphen{}like systems.
On Windows systems, paths are also usually prefixed with a “disk designator” such as \sphinxcode{\sphinxupquote{C:}} or \sphinxcode{\sphinxupquote{d:}}.
Let’s say I want to create a new folder in my home folder on a Unix system,
I can run the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mkdir\PYG{+w}{ }/home/me/awesome\PYGZus{}datalad\PYGZus{}project
\end{sphinxVerbatim}

\sphinxAtStartPar
If I want to do the same in Windows CMD, I’d do

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} mkdir C:\PYGZbs{}Users\PYGZbs{}me\PYGZbs{}awesome\PYGZus{}datalad\PYGZus{}project
\end{sphinxVerbatim}

\sphinxAtStartPar
And that both works on the respective system. \sphinxcode{\sphinxupquote{/home/me/awesome\_datalad\_project}} and \sphinxcode{\sphinxupquote{\textbackslash{}Users\textbackslash{}me\textbackslash{}awesome\_datalad\_project}} are what is called an \sphinxstyleemphasis{absolute}
path.
Absolute paths \sphinxstyleemphasis{always} start with a \sphinxcode{\sphinxupquote{/}} (on Unix\sphinxhyphen{}like systems) or a \sphinxcode{\sphinxupquote{\textbackslash{}}} (on Windows systems), and define the folder’s location with no ambiguity.

\sphinxAtStartPar
However, much like in spoken language, using someone’s full proper name every
time would be exhausting, and thus pronouns are used.

\sphinxAtStartPar
This shorthand is called \sphinxstyleemphasis{relative} paths, because they are defined (wait for it…)
\sphinxstyleemphasis{relative} to your current location on the file system. Relative paths \sphinxstyleemphasis{never} start
with a \sphinxcode{\sphinxupquote{/}} or \sphinxcode{\sphinxupquote{\textbackslash{}}}.
For example, \sphinxcode{\sphinxupquote{myfile.txt}} is a relative path to the file \sphinxcode{\sphinxupquote{myfile.txt}} in the current directory on Unix\sphinxhyphen{}like systems.
The Windows equivalent for \sphinxcode{\sphinxupquote{myfile.txt}} in the current directory on the \sphinxcode{\sphinxupquote{C}} disk is \sphinxcode{\sphinxupquote{C:myfile.txt}}.

\sphinxAtStartPar
Unix knows a few shortcuts to refer to file system related directories, and you will
come across them often. Whenever you see a \sphinxcode{\sphinxupquote{.}}, \sphinxcode{\sphinxupquote{..}}, or \sphinxcode{\sphinxupquote{\textasciitilde{}}} in a DataLad command,
here is the translation to this cryptic punctuation:
\begin{description}
\sphinxlineitem{\sphinxcode{\sphinxupquote{.}}}
\sphinxAtStartPar
the current directory

\sphinxlineitem{\sphinxcode{\sphinxupquote{..}}}
\sphinxAtStartPar
the parent directory

\sphinxlineitem{\sphinxcode{\sphinxupquote{\textasciitilde{}}}}
\sphinxAtStartPar
the current user’s home directory

\end{description}

\sphinxAtStartPar
So, taking the above example again: given that I am in my home (\sphinxcode{\sphinxupquote{\textasciitilde{}}}) folder,
the following commands all would create the new folder in the exact same place.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mkdir\PYG{+w}{ }/home/me/awesome\PYGZus{}datalad\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }mkdir\PYG{+w}{ }\PYGZti{}/awesome\PYGZus{}datalad\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }mkdir\PYG{+w}{ }awesome\PYGZus{}datalad\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }mkdir\PYG{+w}{ }./awesome\PYGZus{}datalad\PYGZus{}project
\end{sphinxVerbatim}

\sphinxAtStartPar
To demonstrate this further, consider the following: In my home directory
\sphinxcode{\sphinxupquote{/home/me}} I have added a folder for my current project,
\sphinxcode{\sphinxupquote{awesome\_datalad\_project/}}. Let’s take a look at how this folder is organized:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }tree
\PYG{g+go}{└── home}
\PYG{g+go}{    └── me}
\PYG{g+go}{         └── awesome\PYGZus{}datalad\PYGZus{}project}
\PYG{g+go}{            ├── aligned}
\PYG{g+go}{                ├── code}
\PYG{g+go}{            └── sub\PYGZhy{}01}
\PYG{g+go}{                └── bold3T}
\PYG{g+go}{            ├── ...}
\PYG{g+go}{            └── sub\PYGZhy{}xx}
\PYG{g+go}{                └── bold3T}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now let’s say I want to change from my home directory \sphinxcode{\sphinxupquote{/home/me}} into the \sphinxcode{\sphinxupquote{code/}}
folder of the project. I could use absolute paths:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cd /home/me/awesome\_datalad\_project/aligned/code}}

\sphinxAtStartPar
But that is a bit wordy. It is much easier with a relative path:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }awesome\PYGZus{}datalad\PYGZus{}project/aligned/code
\end{sphinxVerbatim}

\sphinxAtStartPar
Relative to my starting location (\sphinxcode{\sphinxupquote{/home/me}}), I navigated into the subfolders.

\sphinxAtStartPar
I can change back to my home directory also with a relative path:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../../../
\end{sphinxVerbatim}

\sphinxAtStartPar
The first \sphinxcode{\sphinxupquote{../}} takes me from \sphinxcode{\sphinxupquote{code/}} to its parent \sphinxcode{\sphinxupquote{aligned/}}, the
second \sphinxcode{\sphinxupquote{../}} to \sphinxcode{\sphinxupquote{awesome\_datalad\_project/}}, and the last \sphinxcode{\sphinxupquote{../}}
back to my home directory \sphinxcode{\sphinxupquote{me/}}.

\sphinxAtStartPar
However, since I want to go back to my home folder, it’s much faster to run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }\PYGZti{}
\end{sphinxVerbatim}

\sphinxAtStartPar
Windows similarly knows the \sphinxcode{\sphinxupquote{.}} and \sphinxcode{\sphinxupquote{..}} shortcuts, but cannot handle the \sphinxcode{\sphinxupquote{\textasciitilde{}}} shortcut.
In order to quickly get home, you could use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }\PYGZpc{}userprofile\PYGZpc{}
\end{sphinxVerbatim}

\sphinxAtStartPar
More information on Windows paths can be found \sphinxhref{https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file}{here}.

\index{text editor@\spxentry{text editor}}\ignorespaces 

\section{Text editors}
\label{\detokenize{intro/howto:text-editors}}\label{\detokenize{intro/howto:index-6}}
\sphinxAtStartPar
Text editors are a crucial tool for any Linux user, but regardless of your operating system,
if you use DataLad, you will occasionally find yourself in your default text editor to write
a {\hyperref[\detokenize{glossary:term-commit-message}]{\sphinxtermref{\DUrole{xref,std,std-term}{commit message}}}} to describe a change you performed in your DataLad dataset.

\sphinxAtStartPar
Religious wars have been fought over which is “the best” editor. From the smoldering ashes,
this is the breakdown:
\begin{description}
\sphinxlineitem{\sphinxcode{\sphinxupquote{nano}}}
\sphinxAtStartPar
Easy to use; medium features. If you do not know which to use, start with this.

\sphinxlineitem{\sphinxcode{\sphinxupquote{vim}}}
\sphinxAtStartPar
Powerful and light; lots of features and many plugins; steep learning curve.
Two resources to help get the most out of vim are the vimtutor program
and vimcasts.org. If you accidentally enter \sphinxcode{\sphinxupquote{vim}} unprepared, typing \sphinxcode{\sphinxupquote{:q}}
will get you out of there.

\sphinxlineitem{\sphinxcode{\sphinxupquote{emacs}}}
\sphinxAtStartPar
Powerful; tons of features; written in Lisp; huge ecosystem; advanced learning curve.

\end{description}

\sphinxAtStartPar
The text editors above are all command\sphinxhyphen{}line editors.
They will open up directly in your terminal.

\index{configure default editor@\spxentry{configure default editor}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!configure default editor@\spxentry{configure default editor}}\ignorespaces 
\sphinxAtStartPar
While those text editors can also be installed on Windows, command\sphinxhyphen{}line editors are rarely used on Windows.
Git for Windows might set {\hyperref[\detokenize{glossary:term-vim}]{\sphinxtermref{\DUrole{xref,std,std-term}{vim}}}} as the default editor upon installation, which can require some acclimatization.
A good graphical alternative is Notepad++, a powerful Windows\sphinxhyphen{}native text editor.
You may either be able to configure this during the installation, of afterwards by running \sphinxcode{\sphinxupquote{git config core.editor notepad}}.

\index{shell@\spxentry{shell}}\ignorespaces 

\section{Shells}
\label{\detokenize{intro/howto:shells}}\label{\detokenize{intro/howto:index-8}}
\sphinxAtStartPar
Whenever you use the command line on a Unix\sphinxhyphen{}based system, you do that in a command\sphinxhyphen{}line
interpreter that is referred to as a \sphinxcode{\sphinxupquote{shell}}.

\sphinxAtStartPar
The shell is used to start commands and display the output of those commands.
It also comes with its own primitive (yet surprisingly powerful) scripting language.

\sphinxAtStartPar
Many shells exist, though most belong to a family of shells called “Bourne Shells”
that descend from the original \sphinxcode{\sphinxupquote{sh}}. This is relevant, because they share (mostly)
a common syntax.

\sphinxAtStartPar
Two common shells are:
\begin{description}
\sphinxlineitem{\sphinxcode{\sphinxupquote{Bash}}}
\sphinxAtStartPar
The bourne\sphinxhyphen{}again shell (\sphinxcode{\sphinxupquote{bash}}) is the default shell on many *nix systems (most Linux distros, macOS).

\sphinxlineitem{\sphinxcode{\sphinxupquote{zsh}}}
\sphinxAtStartPar
The Z shell (\sphinxcode{\sphinxupquote{zsh}}) comes with many additional features, the highlights being:
shared history across running shells, smarter tab\sphinxhyphen{}completion, spelling correction, and better theming.

\end{description}

\sphinxAtStartPar
To determine what shell you’re in, run the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{n+nv}{\PYGZdl{}SHELL}
\PYG{g+go}{/usr/bin/bash}
\end{sphinxVerbatim}

\index{tab completion@\spxentry{tab completion}|spxpagem}\ignorespaces 

\section{Tab completion}
\label{\detokenize{intro/howto:tab-completion}}\label{\detokenize{intro/howto:index-9}}
\sphinxAtStartPar
One of the best features ever invented is tab completion. Imagine your favorite animal sitting
on your shoulder. Now imagine that animal shouting “TAB!” every time you’ve typed the first
3 letters of a word. Listen to that animal.

\sphinxAtStartPar
Tab completion autocompletes commands and paths when you press the Tab key.
If there are multiple matching options, pressing Tab twice will list them.

\sphinxAtStartPar
The greatest advantage of tab completion is not increased speed (though that is a nice benefit)
but rather the near elimination of typos — and the resulting reduction of cognitive load.
You can actually focus on the task you’re working on, rather than your typing. Tab\sphinxhyphen{}completion
will autocomplete a DataLad command, options you give to it, or paths.

\sphinxAtStartPar
For an example of tab\sphinxhyphen{}completion with paths, consider the following directory structure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{├── Desktop}
\PYG{g+go}{├── Documents}
\PYG{g+go}{│   ├── my\PYGZus{}awesome\PYGZus{}project}
\PYG{g+go}{│   └── my\PYGZus{}comics}
\PYG{g+go}{│      └── xkcd}
\PYG{g+go}{│      │   └── is\PYGZus{}it\PYGZus{}worth\PYGZus{}the\PYGZus{}time.png}
\PYG{g+go}{├── Downloads}
\end{sphinxVerbatim}

\sphinxAtStartPar
You’re in your home directory, and you want to navigate to your \sphinxhref{https://xkcd.com/1205}{xkcd}
comic selection in \sphinxcode{\sphinxupquote{Documents/my\_comics/xkcd}}.
Instead of typing the full path error\sphinxhyphen{}free, you can press Tab after the first few letters.
If it is unambiguous, such as \sphinxcode{\sphinxupquote{cd Doc \textless{}Tab\textgreater{}}}, it will expand to \sphinxcode{\sphinxupquote{cd Documents}}.
If there are multiple matching options, such as \sphinxcode{\sphinxupquote{cd Do}}, you will be prompted for more letters.
Pressing Tab again will list the matching options (\sphinxcode{\sphinxupquote{Documents}} and \sphinxcode{\sphinxupquote{Downloads}} in this case).

\sphinxAtStartPar
\sphinxstylestrong{That’s it \textendash{} equipped with the basics of the command line, you are good to go on your DataLad adventure!}

\sphinxstepscope

\index{what is@\spxentry{what is}!DataLad@\spxentry{DataLad}}\index{DataLad@\spxentry{DataLad}!what is@\spxentry{what is}}\ignorespaces 

\chapter{What you really need to know}
\label{\detokenize{intro/executive_summary:what-you-really-need-to-know}}\label{\detokenize{intro/executive_summary:executive-summary}}\label{\detokenize{intro/executive_summary:index-0}}\label{\detokenize{intro/executive_summary::doc}}
\sphinxAtStartPar
DataLad is a data management multitool that can assist you in handling the entire
life cycle of digital objects. It is a command\sphinxhyphen{}line tool, free and open source, and
available for all major operating systems.

\sphinxAtStartPar
This document is the 10.000 feet overview of important concepts, commands, and
capacities of DataLad. Each section briefly highlights one type of functionality or
concept and the associated commands, and the upcoming Basics chapters will demonstrate
in detail how to use them.


\section{DataLad datasets}
\label{\detokenize{intro/executive_summary:datalad-datasets}}
\sphinxAtStartPar
Every command affects or uses DataLad \sphinxstyleemphasis{datasets}, the core data structure of
DataLad. A \sphinxstyleemphasis{dataset} is a directory on a computer that DataLad manages.

\begin{figure}[tbp]
\centering

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{dataset}.pdf}
\end{figure}

\sphinxAtStartPar
You can create new, empty datasets from scratch and populate them,
or transform existing directories into datasets.


\section{Simplified local version control workflows}
\label{\detokenize{intro/executive_summary:simplified-local-version-control-workflows}}
\sphinxAtStartPar
Building on top of {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} and {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}, DataLad allows you to
version control arbitrarily large files in datasets.

\begin{figure}[tbp]
\centering

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{local_wf}.pdf}
\end{figure}

\sphinxAtStartPar
Thus, you can keep track of revisions of data of any size, and view, interact with or
restore any version of your dataset’s history.


\section{Consumption and collaboration}
\label{\detokenize{intro/executive_summary:consumption-and-collaboration}}
\sphinxAtStartPar
DataLad lets you consume datasets provided by others, and collaborate with them.
You can install existing datasets and update them from their sources, or create
sibling datasets that you can publish updates to and pull updates from for
collaboration and data sharing.

\begin{figure}[tbp]
\centering

\noindent\sphinxincludegraphics[width=1.300\linewidth]{{collaboration}.pdf}
\end{figure}

\sphinxAtStartPar
Additionally, you can get access to publicly available open
data collections with {\hyperref[\detokenize{glossary:term-the-DataLad-superdataset}]{\sphinxtermref{\DUrole{xref,std,std-term}{the DataLad superdataset ///}}}}.


\section{Dataset linkage}
\label{\detokenize{intro/executive_summary:dataset-linkage}}
\sphinxAtStartPar
Datasets can contain other datasets (subdatasets), nested arbitrarily deep. Each
dataset has an independent revision history, but can be registered at a precise version
in higher\sphinxhyphen{}level datasets. This allows to combine datasets and to perform commands recursively across
a hierarchy of datasets, and it is the basis for advanced provenance capture abilities.

\begin{figure}[tbp]
\centering

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{linkage_subds}.pdf}
\end{figure}


\section{Full provenance capture and reproducibility}
\label{\detokenize{intro/executive_summary:full-provenance-capture-and-reproducibility}}
\sphinxAtStartPar
DataLad allows to capture full {\hyperref[\detokenize{glossary:term-provenance}]{\sphinxtermref{\DUrole{xref,std,std-term}{provenance}}}}: The origin of datasets, the
origin of files obtained from web sources, complete machine\sphinxhyphen{}readable and
automatically reproducible records of how files were created (including software
environments).

\begin{figure}[tbp]
\centering

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{reproducible_execution}.pdf}
\end{figure}

\sphinxAtStartPar
You or your collaborators can thus reobtain or reproducibly recompute content
with a single command, and make use of extensive provenance of dataset content
(who created it, when, and how?).


\section{Third party service integration}
\label{\detokenize{intro/executive_summary:third-party-service-integration}}
\sphinxAtStartPar
Export datasets to third party services such as
\sphinxhref{https://github.com}{GitHub}, \sphinxhref{https://about.gitlab.com}{GitLab}, or
\sphinxhref{https://figshare.com}{Figshare} with built\sphinxhyphen{}in commands.

\begin{figure}[tbp]
\centering

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{thirdparty}.pdf}
\end{figure}

\sphinxAtStartPar
Alternatively, you can use a multitude of other available third party services such as
\sphinxhref{https://www.dropbox.com}{Dropbox}, \sphinxhref{https://drive.google.com/drive/my-drive}{Google Drive},
\sphinxhref{https://aws.amazon.com/s3}{Amazon S3}, \sphinxhref{https://owncloud.com}{owncloud},
or many more that DataLad datasets are compatible with.


\section{Metadata handling}
\label{\detokenize{intro/executive_summary:metadata-handling}}
\sphinxAtStartPar
Extract, aggregate, and query dataset metadata. This allows to automatically obtain
metadata according to different metadata standards (EXIF, XMP, ID3, BIDS, DICOM,
NIfTI1, …), store this metadata in a portable format, share it, and search dataset
contents.

\begin{figure}[tbp]
\centering

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{metadata_prov_imaging}.pdf}
\end{figure}


\section{All in all…}
\label{\detokenize{intro/executive_summary:all-in-all}}
\sphinxAtStartPar
You can use DataLad for a variety of use cases. At its core, it is a domain\sphinxhyphen{}agnostic
and self\sphinxhyphen{}effacing tool: DataLad allows to improve your data management without
custom data structures or the need for central infrastructure or third party
services.
If you are interested in more high\sphinxhyphen{}level information on DataLad, you can find
answers to common questions in the section \DUrole{xref,std,std-ref}{FAQ}, and a concise command
cheat\sphinxhyphen{}sheet in section {\hyperref[\detokenize{basics/101-136-cheatsheet:cheat}]{\sphinxcrossref{\DUrole{std,std-ref}{DataLad cheat sheet}}}} (\autopageref*{\detokenize{basics/101-136-cheatsheet:cheat}}).

\sphinxAtStartPar
But enough of the introduction now \textendash{} let’s dive into the
\DUrole{xref,std,std-ref}{basics\sphinxhyphen{}intro}

\sphinxstepscope


\chapter{DataLad datasets}
\label{\detokenize{basics/basics-datasets:datalad-datasets}}\label{\detokenize{basics/basics-datasets:chapter-datasets}}\label{\detokenize{basics/basics-datasets::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{datasets}.pdf}\hspace*{\fill}}

\sphinxstepscope

\index{create@\spxentry{create}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!create@\spxentry{create}}\index{create dataset@\spxentry{create dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!create dataset@\spxentry{create dataset}}\ignorespaces 

\section{Create a dataset}
\label{\detokenize{basics/101-101-create:create-a-dataset}}\label{\detokenize{basics/101-101-create:createds}}\label{\detokenize{basics/101-101-create:index-0}}\label{\detokenize{basics/101-101-create::doc}}
\sphinxAtStartPar
We are about to start the educational course \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}.
In order to follow along and organize course content, let us create
a directory on our computer to collate the materials, assignments, and
notes in.

\sphinxAtStartPar
Since this is \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}, let’s do it as a {\hyperref[\detokenize{glossary:term-DataLad-dataset}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad dataset}}}}.
You might associate the term “dataset” with a large spreadsheet containing
variables and data.
But for DataLad, a dataset is the core data type:
As noted in {\hyperref[\detokenize{intro/philosophy:philo}]{\sphinxcrossref{\DUrole{std,std-ref}{A brief overview of DataLad}}}} (\autopageref*{\detokenize{intro/philosophy:philo}}), a dataset is a collection of \sphinxstyleemphasis{files}
in folders, and a file is the smallest unit any dataset can contain.
Although this is a very simple concept, datasets come with many
useful features.
Because experiencing is more insightful than just reading, we will explore the
concepts of DataLad datasets together by creating one.

\sphinxAtStartPar
Find a nice place on your computer’s file system to put a dataset for \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}},
and create a fresh, empty dataset with the \sphinxcode{\sphinxupquote{datalad create}} command.

\sphinxAtStartPar
Note the command structure of \sphinxcode{\sphinxupquote{datalad create}} (optional bits are enclosed in \sphinxcode{\sphinxupquote{{[} {]}}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{datalad} \PYG{n}{create} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{description} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{...}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{n}{config} \PYG{n}{options}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYG{n}{PATH}
\end{sphinxVerbatim}

\index{set description for dataset location@\spxentry{set description for dataset location}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!set description for dataset location@\spxentry{set description for dataset location}}\ignorespaces \phantomsection\label{\detokenize{basics/101-101-create:createdescription}}\begin{findoutmore}[label={index-1}, before title={\thetcbcounter\ }, check odd page=true]{What is the description option of ‘datalad create’?}
\label{\detokenize{basics/101-101-create:index-1}}

\sphinxAtStartPar
The optional \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}description}} flag allows you to provide a short description of
the \sphinxstyleemphasis{location} of your dataset, for example with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}\PYGZhy{}description\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}course on DataLad\PYGZhy{}101 on my private laptop\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }text2git\PYG{+w}{ }DataLad\PYGZhy{}101
\end{sphinxVerbatim}

\sphinxAtStartPar
If you want, use the above command instead to provide a description. Its use will not be immediately clear now, but the chapter
{\hyperref[\detokenize{basics/basics-collaboration:chapter-collaboration}]{\sphinxcrossref{\DUrole{std,std-ref}{Collaboration}}}} (\autopageref*{\detokenize{basics/basics-collaboration:chapter-collaboration}}) shows where this description
ends up and how it may be useful.


\end{findoutmore}

\sphinxAtStartPar
Let’s start:

\index{create dataset@\spxentry{create dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!create dataset@\spxentry{create dataset}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-101-create:index-2}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }text2git\PYG{+w}{ }DataLad\PYGZhy{}101
\PYG{g+go}{[INFO] Running procedure cfg\PYGZus{}text2git}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{run(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 (dataset) [VIRTUALENV/bin/python /home/a...]}
\PYG{g+go}{create(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will create a dataset called \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} in the directory you are currently
in. For now, disregard \sphinxcode{\sphinxupquote{\sphinxhyphen{}c text2git}}. It applies a configuration template, but there
will be other parts of this book to explain this in detail.

\sphinxAtStartPar
Once created, a DataLad dataset looks like any other directory on your file system.
Currently, it seems empty.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }DataLad\PYGZhy{}101
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{    }\PYG{c+c1}{\PYGZsh{} ls does not show any output, because the dataset is empty.}
\end{sphinxVerbatim}

\sphinxAtStartPar
However, all files and directories you store within the DataLad dataset
can be tracked (should you want them to be tracked).
\sphinxstyleemphasis{Tracking} in this context means that edits done to a file are automatically
associated with information about the change, the author of the edit,
and the time of this change. This is already informative important on its own
\textendash{} the {\hyperref[\detokenize{glossary:term-provenance}]{\sphinxtermref{\DUrole{xref,std,std-term}{provenance}}}} captured with this can, for example, be used to learn
about a file’s lineage, and can establish trust in it.
But what is especially helpful is that previous states of files or directories
can be restored. Remember the last time you accidentally deleted content
in a file, but only realized \sphinxstyleemphasis{after} you saved it? With DataLad, no
mistakes are forever. We will see many examples of this later in the book,
and such information is stored in what we will refer
to as the \sphinxstyleemphasis{history} of a dataset.

\index{log@\spxentry{log}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!log@\spxentry{log}}\index{exit pager@\spxentry{exit pager}!in a terminal@\spxentry{in a terminal}}\index{in a terminal@\spxentry{in a terminal}!exit pager@\spxentry{exit pager}}\index{show history@\spxentry{show history}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!show history@\spxentry{show history}}\ignorespaces 
\sphinxAtStartPar
This history is almost as small as it can be at the current state, but let’s take
a look at it. For looking at the history, the code examples will use \sphinxcode{\sphinxupquote{git log}},
a built\sphinxhyphen{}in {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} command%
\begin{footnote}[1]\sphinxAtStartFootnote
A tool we can recommend as an alternative to \sphinxcode{\sphinxupquote{git log}} is {\hyperref[\detokenize{glossary:term-tig}]{\sphinxtermref{\DUrole{xref,std,std-term}{tig}}}}.
Once installed, exchange any \sphinxcode{\sphinxupquote{git log}} command you see here with the single word \sphinxcode{\sphinxupquote{tig}}.
%
\end{footnote} that works right in your terminal. Your log
\sphinxstyleemphasis{might} be opened in a terminal {\hyperref[\detokenize{glossary:term-pager}]{\sphinxtermref{\DUrole{xref,std,std-term}{pager}}}}
that lets you scroll up and down with your arrow keys, but not enter any more commands.
If this happens, you can get out of \sphinxcode{\sphinxupquote{git log}} by pressing \sphinxcode{\sphinxupquote{q}}. For Windows,
also see \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-adjustedmode-log}} {\hyperref[\detokenize{basics/101-101-create:ww-adjustedmode-log}]{\sphinxcrossref{\DUrole{std,std-ref}{on showing history}}}} (\autopageref*{\detokenize{basics/101-101-create:ww-adjustedmode-log}}).

\fvset{hllines={, 3, 4, 6, 9, 10, 12,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log
\PYG{g+go}{commit e0ff3a73✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    Instruct annex to add text files to Git}

\PYG{g+go}{commit 4ce681d6✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    [DATALAD] new dataset}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
We can see two {\hyperref[\detokenize{glossary:term-commit}]{\sphinxtermref{\DUrole{xref,std,std-term}{commit}}}}s in the history of the repository.
Each of them is identified by a unique 40 character sequence, called a
{\hyperref[\detokenize{glossary:term-shasum}]{\sphinxtermref{\DUrole{xref,std,std-term}{shasum}}}}.

\index{log@\spxentry{log}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!log@\spxentry{log}}\index{corresponding branch@\spxentry{corresponding branch}!in adjusted mode@\spxentry{in adjusted mode}}\index{in adjusted mode@\spxentry{in adjusted mode}!corresponding branch@\spxentry{corresponding branch}}\index{show history@\spxentry{show history}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!show history@\spxentry{show history}}\ignorespaces \begin{windowswit}[label={ww-adjustedmode-log}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Your Git log may be more extensive - use ‘git log main’ instead!}
\label{\detokenize{basics/101-101-create:ww-adjustedmode-log}}

\sphinxAtStartPar
The output of \sphinxcode{\sphinxupquote{git log}} shown in the book and the output you will see in your own datasets when executing the same commands may not always match \textendash{} many times you might see commits about a “git\sphinxhyphen{}annex adjusted branch” in your history.
This is expected, and if you want to read up more about this, please progress on to chapter {\hyperref[\detokenize{basics/basics-annex:chapter-gitannex}]{\sphinxcrossref{\DUrole{std,std-ref}{Under the hood: git\sphinxhyphen{}annex}}}} (\autopageref*{\detokenize{basics/basics-annex:chapter-gitannex}}) and afterwards take a look at \sphinxhref{https://git-annex.branchable.com/design/adjusted\_branches}{this part of git\sphinxhyphen{}annex documentation}.

\sphinxAtStartPar
In order to get a similar experience in your dataset, please add the name of your default {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} (it will likely have the name \sphinxcode{\sphinxupquote{main}} or \sphinxcode{\sphinxupquote{master}}) to every \sphinxcode{\sphinxupquote{git log}} command.
This should display the same output that the book displays.
The reason behind this is that datasets are using a special {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} to be functional on Windows.
This branch’s history differs from the history that would be in the default branch.
With this workaround, you will be able to display the dataset history from the same branch that the book and all other operating system display.
Thus, whenever the book code snippet contains a line that starts with \sphinxcode{\sphinxupquote{git log}}, copy it and append the term \sphinxcode{\sphinxupquote{main}} or \sphinxcode{\sphinxupquote{master}}, whichever is appropriate.


\end{windowswit}

\sphinxAtStartPar
Highlighted in this output is information about the author and about
the time, as well as a {\hyperref[\detokenize{glossary:term-commit-message}]{\sphinxtermref{\DUrole{xref,std,std-term}{commit message}}}} that summarizes the
performed action concisely. In this case, both commit messages were written by
DataLad itself. The most recent change is on the top. The first commit
written to the history therefore states that a new dataset was created,
and the second commit is related to the \sphinxcode{\sphinxupquote{\sphinxhyphen{}c text2git}} option (which
uses a configuration template to instruct DataLad to store text files
in Git, but more on this later).
While these commits were produced and described by DataLad,
in most other cases, you will have to create the commit and
an informative commit message yourself.

\sphinxAtStartPar
Congratulations, you just created your first DataLad dataset!
Let us now put some content inside.

\index{create dataset@\spxentry{create dataset}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!create dataset@\spxentry{create dataset}}\ignorespaces \begin{gitusernote}[label={index-5}, before title={\thetcbcounter\ }, check odd page=true]{Create internals}
\label{\detokenize{basics/101-101-create:index-5}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad create}} uses \sphinxcode{\sphinxupquote{git init}} and \sphinxcode{\sphinxupquote{git annex init}}. Therefore,
the DataLad dataset is a Git repository.
Large file content in the
dataset is tracked with git\sphinxhyphen{}annex. An \sphinxcode{\sphinxupquote{ls \sphinxhyphen{}a}}
reveals that Git has secretly done its work:

\fvset{hllines={, 4, 5, 6,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}a\PYG{+w}{ }\PYG{c+c1}{\PYGZsh{} show also hidden files}
\PYG{g+go}{.}
\PYG{g+go}{..}
\PYG{g+go}{.datalad}
\PYG{g+go}{.git}
\PYG{g+go}{.gitattributes}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
\sphinxstylestrong{For non\sphinxhyphen{}Git\sphinxhyphen{}Users:} these hidden \sphinxstyleemphasis{dot\sphinxhyphen{}directories} and \sphinxstyleemphasis{dot\sphinxhyphen{}files} are necessary for all Git operations. Please do not tamper with them, and, importantly, \sphinxstylestrong{do not delete them!}


\end{gitusernote}

\sphinxstepscope

\index{populate dataset@\spxentry{populate dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!populate dataset@\spxentry{populate dataset}}\ignorespaces 

\section{Populate a dataset}
\label{\detokenize{basics/101-102-populate:populate-a-dataset}}\label{\detokenize{basics/101-102-populate:populate}}\label{\detokenize{basics/101-102-populate:index-0}}\label{\detokenize{basics/101-102-populate::doc}}
\sphinxAtStartPar
The first lecture in DataLad\sphinxhyphen{}101 referenced some useful literature.
Even if we end up not reading those books at all, let’s download
them nevertheless and put them into our dataset. You never know, right?
Let’s first create a directory to save books for additional reading in.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mkdir\PYG{+w}{ }books
\end{sphinxVerbatim}

\index{tree@\spxentry{tree}!terminal command@\spxentry{terminal command}}\index{terminal command@\spxentry{terminal command}!tree@\spxentry{tree}}\ignorespaces 
\sphinxAtStartPar
Let’s take a look at the current directory structure with the tree command%
\begin{footnote}[1]\sphinxAtStartFootnote
\sphinxcode{\sphinxupquote{tree}} is a Unix command to list file system content. If it is not yet installed,
you can get it with your native package manager (e.g.,  \sphinxcode{\sphinxupquote{apt}}, \sphinxcode{\sphinxupquote{brew}}, or conda).
For example, if you use OSX, \sphinxcode{\sphinxupquote{brew install tree}}  will get you this tool.
Windows has its own \sphinxcode{\sphinxupquote{tree}} command.
Note that this \sphinxcode{\sphinxupquote{tree}} works slightly different than its Unix equivalent \sphinxhyphen{} by default, it will only display directories, not files, and the command options it accepts are either \sphinxcode{\sphinxupquote{/f}} (display file names) or \sphinxcode{\sphinxupquote{/a}} (change display of subdirectories to text instead of graphic characters).
%
\end{footnote}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }tree
\PYG{g+go}{.}
\PYG{g+go}{└── books}

\PYG{g+go}{1 directory, 0 files}
\end{sphinxVerbatim}

\sphinxAtStartPar
Arguably, not the most exciting thing to see. So let’s put some PDFs inside.
Below is a short list of optional readings. We decide to download them (they
are all free, in total about 15 MB), and save them in \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101/books}}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Additional reading about the command line: \sphinxhref{https://sourceforge.net/projects/linuxcommand/files/TLCL/19.01/TLCL-19.01.pdf/download}{The Linux Command Line}

\item {} 
\sphinxAtStartPar
An intro to Python: \sphinxhref{https://github.com/swaroopch/byte-of-python/releases/download/vadb91fc6fce27c58e3f931f5861806d3ccd1054c/byte-of-python.pdf}{A byte of Python}

\end{itemize}

\sphinxAtStartPar
You can either visit the links and save them in \sphinxcode{\sphinxupquote{books/}},
or run the following commands%
\begin{footnote}[2]\sphinxAtStartFootnote
\sphinxcode{\sphinxupquote{wget}} is a Unix command for non\sphinxhyphen{}interactively downloading files from the
web. If it is not yet installed, you can get it with your native package manager (e.g.,
\sphinxcode{\sphinxupquote{apt}} or \sphinxcode{\sphinxupquote{brew}}). For example, if you use OSX, \sphinxcode{\sphinxupquote{brew install wget}}
will get you this tool.
%
\end{footnote} to download the books right from the terminal.
Note that we line break the command with \sphinxcode{\sphinxupquote{\textbackslash{}}} line continuation characters. In your own work you can write
commands like this into a single line. If you copy them into your terminal as they
are presented here, make sure to check the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-no-multiline-commands}} {\hyperref[\detokenize{basics/101-102-populate:ww-no-multiline-commands}]{\sphinxcrossref{\DUrole{std,std-ref}{on peculiarities of its terminals}}}} (\autopageref*{\detokenize{basics/101-102-populate:ww-no-multiline-commands}}).

\index{line continuation@\spxentry{line continuation}!on Windows in a terminal@\spxentry{on Windows in a terminal}}\index{on Windows in a terminal@\spxentry{on Windows in a terminal}!line continuation@\spxentry{line continuation}}\ignorespaces \begin{windowswit}[label={ww-no-multiline-commands}, before title={\thetcbcounter\ }, float, floatplacement=tbp, check odd page=true]{Terminals other than Git Bash can’t handle multi-line commands}
\label{\detokenize{basics/101-102-populate:ww-no-multiline-commands}}

\sphinxAtStartPar
In Unix shells, \sphinxcode{\sphinxupquote{\textbackslash{}}} can be used to split a command into several lines, for example to aid readability.
Standard Windows terminals (including the Anaconda prompt) do not support this.
They instead use the \sphinxcode{\sphinxupquote{\textasciicircum{}}} character:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }wget\PYG{+w}{ }\PYGZhy{}q\PYG{+w}{ }https://sourceforge.net/projects/linuxcommand/files/TLCL/19.01/TLCL\PYGZhy{}19.01.pdf/download\PYG{+w}{ }\PYGZca{}
\PYG{g+go}{\PYGZhy{}O TLCL.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you are not using the Git Bash, you either need to copy multi\sphinxhyphen{}line commands into a single line, or use \sphinxcode{\sphinxupquote{\textasciicircum{}}} (make sure that there is \sphinxstylestrong{no space} afterwards) instead of \sphinxcode{\sphinxupquote{\textbackslash{}}}.


\end{windowswit}

\index{download file@\spxentry{download file}!with wget@\spxentry{with wget}}\index{with wget@\spxentry{with wget}!download file@\spxentry{download file}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-102-populate:index-3}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }books
\PYG{g+gp}{\PYGZdl{} }wget\PYG{+w}{ }\PYGZhy{}q\PYG{+w}{ }https://sourceforge.net/projects/linuxcommand/files/TLCL/19.01/TLCL\PYGZhy{}19.01.pdf/download\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}O\PYG{+w}{ }TLCL.pdf
\PYG{g+gp}{\PYGZdl{} }wget\PYG{+w}{ }\PYGZhy{}q\PYG{+w}{ }https://homepages.uc.edu/\PYGZti{}becktl/byte\PYGZus{}of\PYGZus{}python.pdf\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}O\PYG{+w}{ }byte\PYGZhy{}of\PYGZhy{}python.pdf
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} get back into the root of the dataset}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\end{sphinxVerbatim}

\sphinxAtStartPar
Some machines will not have \sphinxcode{\sphinxupquote{ wget}} available by default, but any command that can
download a file can work as an alternative. See the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-curl-instead-wget}} {\hyperref[\detokenize{basics/101-102-populate:ww-curl-instead-wget}]{\sphinxcrossref{\DUrole{std,std-ref}{for the popular alternative
curl}}}} (\autopageref*{\detokenize{basics/101-102-populate:ww-curl-instead-wget}}).

\index{curl instead of wget@\spxentry{curl instead of wget}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!curl instead of wget@\spxentry{curl instead of wget}}\index{download file@\spxentry{download file}!with curl@\spxentry{with curl}}\index{with curl@\spxentry{with curl}!download file@\spxentry{download file}}\ignorespaces \begin{windowswit}[label={ww-curl-instead-wget}, before title={\thetcbcounter\ }, float, floatplacement=tbp, check odd page=true]{You can use curl instead of wget}
\label{\detokenize{basics/101-102-populate:ww-curl-instead-wget}}

\sphinxAtStartPar
Many versions of Windows do not ship with the tool \sphinxcode{\sphinxupquote{wget}}.
You can install it, but it may be easier to use the pre\sphinxhyphen{}installed \sphinxcode{\sphinxupquote{curl}} command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }books
\PYG{g+gp}{\PYGZdl{} }curl\PYG{+w}{ }\PYGZhy{}L\PYG{+w}{ }https://sourceforge.net/projects/linuxcommand/files/TLCL/19.01/TLCL\PYGZhy{}19.01.pdf/download\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}o\PYG{+w}{ }TLCL.pdf
\PYG{g+gp}{\PYGZdl{} }curl\PYG{+w}{ }\PYGZhy{}L\PYG{+w}{ }https://github.com/swaroopch/byte\PYGZhy{}of\PYGZhy{}python/releases/download/vadb91fc6fce27c58e3f931f5861806d3ccd1054c/byte\PYGZhy{}of\PYGZhy{}python.pdf\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}o\PYG{+w}{ }byte\PYGZhy{}of\PYGZhy{}python.pdf
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\end{sphinxVerbatim}


\end{windowswit}

\sphinxAtStartPar
Let’s see what happened. First of all, in the root of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}, show the directory
structure with tree:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }tree
\PYG{g+go}{.}
\PYG{g+go}{└── books}
\PYG{g+go}{    ├── byte\PYGZhy{}of\PYGZhy{}python.pdf}
\PYG{g+go}{    └── TLCL.pdf}

\PYG{g+go}{1 directory, 2 files}
\end{sphinxVerbatim}

\index{status@\spxentry{status}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!status@\spxentry{status}}\index{check dataset for modification@\spxentry{check dataset for modification}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!check dataset for modification@\spxentry{check dataset for modification}}\ignorespaces 
\sphinxAtStartPar
Now what does DataLad do with this new content? One command you will use very
often is \sphinxcode{\sphinxupquote{datalad status}}.
It reports on the state of dataset content, and
regular status reports should become a habit in the wake of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: books (directory)}
\end{sphinxVerbatim}

\index{save@\spxentry{save}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!save@\spxentry{save}}\index{save dataset modification@\spxentry{save dataset modification}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!save dataset modification@\spxentry{save dataset modification}}\ignorespaces 
\sphinxAtStartPar
Interesting; the \sphinxcode{\sphinxupquote{books/}} directory is “untracked”. Remember how content
\sphinxstyleemphasis{can} be tracked \sphinxstyleemphasis{if a user wants to}?
Untracked means that DataLad does not know about this directory or its content,
because we have not instructed DataLad to actually track it. This means that DataLad
does not store the downloaded books in its history yet. Let’s change this by
\sphinxstyleemphasis{saving} the files to the dataset’s history with the \sphinxcode{\sphinxupquote{datalad save}} command.

\sphinxAtStartPar
This time, it is your turn to specify a helpful {\hyperref[\detokenize{glossary:term-commit-message}]{\sphinxtermref{\DUrole{xref,std,std-term}{commit message}}}}
with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}m}} option (although the DataLad command is \sphinxcode{\sphinxupquote{datalad save}}, we talk
about commit messages because \sphinxcode{\sphinxupquote{datalad save}} ultimately uses the command
\sphinxcode{\sphinxupquote{git commit}} to do its work):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add books on Python and Unix to read later\PYGZdq{}}
\PYG{g+go}{add(ok): books/TLCL.pdf (file)}
\PYG{g+go}{add(ok): books/byte\PYGZhy{}of\PYGZhy{}python.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you ever forget to specify a message, or made a typo, not all is lost. A
\textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-amend-save}} {\hyperref[\detokenize{basics/101-102-populate:fom-amend-save}]{\sphinxcrossref{\DUrole{std,std-ref}{explains how to amend a saved state}}}} (\autopageref*{\detokenize{basics/101-102-populate:fom-amend-save}}).

\index{amend commit message@\spxentry{amend commit message}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!amend commit message@\spxentry{amend commit message}}\ignorespaces \begin{findoutmore}[label={fom-amend-save}, before title={\thetcbcounter\ }, float, floatplacement=tbp, check odd page=true]{“Oh no! I forgot the -m option for ‘datalad save’!”}
\label{\detokenize{basics/101-102-populate:fom-amend-save}}

\sphinxAtStartPar
If you forget to specify a commit message with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}m}} option, DataLad will write
\sphinxcode{\sphinxupquote{{[}DATALAD{]} Recorded changes}} as a commit message into your history.
This is not particularly informative.
You can change the \sphinxstyleemphasis{last} commit message with the Git command
\sphinxcode{\sphinxupquote{git commit \sphinxhyphen{}\sphinxhyphen{}amend}}. This will open up your default editor
and you can edit
the commit message. Careful \textendash{} the default editor might be {\hyperref[\detokenize{glossary:term-vim}]{\sphinxtermref{\DUrole{xref,std,std-term}{vim}}}}!
The section {\hyperref[\detokenize{basics/101-137-history:history}]{\sphinxcrossref{\DUrole{std,std-ref}{Git things done}}}} (\autopageref*{\detokenize{basics/101-137-history:history}}) will show you many more ways in which you can
interact with a dataset’s history.


\end{findoutmore}

\sphinxAtStartPar
As already noted, any files you \sphinxcode{\sphinxupquote{save}} in this dataset, and all modifications
to these files that you \sphinxcode{\sphinxupquote{save}}, are tracked in this history.
Importantly, this file tracking works
regardless of the size of the files \textendash{} a DataLad dataset could be
your private music or movie collection with single files being many GB in size.
This is one aspect that distinguishes DataLad from many other
version control tools, among them Git.
Large content is tracked in an \sphinxstyleemphasis{annex} that is automatically
created and handled by DataLad. Whether text files or larger files change,
all of these changes can be written to your DataLad dataset’s history.

\index{log@\spxentry{log}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!log@\spxentry{log}}\index{show last commit@\spxentry{show last commit}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!show last commit@\spxentry{show last commit}}\ignorespaces 
\sphinxAtStartPar
Let’s see how the saved content shows up in the history of the dataset with \sphinxcode{\sphinxupquote{git log}}.
The option \sphinxcode{\sphinxupquote{\sphinxhyphen{}n 1}} specifies that we want to take a look at the most recent commit.
In order to get a bit more details, we add the \sphinxcode{\sphinxupquote{\sphinxhyphen{}p}} flag. If you end up in a
{\hyperref[\detokenize{glossary:term-pager}]{\sphinxtermref{\DUrole{xref,std,std-term}{pager}}}}, navigate with up and down arrow keys and leave the log by typing \sphinxcode{\sphinxupquote{q}}:

\fvset{hllines={, 3, 4, 6, 8, 12, 16, 20,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}p\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}
\PYG{g+go}{commit b40316a6✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    add books on Python and Unix to read later}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/books/TLCL.pdf b/books/TLCL.pdf}
\PYG{g+go}{new file mode 120000}
\PYG{g+go}{index 0000000..4c84b61}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/books/TLCL.pdf}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1 @@}
\PYG{g+go}{+../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\PYG{g+go}{\PYGZbs{} No newline at end of file}
\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/books/byte\PYGZhy{}of\PYGZhy{}python.pdf b/books/byte\PYGZhy{}of\PYGZhy{}python.pdf}
\PYG{g+go}{new file mode 120000}
\PYG{g+go}{index 0000000..7a6e51e}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/books/byte\PYGZhy{}of\PYGZhy{}python.pdf}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Now this might look a bit cryptic (and honestly, tig%
\begin{footnote}[3]\sphinxAtStartFootnote
See {\hyperref[\detokenize{glossary:term-tig}]{\sphinxtermref{\DUrole{xref,std,std-term}{tig}}}}. Once installed, exchange any git log command you
see here with the single word \sphinxcode{\sphinxupquote{tig}}.
%
\end{footnote} makes it look prettier).
But this tells us the date and time in which a particular author added two PDFs to
the directory \sphinxcode{\sphinxupquote{books/}}, and thanks to that commit message we have a nice
human\sphinxhyphen{}readable summary of that action. A \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-commit-message-guidance}} {\hyperref[\detokenize{basics/101-102-populate:fom-commit-message-guidance}]{\sphinxcrossref{\DUrole{std,std-ref}{explains what makes
a good message}}}} (\autopageref*{\detokenize{basics/101-102-populate:fom-commit-message-guidance}}).

\index{recommendation@\spxentry{recommendation}!commit message@\spxentry{commit message}}\index{commit message@\spxentry{commit message}!recommendation@\spxentry{recommendation}}\ignorespaces \begin{findoutmore}[label={fom-commit-message-guidance}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{DOs and DON’Ts for commit messages}
\label{\detokenize{basics/101-102-populate:fom-commit-message-guidance}}

\sphinxAtStartPar
\sphinxstylestrong{DOs}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Write a \sphinxstyleemphasis{title line} with 72 characters or less

\item {} 
\sphinxAtStartPar
Use imperative voice, e.g., “Add notes from lecture 2”

\item {} 
\sphinxAtStartPar
If a title line is not enough to express your changes and reasoning behind it, add a body to your commit message: hit enter twice (before closing the quotation marks), and continue writing a brief summary of the changes after a blank line. This summary should explain “what” has been done and “why”, but not “how”. Close the quotation marks, and hit enter to save the change with your message.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{DON’Ts}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Avoid passive voice

\item {} 
\sphinxAtStartPar
Extensive formatting (hashes, asterisks, quotes, …) will most likely make your shell complain

\item {} 
\sphinxAtStartPar
Do not say nasty things about other people

\end{itemize}


\end{findoutmore}

\index{no staging@\spxentry{no staging}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!no staging@\spxentry{no staging}}\ignorespaces \begin{gitusernote}[label={index-10}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{There is no staging area in DataLad}
\label{\detokenize{basics/101-102-populate:index-10}}

\sphinxAtStartPar
Just as in Git, new files are not tracked from their creation on, but only when
explicitly added to Git (in Git terms, with an initial \sphinxcode{\sphinxupquote{git add}}). But different
from the common Git workflow, DataLad skips the staging area. A \sphinxcode{\sphinxupquote{datalad save}}
combines a \sphinxcode{\sphinxupquote{git add}} and a \sphinxcode{\sphinxupquote{git commit}}, and therefore, the commit message
is specified with \sphinxcode{\sphinxupquote{datalad save}}.


\end{gitusernote}

\sphinxAtStartPar
Cool, so now you have added some files to your dataset history. But what is a bit
inconvenient is that both books were saved \sphinxstyleemphasis{together}. You begin to wonder: “A Python
book and a Unix book do not have that much in common. I probably should not save them
in the same commit. And … what happens if I have files I do not want to track?
\sphinxcode{\sphinxupquote{datalad save \sphinxhyphen{}m "some commit message"}} would save all of what is currently
untracked or modified in the dataset into the history!”

\sphinxAtStartPar
Regarding your first remark, you are absolutely right!
It is good practice to save only those changes
together that belong together. We do not want to squish completely unrelated changes
into the same spot of our history, because it would get very nasty should we want to
revert \sphinxstyleemphasis{some} of the changes without affecting others in this commit.

\sphinxAtStartPar
Luckily, we can point \sphinxcode{\sphinxupquote{datalad save}} to exactly the changes we want it to record.
Let’s try this by adding yet another book, a good reference work about git,
\sphinxhref{https://git-scm.com/book/en/v2}{Pro Git}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }books
\PYG{g+gp}{\PYGZdl{} }wget\PYG{+w}{ }\PYGZhy{}q\PYG{+w}{ }https://github.com/progit/progit2/releases/download/2.1.154/progit.pdf
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad status}} shows that there is a new untracked file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: books/progit.pdf (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s give \sphinxcode{\sphinxupquote{datalad save}} precisely this file by specifying its path after the commit message:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add reference book about git\PYGZdq{}}\PYG{+w}{ }books/progit.pdf
\PYG{g+go}{add(ok): books/progit.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Regarding your second remark, you are right that a \sphinxcode{\sphinxupquote{datalad save}} without a
path specification would write all of the currently untracked files or modifications
to the history. But check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-save-updated-only}} {\hyperref[\detokenize{basics/101-102-populate:fom-save-updated-only}]{\sphinxcrossref{\DUrole{std,std-ref}{on how to tell it otherwise}}}} (\autopageref*{\detokenize{basics/101-102-populate:fom-save-updated-only}}).

\index{save already tracked files only@\spxentry{save already tracked files only}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!save already tracked files only@\spxentry{save already tracked files only}}\ignorespaces \begin{findoutmore}[label={fom-save-updated-only}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{How to save already tracked dataset components only?}
\label{\detokenize{basics/101-102-populate:fom-save-updated-only}}

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{datalad save \sphinxhyphen{}m "concise message" \sphinxhyphen{}\sphinxhyphen{}updated}} (or the shorter
form of \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}updated}}, \sphinxcode{\sphinxupquote{\sphinxhyphen{}u}}) will only write \sphinxstyleemphasis{modifications} to the
history, not untracked files. Later, we will also see \sphinxcode{\sphinxupquote{.gitignore}} files
that let you hide content from version control.  However, it is good
practice to safely store away modifications or new content.  This improves
your dataset and workflow, and will be a requirement for executing certain
commands.


\end{findoutmore}

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{datalad status}} should now be empty, and our dataset’s history should look like this:

\index{show history (compact)@\spxentry{show history}\spxextra{compact}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!show history (compact)@\spxentry{show history}\spxextra{compact}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-102-populate:index-12}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} lets make the output a bit more concise with the \PYGZhy{}\PYGZhy{}oneline option}
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{a875e49 add reference book about git}
\PYG{g+go}{b40316a add books on Python and Unix to read later}
\PYG{g+go}{e0ff3a7 Instruct annex to add text files to Git}
\PYG{g+go}{4ce681d [DATALAD] new dataset}
\end{sphinxVerbatim}

\sphinxAtStartPar
“Wonderful! I’m getting a hang on this quickly”, you think. “Version controlling
files is not as hard as I thought!”

\sphinxAtStartPar
But downloading and adding content to your dataset “manually” has two
disadvantages: For one, it requires you to download the content and save it.
Compared to a workflow with no DataLad dataset, this is one additional command
you have to perform (\sphinxhref{https://xkcd.com/1205}{and that additional time adds up, after a while}). But a more
serious disadvantage is that you have no electronic record of the source of the
contents you added. The amount of {\hyperref[\detokenize{glossary:term-provenance}]{\sphinxtermref{\DUrole{xref,std,std-term}{provenance}}}}, the time, date, and author
of file, is already quite nice, but we don’t know anything about where you downloaded
these files from. If you would want to find out, you would have to \sphinxstyleemphasis{remember}
where you got the content from \textendash{} and brains are not made for such tasks.

\sphinxAtStartPar
Luckily, DataLad has a command that will solve both of these problems:
The \sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}} command.
We will dive deeper into the provenance\sphinxhyphen{}related benefits of using it in later chapters, but for now,
we’ll start with best\sphinxhyphen{}practice\sphinxhyphen{}building. \sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}} can retrieve content
from a URL (following any URL\sphinxhyphen{}scheme from https, http, or ftp or s3) and save it
into the dataset together with a human\sphinxhyphen{}readable commit message and a hidden,
machine\sphinxhyphen{}readable record of the origin of the content. This saves you time,
and captures {\hyperref[\detokenize{glossary:term-provenance}]{\sphinxtermref{\DUrole{xref,std,std-term}{provenance}}}} information about the data you add to your dataset.
To experience this, let’s add a final book,
\sphinxhref{https://tldp.org/LDP/Bash-Beginners-Guide/Bash-Beginners-Guide.pdf}{a beginner’s guide to bash},
to the dataset. We provide the command with a URL, a pointer to the dataset the
file should be saved in (\sphinxcode{\sphinxupquote{.}} denotes “current directory”), and a commit message.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }download\PYGZhy{}url\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }https://www.tldp.org/LDP/Bash\PYGZhy{}Beginners\PYGZhy{}Guide/Bash\PYGZhy{}Beginners\PYGZhy{}Guide.pdf\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}dataset\PYG{+w}{ }.\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add beginners guide on bash\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}O\PYG{+w}{ }books/bash\PYGZus{}guide.pdf
\PYG{g+go}{download\PYGZus{}url(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/books/bash\PYGZus{}guide.pdf (file)}
\PYG{g+go}{add(ok): books/bash\PYGZus{}guide.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Afterwards, a fourth book is inside your \sphinxcode{\sphinxupquote{books/}} directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }books
\PYG{g+go}{bash\PYGZus{}guide.pdf}
\PYG{g+go}{byte\PYGZhy{}of\PYGZhy{}python.pdf}
\PYG{g+go}{progit.pdf}
\PYG{g+go}{TLCL.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
However, the \sphinxcode{\sphinxupquote{datalad status}} command does not return any output \textendash{}
the dataset state is “clean”:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is because \sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}} took care of saving for you:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}p\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}
\PYG{g+go}{commit 59ac8d32✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    add beginners guide on bash}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/books/bash\PYGZus{}guide.pdf b/books/bash\PYGZus{}guide.pdf}
\PYG{g+go}{new file mode 120000}
\PYG{g+go}{index 0000000..00ca6bd}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/books/bash\PYGZus{}guide.pdf}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1 @@}
\PYG{g+go}{+../.git/annex/objects/WF/Gq/✂/MD5E\PYGZhy{}s1198170\PYGZhy{}\PYGZhy{}0ab2c121✂MD5.pdf}
\PYG{g+go}{\PYGZbs{} No newline at end of file}
\end{sphinxVerbatim}

\sphinxAtStartPar
At this point in time, the biggest advantage may seem to be the time save. However,
soon you will experience how useful it is to have DataLad keep track for you where
file content came from.

\sphinxAtStartPar
To conclude this section, let’s take a final look at the history of your dataset at
this point:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{59ac8d3 add beginners guide on bash}
\PYG{g+go}{a875e49 add reference book about git}
\PYG{g+go}{b40316a add books on Python and Unix to read later}
\PYG{g+go}{e0ff3a7 Instruct annex to add text files to Git}
\PYG{g+go}{4ce681d [DATALAD] new dataset}
\end{sphinxVerbatim}

\sphinxAtStartPar
Well done! Your \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset and its history are slowly growing.

\sphinxstepscope

\index{modify dataset@\spxentry{modify dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!modify dataset@\spxentry{modify dataset}}\ignorespaces 

\section{Modify content}
\label{\detokenize{basics/101-103-modify:modify-content}}\label{\detokenize{basics/101-103-modify:modify}}\label{\detokenize{basics/101-103-modify:index-0}}\label{\detokenize{basics/101-103-modify::doc}}
\sphinxAtStartPar
So far, we’ve only added new content to the dataset. And we have not done
much to that content up to this point, to be honest. Let’s see what happens if
we add content, and then modify it.

\sphinxAtStartPar
For this, in the root of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}, create a plain text file
called \sphinxcode{\sphinxupquote{notes.txt}}. It will contain all of the notes that you take
throughout the course.

\sphinxAtStartPar
Let’s write a short summary of how to create a DataLad dataset from scratch:
\begin{quote}

\sphinxAtStartPar
“One can create a new dataset with ‘datalad create
{[}\textendash{}description{]} PATH’. The dataset is created empty”.
\end{quote}

\sphinxAtStartPar
This is meant to be a note you would take in an educational course.
You can take this note and write it to a file with an editor of your choice.
The next code snippet, however, contains this note within the start and end part of a
\sphinxhref{https://en.wikipedia.org/wiki/Here\_document}{heredoc}.
You can also copy the full code snippet, starting
from \sphinxcode{\sphinxupquote{cat \textless{}\textless{} EOT \textgreater{} notes.txt}}, including the \sphinxcode{\sphinxupquote{EOT}} in the last line, in your
terminal to write this note from the terminal (without any editor) into \sphinxcode{\sphinxupquote{notes.txt}}.
Check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-heredoc}} {\hyperref[\detokenize{basics/101-103-modify:fom-heredoc}]{\sphinxcrossref{\DUrole{std,std-ref}{on some heredocs background}}}} (\autopageref*{\detokenize{basics/101-103-modify:fom-heredoc}}).

\index{here\sphinxhyphen{}document@\spxentry{here\sphinxhyphen{}document}}\index{heredoc@\spxentry{heredoc}}\ignorespaces \begin{findoutmore}[label={fom-heredoc}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{How does a heredoc (here-document) work?}
\label{\detokenize{basics/101-103-modify:fom-heredoc}}

\sphinxAtStartPar
The code snippet makes sure to write lines of text into a
file (that so far does not exist) called \sphinxcode{\sphinxupquote{notes.txt}}.

\sphinxAtStartPar
To do this, the content of the “document” is wrapped in between
\sphinxstyleemphasis{delimiting identifiers}. Here, these identifiers are \sphinxstyleemphasis{EOT} (short
for “end of text”), but naming is arbitrary as long as the two identifiers
are identical. The first “EOT” identifies the start of the text stream, and
the second “EOT” terminates the text stream.

\sphinxAtStartPar
The characters \sphinxcode{\sphinxupquote{\textless{}\textless{}}} redirect the text stream into
\sphinxhref{https://en.wikipedia.org/wiki/Standard\_streams\#Standard\_input\_(stdin)}{“standard input” (stdin)},
the standard location that provides the \sphinxstyleemphasis{input} for a command.
Thus, the text stream becomes the input for the
\sphinxhref{https://en.wikipedia.org/wiki/Cat\_(Unix)}{cat command}, which takes
the input and writes it to
\sphinxhref{https://en.wikipedia.org/wiki/Standard\_streams\#Standard\_output\_(stdout)}{“standard output” (stdout)}.

\sphinxAtStartPar
Lastly, the \sphinxcode{\sphinxupquote{\textgreater{}}} character takes \sphinxcode{\sphinxupquote{stdout}} can creates a new file
\sphinxcode{\sphinxupquote{notes.txt}} with \sphinxcode{\sphinxupquote{stdout}} as its contents.

\sphinxAtStartPar
It might seem like a slightly convoluted way to create a text file with
a note in it. But it allows to write notes from the terminal, enabling
this book to create commands you can execute with nothing other than your terminal.
You are free to copy\sphinxhyphen{}paste the snippets with the heredocs,
or find a workflow that suites you better. The only thing important is that
you create and modify a \sphinxcode{\sphinxupquote{.txt}} file while working with this book.


\end{findoutmore}

\sphinxAtStartPar
Running this command will create \sphinxcode{\sphinxupquote{notes.txt}} in the
root of your \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset, but see the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-heredoc}} {\hyperref[\detokenize{basics/101-103-modify:ww-heredoc}]{\sphinxcrossref{\DUrole{std,std-ref}{on terminal compatibility}}}} (\autopageref*{\detokenize{basics/101-103-modify:ww-heredoc}}):

\index{heredoc@\spxentry{heredoc}}\index{heredoc@\spxentry{heredoc}!on Windows in a terminal@\spxentry{on Windows in a terminal}}\index{on Windows in a terminal@\spxentry{on Windows in a terminal}!heredoc@\spxentry{heredoc}}\ignorespaces \begin{windowswit}[label={ww-heredoc}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Heredocs don’t work under non-Git-Bash Windows terminals}
\label{\detokenize{basics/101-103-modify:ww-heredoc}}

\sphinxAtStartPar
Heredocs rely on Unix\sphinxhyphen{}type redirection and multi\sphinxhyphen{}line commands \textendash{} which is not supported on most native Windows terminals or the Anaconda prompt on Windows.
If you are using an Anaconda prompt or a Windows terminal other than Git Bash, instead of executing heredocs, please open up an editor and paste and save the text into it.

\sphinxAtStartPar
The relevant text in the snippet below would be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
One can create a new dataset with \PYGZsq{}datalad create [\PYGZhy{}\PYGZhy{}description] PATH\PYGZsq{}.
The dataset is created empty
\end{sphinxVerbatim}

\sphinxAtStartPar
If you are using Git Bash, however, here docs will work just fine.


\end{windowswit}

\index{create heredoc@\spxentry{create heredoc}!in a terminal@\spxentry{in a terminal}}\index{in a terminal@\spxentry{in a terminal}!create heredoc@\spxentry{create heredoc}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-103-modify:index-3}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYG{+w}{ }notes.txt
\PYG{g+go}{One can create a new dataset with \PYGZsq{}datalad create [\PYGZhy{}\PYGZhy{}description] PATH\PYGZsq{}.}
\PYG{g+go}{The dataset is created empty}

\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\index{check dataset for modification@\spxentry{check dataset for modification}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!check dataset for modification@\spxentry{check dataset for modification}}\ignorespaces 
\sphinxAtStartPar
Run \sphinxcode{\sphinxupquote{datalad status}} to confirm that there is a new, untracked file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: notes.txt (file)}
\end{sphinxVerbatim}

\index{save dataset modification@\spxentry{save dataset modification}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!save dataset modification@\spxentry{save dataset modification}}\ignorespaces 
\sphinxAtStartPar
Save the current state of this file in your dataset’s history. Because it is the only modification
in the dataset, there is no need to specify a path.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Add notes on datalad create\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
But now, let’s see how \sphinxstyleemphasis{changing} tracked content works.
Modify this file by adding another note. After all, you already know how to use
\sphinxcode{\sphinxupquote{datalad save}}, so write a short summary on that as well.

\sphinxAtStartPar
Again, the example uses Unix commands (\sphinxcode{\sphinxupquote{cat}} and redirection, this time however
with \sphinxcode{\sphinxupquote{\textgreater{}\textgreater{}}} to \sphinxstyleemphasis{append} new content to the existing file)
to accomplish this, but you can take any editor of your choice.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }notes.txt
\PYG{g+go}{The command \PYGZdq{}datalad save [\PYGZhy{}m] PATH\PYGZdq{} saves the file (modifications) to}
\PYG{g+go}{history.}
\PYG{g+go}{Note to self: Always use informative, concise commit messages.}

\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s check the dataset’s current state:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{ modified: notes.txt (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
and save the file in DataLad:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add note on datalad save\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s take another look into our history to see the development of this file.
We are using \sphinxcode{\sphinxupquote{git log \sphinxhyphen{}p \sphinxhyphen{}n 2}} to see last two commits and explore
the difference to the previous state of a file within each commit.

\fvset{hllines={, 6, 25,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}p\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{2}
\PYG{g+go}{commit e310b465✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    add note on datalad save}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/notes.txt b/notes.txt}
\PYG{g+go}{index 3a7a1fe..0142412 100644}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} a/notes.txt}
\PYG{g+go}{+++ b/notes.txt}
\PYG{g+go}{@@ \PYGZhy{}1,3 +1,7 @@}
\PYG{g+go}{ One can create a new dataset with \PYGZsq{}datalad create [\PYGZhy{}\PYGZhy{}description] PATH\PYGZsq{}.}
\PYG{g+go}{ The dataset is created empty}

\PYG{g+go}{+The command \PYGZdq{}datalad save [\PYGZhy{}m] PATH\PYGZdq{} saves the file (modifications) to}
\PYG{g+go}{+history.}
\PYG{g+go}{+Note to self: Always use informative, concise commit messages.}
\PYG{g+go}{+}

\PYG{g+go}{commit 874d766f✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    Add notes on datalad create}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/notes.txt b/notes.txt}
\PYG{g+go}{new file mode 100644}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
We can see that the history can not only show us the commit message attached to
a commit, but also the precise change that occurred in the text file in the commit.
Additions are marked with a \sphinxcode{\sphinxupquote{+}}, and deletions would be shown with a leading \sphinxcode{\sphinxupquote{\sphinxhyphen{}}}.
From the dataset’s history, we can therefore also find out \sphinxstyleemphasis{how} the text file
evolved over time. That’s quite neat, isn’t it?
Check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-log-options}} {\hyperref[\detokenize{basics/101-103-modify:fom-log-options}]{\sphinxcrossref{\DUrole{std,std-ref}{on \textquotesingle{}git log\textquotesingle{} for even more possibilities}}}} (\autopageref*{\detokenize{basics/101-103-modify:fom-log-options}}).

\index{log@\spxentry{log}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!log@\spxentry{log}}\index{get help@\spxentry{get help}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!get help@\spxentry{get help}}\index{filter history@\spxentry{filter history}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!filter history@\spxentry{filter history}}\ignorespaces \begin{findoutmore}[label={fom-log-options}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{‘git log’ has many more useful options}
\label{\detokenize{basics/101-103-modify:fom-log-options}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{git log}}, as many other \sphinxcode{\sphinxupquote{Git}} commands, has a good number of options
which you can discover if you run \sphinxcode{\sphinxupquote{git log \sphinxhyphen{}\sphinxhyphen{}help}}.  Those options could
help to find specific changes (e.g., which added or removed a specific word
with \sphinxcode{\sphinxupquote{\sphinxhyphen{}S}}), or change how \sphinxcode{\sphinxupquote{git log}} output will look (e.g.,
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}word\sphinxhyphen{}diff}} to highlight individual word changes).


\end{findoutmore}

\sphinxstepscope

\index{clone@\spxentry{clone}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!clone@\spxentry{clone}}\index{clone dataset@\spxentry{clone dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!clone dataset@\spxentry{clone dataset}}\ignorespaces 

\section{Install datasets}
\label{\detokenize{basics/101-105-install:install-datasets}}\label{\detokenize{basics/101-105-install:installds}}\label{\detokenize{basics/101-105-install:index-0}}\label{\detokenize{basics/101-105-install::doc}}
\sphinxAtStartPar
So far, we have created a \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} course dataset. We saved some additional readings
into the dataset, and have carefully made and saved notes on the DataLad
commands we discovered. Up to this point, we therefore know the typical, \sphinxstyleemphasis{local}
workflow to create and populate a dataset from scratch.

\sphinxAtStartPar
But we’ve been told that with DataLad we could very easily get vast amounts of data to our
computer. Rumor has it that this would be only a single command in the terminal!
Therefore, everyone in today’s lecture excitedly awaits today’s topic: Installing datasets.

\sphinxAtStartPar
“With DataLad, users can install \sphinxstyleemphasis{clones} of existing DataLad datasets from paths, URLs, or
open\sphinxhyphen{}data collections” our lecturer begins.
“This makes accessing data fast and easy. A dataset that others could install can be
created by anyone, without a need for additional software. Your own datasets can be
installed by others, should you want that, for example. Therefore, not only accessing
data becomes fast and easy, but also \sphinxstyleemphasis{sharing}.”
“That’s so cool!”, you think. “Exam preparation will be a piece of cake if all of us
can share our mid\sphinxhyphen{}term and final projects easily!”
“But today, let’s only focus on how to install a dataset”, she continues.
“Damn it! Can we not have longer lectures?”, you think and set alarms to all of the
upcoming lecture dates in your calendar.
There is so much exciting stuff to come, you cannot miss a single one.

\sphinxAtStartPar
“Psst!” a student from the row behind reaches over. “There are
a bunch of audio recordings of a really cool podcast, and they have been shared in the form
of a DataLad dataset! Shall we try whether we can install that?”

\sphinxAtStartPar
“Perfect! What a great way to learn how to install a dataset. Doing it
now instead of looking at slides for hours is my preferred type of learning anyway”,
you think as you fire up your terminal and navigate into your \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset.

\sphinxAtStartPar
In this demonstration, we are using one of the many openly available datasets that
DataLad provides in a public registry that anyone can access. One of these datasets is a
collection of audio recordings of a great podcast, the longnow seminar series%
\begin{footnote}[2]\sphinxAtStartFootnote
The longnow podcasts are lectures and conversations on long\sphinxhyphen{}term thinking produced by
the LongNow foundation and we can wholeheartedly recommend them for their worldly
wisdoms and compelling, thoughtful ideas. Subscribe to the podcasts at \sphinxurl{https://longnow.org/seminars/podcast}.
Support the foundation by becoming a member: \sphinxurl{https://longnow.org/join}.
%
\end{footnote}.
It consists of audio recordings about long\sphinxhyphen{}term thinking, and while the DataLad\sphinxhyphen{}101
course is not a long\sphinxhyphen{}term thinking seminar, those recordings are nevertheless a
good addition to the large stash of yet\sphinxhyphen{}to\sphinxhyphen{}read text books we piled up.
Let’s get this dataset into our existing \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset.

\sphinxAtStartPar
To keep the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset neat and organized, we first create a new directory,
called recordings.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} we are in the root of DataLad\PYGZhy{}101}
\PYG{g+gp}{\PYGZdl{} }mkdir\PYG{+w}{ }recordings
\end{sphinxVerbatim}

\sphinxAtStartPar
The command that can be used to obtain a dataset is \sphinxcode{\sphinxupquote{datalad clone}},
but we often refer to the process of cloning a Dataset as \sphinxstyleemphasis{installing}.
Let’s install the longnow podcasts in this new directory.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{datalad clone}} command takes a location of an existing dataset to clone. This \sphinxstyleemphasis{source}
can be a URL or a path to a local directory, or an SSH server%
\begin{footnote}[1]\sphinxAtStartFootnote
Additionally, a source can also be a pointer to an open\sphinxhyphen{}data collection,
for example {\hyperref[\detokenize{glossary:term-the-DataLad-superdataset}]{\sphinxtermref{\DUrole{xref,std,std-term}{the DataLad superdataset ///}}}} \textendash{} more on what this is and how to
use it later, though.
%
\end{footnote}. The dataset
to be installed lives on {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}, at
\sphinxhref{https://github.com/datalad-datasets/longnow-podcasts}{https://github.com/datalad\sphinxhyphen{}datasets/longnow\sphinxhyphen{}podcasts.git},
and we can give its GitHub URL as the  first positional argument.
Optionally, the command also takes as second positional argument a path to the \sphinxstyleemphasis{destination},
\textendash{} a path to where we want to install the dataset to. In this case it is \sphinxcode{\sphinxupquote{recordings/longnow}}.
Because we are installing a dataset (the podcasts) into an existing dataset (the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}
dataset), we also supply a \sphinxcode{\sphinxupquote{\sphinxhyphen{}d/\sphinxhyphen{}\sphinxhyphen{}dataset}} flag to the command.
This specifies the dataset to perform the operation on, and allows us to install
the podcasts as a \sphinxstyleemphasis{subdataset} of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}.
The \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-no-clone-dataset}} {\hyperref[\detokenize{basics/101-105-install:fom-no-clone-dataset}]{\sphinxcrossref{\DUrole{std,std-ref}{on not using this option}}}} (\autopageref*{\detokenize{basics/101-105-install:fom-no-clone-dataset}}) provides some more background.
Because we are in the root
of the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset, the pointer to the dataset is a \sphinxcode{\sphinxupquote{.}} (which is Unix’
way of saying “current directory”). In the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-clone-nonroot}} {\hyperref[\detokenize{basics/101-105-install:fom-clone-nonroot}]{\sphinxcrossref{\DUrole{std,std-ref}{on dataset option values}}}} (\autopageref*{\detokenize{basics/101-105-install:fom-clone-nonroot}})
you can learn about cloning at other locations than the dataset root.

\sphinxAtStartPar
As before with long commands, we line break the code with a \sphinxcode{\sphinxupquote{\textbackslash{}}}. You can
copy it as it is presented here into your terminal, but in your own work you
can write commands like this into a single line.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }clone\PYG{+w}{ }\PYGZhy{}\PYGZhy{}dataset\PYG{+w}{ }.\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{ }https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git\PYG{+w}{ }recordings/longnow
\PYG{g+go}{[INFO] Remote origin not usable by git\PYGZhy{}annex; setting annex\PYGZhy{}ignore}
\PYG{g+go}{install(ok): recordings/longnow (dataset)}
\PYG{g+go}{add(ok): recordings/longnow (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This command copied the repository found at the URL \sphinxurl{https://github.com/datalad-datasets/longnow-podcasts}
into the existing \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset, into the directory \sphinxcode{\sphinxupquote{recordings/longnow}}.
The optional destination is helpful: If we had not specified the path
\sphinxcode{\sphinxupquote{recordings/longnow}} as a destination for the dataset clone, the command would
have installed the dataset into the root of the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset, and instead
of \sphinxcode{\sphinxupquote{longnow}} it would have used the name of the remote repository “\sphinxcode{\sphinxupquote{longnow\sphinxhyphen{}podcasts}}”.
But the coolest feature of \sphinxcode{\sphinxupquote{datalad clone}} is yet invisible: This command
also recorded where this dataset came from, thus capturing its \sphinxstyleemphasis{origin} as
{\hyperref[\detokenize{glossary:term-provenance}]{\sphinxtermref{\DUrole{xref,std,std-term}{provenance}}}}. Even though this is not obvious at this point in time, later
chapters in this book will demonstrate how useful this information can be.

\index{clone@\spxentry{clone}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!clone@\spxentry{clone}}\ignorespaces \begin{gitusernote}[label={index-1}, before title={\thetcbcounter\ }, float, floatplacement=p, check odd page=true]{Clone internals}
\label{\detokenize{basics/101-105-install:index-1}}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{datalad clone}} command uses \sphinxcode{\sphinxupquote{git clone}}.
A dataset that is installed from an existing source, e.g., a path or URL,
is the DataLad equivalent of a \sphinxstyleemphasis{clone} in Git.


\end{gitusernote}

\index{clone into another dataset@\spxentry{clone into another dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!clone into another dataset@\spxentry{clone into another dataset}}\ignorespaces \begin{findoutmore}[label={fom-clone-nonroot}, before title={\thetcbcounter\ }, float, floatplacement=p, check odd page=true]{Do I have to install from the root of datasets?}
\label{\detokenize{basics/101-105-install:fom-clone-nonroot}}

\sphinxAtStartPar
No. Instead of from the \sphinxstyleemphasis{root} of the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset, you could have also
installed the dataset from within the \sphinxcode{\sphinxupquote{recordings}}, or \sphinxcode{\sphinxupquote{books}} directory.
In the case of installing datasets into existing datasets you however need
to adjust the paths that are given with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}d/\sphinxhyphen{}\sphinxhyphen{}dataset}} option:
\sphinxcode{\sphinxupquote{\sphinxhyphen{}d}} needs to specify the path to the root of the dataset. This is
important to keep in mind whenever you do not execute the \sphinxcode{\sphinxupquote{datalad clone}} command
from the root of this dataset. Luckily, there is a shortcut: \sphinxcode{\sphinxupquote{\sphinxhyphen{}d\textasciicircum{}}} will always
point to root of the top\sphinxhyphen{}most dataset. For example, if you navigate into \sphinxcode{\sphinxupquote{recordings}},
the command would be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }clone\PYG{+w}{ }\PYGZhy{}d\PYGZca{}\PYG{+w}{ }https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git\PYG{+w}{ }longnow
\end{sphinxVerbatim}


\end{findoutmore}
\begin{findoutmore}[label={fom-no-clone-dataset}, before title={\thetcbcounter\ }, float, floatplacement=p, check odd page=true]{What if I do not install into an existing dataset?}
\label{\detokenize{basics/101-105-install:fom-no-clone-dataset}}

\sphinxAtStartPar
If you do not install into an existing dataset, you only need to omit the \sphinxcode{\sphinxupquote{\sphinxhyphen{}d/\sphinxhyphen{}\sphinxhyphen{}dataset}}
option. You can try:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }clone\PYG{+w}{ }https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git
\end{sphinxVerbatim}

\sphinxAtStartPar
anywhere outside of your \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset to install the podcast dataset into a new directory
called \sphinxcode{\sphinxupquote{longnow\sphinxhyphen{}podcasts}}. You could even do this inside of an existing dataset.
However, whenever you install datasets into of other datasets, the \sphinxcode{\sphinxupquote{\sphinxhyphen{}d/\sphinxhyphen{}\sphinxhyphen{}dataset}}
option is necessary to not only install the dataset, but also \sphinxstyleemphasis{register} it
automatically into the higher level \sphinxstyleemphasis{superdataset}. The upcoming section will
elaborate on this.


\end{findoutmore}

\sphinxAtStartPar
This is how we can visualize the repository structure, but see the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-tree}} {\hyperref[\detokenize{basics/101-105-install:ww-tree}]{\sphinxcrossref{\DUrole{std,std-ref}{on tree}}}} (\autopageref*{\detokenize{basics/101-105-install:ww-tree}})
compatibility notes:

\index{tree@\spxentry{tree}!terminal command@\spxentry{terminal command}}\index{terminal command@\spxentry{terminal command}!tree@\spxentry{tree}}\index{display directory tree@\spxentry{display directory tree}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!display directory tree@\spxentry{display directory tree}}\ignorespaces \begin{windowswit}[label={ww-tree}, before title={\thetcbcounter\ }, float, floatplacement=p, check odd page=true]{use tree}
\label{\detokenize{basics/101-105-install:ww-tree}}

\sphinxAtStartPar
The Windows version of tree requires different parametrization, so please run \sphinxcode{\sphinxupquote{tree}} instead of \sphinxcode{\sphinxupquote{tree \sphinxhyphen{}d}}.


\end{windowswit}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }tree\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{   }\PYG{c+c1}{\PYGZsh{} we limit the output to directories}
\PYG{g+go}{.}
\PYG{g+go}{├── books}
\PYG{g+go}{└── recordings}
\PYG{g+go}{    └── longnow}
\PYG{g+go}{        ├── Long\PYGZus{}Now\PYGZus{}\PYGZus{}Conversations\PYGZus{}at\PYGZus{}The\PYGZus{}Interval}
\PYG{g+go}{        └── Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking}

\PYG{g+go}{5 directories}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can see that \sphinxcode{\sphinxupquote{recordings}} has one subdirectory, our newly installed \sphinxcode{\sphinxupquote{longnow}}
dataset with two subdirectories.
If we navigate into one of them and list its content, we’ll see many \sphinxcode{\sphinxupquote{.mp3}} files (here is an excerpt).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }recordings/longnow/Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking
\PYG{g+gp}{\PYGZdl{} }ls
\PYG{g+go}{2003\PYGZus{}11\PYGZus{}15\PYGZus{}\PYGZus{}Brian\PYGZus{}Eno\PYGZus{}\PYGZus{}The\PYGZus{}Long\PYGZus{}Now.mp3}
\PYG{g+go}{2003\PYGZus{}12\PYGZus{}13\PYGZus{}\PYGZus{}Peter\PYGZus{}Schwartz\PYGZus{}\PYGZus{}The\PYGZus{}Art\PYGZus{}Of\PYGZus{}The\PYGZus{}Really\PYGZus{}Long\PYGZus{}View.mp3}
\PYG{g+go}{2004\PYGZus{}01\PYGZus{}10\PYGZus{}\PYGZus{}George\PYGZus{}Dyson\PYGZus{}\PYGZus{}There\PYGZus{}s\PYGZus{}Plenty\PYGZus{}of\PYGZus{}Room\PYGZus{}at\PYGZus{}the\PYGZus{}Top\PYGZus{}\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking\PYGZus{}About\PYGZus{}Large\PYGZus{}scale\PYGZus{}Computing.mp3}
\PYG{g+go}{2004\PYGZus{}02\PYGZus{}14\PYGZus{}\PYGZus{}James\PYGZus{}Dewar\PYGZus{}\PYGZus{}Long\PYGZus{}term\PYGZus{}Policy\PYGZus{}Analysis.mp3}
\PYG{g+go}{2004\PYGZus{}03\PYGZus{}13\PYGZus{}\PYGZus{}Rusty\PYGZus{}Schweickart\PYGZus{}\PYGZus{}The\PYGZus{}Asteroid\PYGZus{}Threat\PYGZus{}Over\PYGZus{}the\PYGZus{}Next\PYGZus{}100\PYGZus{}000\PYGZus{}Years.mp3}
\PYG{g+go}{2004\PYGZus{}04\PYGZus{}10\PYGZus{}\PYGZus{}Daniel\PYGZus{}Janzen\PYGZus{}\PYGZus{}Third\PYGZus{}World\PYGZus{}Conservation\PYGZus{}\PYGZus{}It\PYGZus{}s\PYGZus{}ALL\PYGZus{}Gardening.mp3}
\PYG{g+go}{2004\PYGZus{}05\PYGZus{}15\PYGZus{}\PYGZus{}David\PYGZus{}Rumsey\PYGZus{}\PYGZus{}Mapping\PYGZus{}Time.mp3}
\PYG{g+go}{2004\PYGZus{}06\PYGZus{}12\PYGZus{}\PYGZus{}Bruce\PYGZus{}Sterling\PYGZus{}\PYGZus{}The\PYGZus{}Singularity\PYGZus{}\PYGZus{}Your\PYGZus{}Future\PYGZus{}as\PYGZus{}a\PYGZus{}Black\PYGZus{}Hole.mp3}
\PYG{g+go}{2004\PYGZus{}07\PYGZus{}10\PYGZus{}\PYGZus{}Jill\PYGZus{}Tarter\PYGZus{}\PYGZus{}The\PYGZus{}Search\PYGZus{}for\PYGZus{}Extra\PYGZus{}terrestrial\PYGZus{}Intelligence\PYGZus{}\PYGZus{}Necessarily\PYGZus{}a\PYGZus{}Long\PYGZus{}term\PYGZus{}Strategy.mp3}
\PYG{g+go}{2004\PYGZus{}08\PYGZus{}14\PYGZus{}\PYGZus{}Phillip\PYGZus{}Longman\PYGZus{}\PYGZus{}The\PYGZus{}Depopulation\PYGZus{}Problem.mp3}
\PYG{g+go}{2004\PYGZus{}09\PYGZus{}11\PYGZus{}\PYGZus{}Danny\PYGZus{}Hillis\PYGZus{}\PYGZus{}Progress\PYGZus{}on\PYGZus{}the\PYGZus{}10\PYGZus{}000\PYGZus{}year\PYGZus{}Clock.mp3}
\PYG{g+go}{2004\PYGZus{}10\PYGZus{}16\PYGZus{}\PYGZus{}Paul\PYGZus{}Hawken\PYGZus{}\PYGZus{}The\PYGZus{}Long\PYGZus{}Green.mp3}
\PYG{g+go}{2004\PYGZus{}11\PYGZus{}13\PYGZus{}\PYGZus{}Michael\PYGZus{}West\PYGZus{}\PYGZus{}The\PYGZus{}Prospects\PYGZus{}of\PYGZus{}Human\PYGZus{}Life\PYGZus{}Extension.mp3}
\end{sphinxVerbatim}


\subsection{Dataset content identity and availability information}
\label{\detokenize{basics/101-105-install:dataset-content-identity-and-availability-information}}
\sphinxAtStartPar
Surprised, you turn to your fellow student and wonder about
how fast the dataset was installed. Should
a download of that many \sphinxcode{\sphinxupquote{.mp3}} files not take much more time?

\sphinxAtStartPar
Here you can see another import feature of DataLad datasets
and the \sphinxcode{\sphinxupquote{datalad clone}} command:
Upon installation of a DataLad dataset, DataLad retrieves only small files
(for example, text files or markdown files) and (small) metadata
about the dataset. It does not, however, download any large files
(yet). The metadata exposes the dataset’s file hierarchy
for exploration (note how you are able to list the dataset contents with \sphinxcode{\sphinxupquote{ls}}),
and downloading only this metadata speeds up the installation of a DataLad dataset
of many TB in size to a few seconds. Just now, after installing, the dataset is
small in size:

\index{show file size@\spxentry{show file size}!in a terminal@\spxentry{in a terminal}}\index{in a terminal@\spxentry{in a terminal}!show file size@\spxentry{show file size}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-105-install:index-4}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../\PYG{+w}{      }\PYG{c+c1}{\PYGZsh{} in longnow/}
\PYG{g+gp}{\PYGZdl{} }du\PYG{+w}{ }\PYGZhy{}sh\PYG{+w}{      }\PYG{c+c1}{\PYGZsh{} Unix command to show size of contents}
\PYG{g+go}{3.7M	.}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is tiny indeed!

\sphinxAtStartPar
If you executed the previous \sphinxcode{\sphinxupquote{ls}} command in your own terminal, you might have seen
the \sphinxcode{\sphinxupquote{.mp3}} files highlighted in a different color than usually.
On your computer, try to open one of the \sphinxcode{\sphinxupquote{.mp3}} files.
You will notice that you cannot open any of the audio files.
This is not your fault: \sphinxstyleemphasis{None of these files exist on your computer yet}.

\sphinxAtStartPar
Wait, what?

\sphinxAtStartPar
This sounds strange, but it has many advantages. Apart from a fast installation,
it allows you to retrieve precisely the content you need, instead of all the contents
of a dataset. Thus, even if you install a dataset that is many TB in size,
it takes up only few MB of space after the install, and you can retrieve only those
components of the dataset that you need.

\sphinxAtStartPar
Let’s see how large the dataset would be in total if all of the files were present.
For this, we supply an additional option to \sphinxcode{\sphinxupquote{datalad status}}. Make sure to be
(somewhere) inside of the \sphinxcode{\sphinxupquote{longnow}} dataset to execute the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}\PYGZhy{}annex
\PYG{g+go}{236 annex\PYGZsq{}d files (15.4 GB recorded total size)}
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\sphinxAtStartPar
Woah! More than 200 files, totaling more than 15 GB?
You begin to appreciate that DataLad did not
download all of this data right away! That would have taken hours given the crappy
internet connection in the lecture hall, and you are not even sure whether your
hard drive has much space left…

\sphinxAtStartPar
But you nevertheless are curious on how to actually listen to one of these \sphinxcode{\sphinxupquote{.mp3}}s now.
So how does one actually “get” the files?

\index{get@\spxentry{get}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!get@\spxentry{get}}\ignorespaces 
\sphinxAtStartPar
The command to retrieve file content is \sphinxcode{\sphinxupquote{datalad get}}.
You can specify one or more specific files, or \sphinxcode{\sphinxupquote{get}} all of the dataset by
specifying \sphinxcode{\sphinxupquote{datalad get .}} at the root directory of the dataset (with \sphinxcode{\sphinxupquote{.}} denoting “current directory”).

\index{get file content@\spxentry{get file content}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!get file content@\spxentry{get file content}}\ignorespaces 
\sphinxAtStartPar
First, we get one of the recordings in the dataset \textendash{} take any one of your choice
(here, it’s the first).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2003\PYGZus{}11\PYGZus{}15\PYGZus{}\PYGZus{}Brian\PYGZus{}Eno\PYGZus{}\PYGZus{}The\PYGZus{}Long\PYGZus{}Now.mp3
\PYG{g+go}{get(ok): Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2003\PYGZus{}11\PYGZus{}15\PYGZus{}\PYGZus{}Brian\PYGZus{}Eno\PYGZus{}\PYGZus{}The\PYGZus{}Long\PYGZus{}Now.mp3 (file) [from web...]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Try to open it \textendash{} it will now work.

\sphinxAtStartPar
If you would want to get the rest of the missing data, instead of specifying all files individually,
we can use \sphinxcode{\sphinxupquote{.}} to refer to \sphinxstyleemphasis{all} of the dataset like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }.
\end{sphinxVerbatim}

\sphinxAtStartPar
However, with a total size of more than 15GB, this might take a while, so do not do that now.
If you did execute the command above, interrupt it by pressing \sphinxcode{\sphinxupquote{CTRL}} + \sphinxcode{\sphinxupquote{C}} \textendash{} Do not worry,
this will not break anything.

\index{show dataset size@\spxentry{show dataset size}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!show dataset size@\spxentry{show dataset size}}\ignorespaces 
\sphinxAtStartPar
Isn’t that easy?
Let’s see how much content is now present locally. For this, \sphinxcode{\sphinxupquote{datalad status \sphinxhyphen{}\sphinxhyphen{}annex all}}
has a nice summary:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}\PYGZhy{}annex\PYG{+w}{ }all
\PYG{g+go}{236 annex\PYGZsq{}d files (35.7 MB/15.4 GB present/total size)}
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\sphinxAtStartPar
This shows you how much of the total content is present locally. With one file,
it is only a fraction of the total size.

\sphinxAtStartPar
Let’s \sphinxcode{\sphinxupquote{get}} a few more recordings, just because it was so mesmerizing to watch
DataLad’s fancy progress bars.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2003\PYGZus{}11\PYGZus{}15\PYGZus{}\PYGZus{}Brian\PYGZus{}Eno\PYGZus{}\PYGZus{}The\PYGZus{}Long\PYGZus{}Now.mp3\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2003\PYGZus{}12\PYGZus{}13\PYGZus{}\PYGZus{}Peter\PYGZus{}Schwartz\PYGZus{}\PYGZus{}The\PYGZus{}Art\PYGZus{}Of\PYGZus{}The\PYGZus{}Really\PYGZus{}Long\PYGZus{}View.mp3\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2004\PYGZus{}01\PYGZus{}10\PYGZus{}\PYGZus{}George\PYGZus{}Dyson\PYGZus{}\PYGZus{}There\PYGZus{}s\PYGZus{}Plenty\PYGZus{}of\PYGZus{}Room\PYGZus{}at\PYGZus{}the\PYGZus{}Top\PYGZus{}\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking\PYGZus{}About\PYGZus{}Large\PYGZus{}scale\PYGZus{}Computing.mp3
\PYG{g+go}{get(ok): Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2004\PYGZus{}01\PYGZus{}10\PYGZus{}\PYGZus{}George\PYGZus{}Dyson\PYGZus{}\PYGZus{}There\PYGZus{}s\PYGZus{}Plenty\PYGZus{}of\PYGZus{}Room\PYGZus{}at\PYGZus{}the\PYGZus{}Top\PYGZus{}\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking\PYGZus{}About\PYGZus{}Large\PYGZus{}scale\PYGZus{}Computing.mp3 (file) [from web...]}
\PYG{g+go}{get(ok): Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2003\PYGZus{}12\PYGZus{}13\PYGZus{}\PYGZus{}Peter\PYGZus{}Schwartz\PYGZus{}\PYGZus{}The\PYGZus{}Art\PYGZus{}Of\PYGZus{}The\PYGZus{}Really\PYGZus{}Long\PYGZus{}View.mp3 (file) [from web...]}
\PYG{g+go}{action summary:}
\PYG{g+go}{  get (notneeded: 1, ok: 2)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that any data that is already retrieved (the first file) is not downloaded again.
DataLad summarizes the outcome of the execution of \sphinxcode{\sphinxupquote{get}} in the end and informs
that the download of one file was \sphinxcode{\sphinxupquote{notneeded}} and the retrieval of the other files was \sphinxcode{\sphinxupquote{ok}}.

\index{get@\spxentry{get}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!get@\spxentry{get}}\ignorespaces \begin{gitusernote}[label={index-8}, before title={\thetcbcounter\ }, check odd page=true]{Get internals}
\label{\detokenize{basics/101-105-install:index-8}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad get}} uses \sphinxcode{\sphinxupquote{git annex get}} underneath the hood.


\end{gitusernote}

\index{drop file content@\spxentry{drop file content}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!drop file content@\spxentry{drop file content}}\ignorespaces 

\subsection{Keep whatever you like}
\label{\detokenize{basics/101-105-install:keep-whatever-you-like}}\label{\detokenize{basics/101-105-install:index-9}}
\sphinxAtStartPar
“Oh shit, oh shit, oh shit…” you hear from right behind you. Your fellow student
apparently downloaded the \sphinxstyleemphasis{full} dataset accidentally. “Is there a way to get rid
of file contents in dataset, too?”, they ask. “Yes”, the lecturer responds,
“you can remove file contents by using \sphinxcode{\sphinxupquote{datalad drop}}. This is
really helpful to save disk space for data you can easily reobtain, for example”.

\index{drop@\spxentry{drop}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!drop@\spxentry{drop}}\ignorespaces 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{datalad drop}} command will remove
file contents completely from your dataset.
You should only use this command to remove contents that you can \sphinxcode{\sphinxupquote{datalad get}}
again, or generate again (for example, with next chapter’s \sphinxcode{\sphinxupquote{datalad datalad run}}
command), or that you really do not need anymore.

\sphinxAtStartPar
Let’s remove the content of one of the files that we have downloaded, and check
what this does to the total size of the dataset. Here is the current amount of
retrieved data in this dataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}\PYGZhy{}annex\PYG{+w}{ }all
\PYG{g+go}{236 annex\PYGZsq{}d files (135.1 MB/15.4 GB present/total size)}
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\sphinxAtStartPar
We drop a single recording’s content that we previously downloaded with
\sphinxcode{\sphinxupquote{datalad get}} …

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }drop\PYG{+w}{ }Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2004\PYGZus{}01\PYGZus{}10\PYGZus{}\PYGZus{}George\PYGZus{}Dyson\PYGZus{}\PYGZus{}There\PYGZus{}s\PYGZus{}Plenty\PYGZus{}of\PYGZus{}Room\PYGZus{}at\PYGZus{}the\PYGZus{}Top\PYGZus{}\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking\PYGZus{}About\PYGZus{}Large\PYGZus{}scale\PYGZus{}Computing.mp3
\PYG{g+go}{drop(ok): Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2004\PYGZus{}01\PYGZus{}10\PYGZus{}\PYGZus{}George\PYGZus{}Dyson\PYGZus{}\PYGZus{}There\PYGZus{}s\PYGZus{}Plenty\PYGZus{}of\PYGZus{}Room\PYGZus{}at\PYGZus{}the\PYGZus{}Top\PYGZus{}\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking\PYGZus{}About\PYGZus{}Large\PYGZus{}scale\PYGZus{}Computing.mp3 (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
… and check the size of the dataset again:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}\PYGZhy{}annex\PYG{+w}{ }all
\PYG{g+go}{236 annex\PYGZsq{}d files (93.5 MB/15.4 GB present/total size)}
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\sphinxAtStartPar
Dropping the file content of one \sphinxcode{\sphinxupquote{mp3}} file saved roughly 40MB of disk space.
Whenever you need the recording again, it is easy to re\sphinxhyphen{}retrieve it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2004\PYGZus{}01\PYGZus{}10\PYGZus{}\PYGZus{}George\PYGZus{}Dyson\PYGZus{}\PYGZus{}There\PYGZus{}s\PYGZus{}Plenty\PYGZus{}of\PYGZus{}Room\PYGZus{}at\PYGZus{}the\PYGZus{}Top\PYGZus{}\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking\PYGZus{}About\PYGZus{}Large\PYGZus{}scale\PYGZus{}Computing.mp3
\PYG{g+go}{get(ok): Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2004\PYGZus{}01\PYGZus{}10\PYGZus{}\PYGZus{}George\PYGZus{}Dyson\PYGZus{}\PYGZus{}There\PYGZus{}s\PYGZus{}Plenty\PYGZus{}of\PYGZus{}Room\PYGZus{}at\PYGZus{}the\PYGZus{}Top\PYGZus{}\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking\PYGZus{}About\PYGZus{}Large\PYGZus{}scale\PYGZus{}Computing.mp3 (file) [from web...]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Reobtained!

\sphinxAtStartPar
This was only a quick digression into \sphinxcode{\sphinxupquote{datalad drop}}. The main principles
of this command will become clear after chapter
{\hyperref[\detokenize{basics/basics-annex:chapter-gitannex}]{\sphinxcrossref{\DUrole{std,std-ref}{Under the hood: git\sphinxhyphen{}annex}}}} (\autopageref*{\detokenize{basics/basics-annex:chapter-gitannex}}), and its precise use is shown in the paragraph on
{\hyperref[\detokenize{basics/101-136-filesystem:remove}]{\sphinxcrossref{\DUrole{std,std-ref}{removing file contents}}}} (\autopageref*{\detokenize{basics/101-136-filesystem:remove}}).
At this point, however, you already know that datasets allow you do
\sphinxcode{\sphinxupquote{datalad drop}} file contents flexibly. If you want to, you could have more
podcasts (or other data) on your computer than you have disk space available
by using DataLad datasets \textendash{} and that really is a cool feature to have.


\subsection{Dataset archeology}
\label{\detokenize{basics/101-105-install:dataset-archeology}}
\sphinxAtStartPar
You have now experienced how easy it is to (re)obtain shared data with DataLad.
But beyond sharing only the \sphinxstyleemphasis{data} in the dataset, when sharing or installing
a DataLad dataset, all copies also include the dataset’s \sphinxstyleemphasis{history}.

\index{log@\spxentry{log}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!log@\spxentry{log}}\index{show history (reverse)@\spxentry{show history}\spxextra{reverse}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!show history (reverse)@\spxentry{show history}\spxextra{reverse}}\ignorespaces 
\sphinxAtStartPar
For example, we can find out who created the dataset in the first place
(the output shows an excerpt of \sphinxcode{\sphinxupquote{git log \sphinxhyphen{}\sphinxhyphen{}reverse}}, which displays the
history from first to most recent commit):

\fvset{hllines={, 3,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}reverse
\PYG{g+go}{commit 8df130bb✂SHA1}
\PYG{g+go}{Author: Michael Hanke \PYGZlt{}michael.hanke@gmail.com\PYGZgt{}}
\PYG{g+go}{Date:   Mon Jul 16 16:08:23 2018 +0200}

\PYG{g+go}{    [DATALAD] Set default backend for all files to be MD5E}

\PYG{g+go}{commit 3d0dc8f5✂SHA1}
\PYG{g+go}{Author: Michael Hanke \PYGZlt{}michael.hanke@gmail.com\PYGZgt{}}
\PYG{g+go}{Date:   Mon Jul 16 16:08:24 2018 +0200}

\PYG{g+go}{    [DATALAD] new dataset}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
But that’s not all. The seminar series is ongoing, and more recordings can get added
to the original repository shared on GitHub.
Because an installed dataset knows the dataset it was installed from,
your local dataset clone can be updated from its origin, and thus get the new recordings,
should there be some. Later in this book, we will see examples of this.

\index{update heredoc@\spxentry{update heredoc}!in a terminal@\spxentry{in a terminal}}\index{in a terminal@\spxentry{in a terminal}!update heredoc@\spxentry{update heredoc}}\index{save dataset modification@\spxentry{save dataset modification}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!save dataset modification@\spxentry{save dataset modification}}\ignorespaces 
\sphinxAtStartPar
Now you can not only create datasets and work with them locally, you can also consume
existing datasets by installing them. Because that’s cool, and because you will use this
command frequently, make a note of it into your \sphinxcode{\sphinxupquote{notes.txt}}, and \sphinxcode{\sphinxupquote{datalad save}} the
modification.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} in the root of DataLad\PYGZhy{}101:}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../../
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }notes.txt
\PYG{g+go}{The command \PYGZsq{}datalad clone URL/PATH [PATH]\PYGZsq{} installs a dataset from}
\PYG{g+go}{e.g., a URL or a path. If you install a dataset into an existing}
\PYG{g+go}{dataset (as a subdataset), remember to specify the root of the}
\PYG{g+go}{superdataset with the \PYGZsq{}\PYGZhy{}d\PYGZsq{} option.}

\PYG{g+go}{EOT}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Add note on datalad clone\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\index{placeholder files@\spxentry{placeholder files}!on Mac@\spxentry{on Mac}}\index{on Mac@\spxentry{on Mac}!placeholder files@\spxentry{placeholder files}}\ignorespaces \begin{importantnote}[label={index-13}, before title={\thetcbcounter\ }, check odd page=true]{Empty files can be confusing}
\label{\detokenize{basics/101-105-install:index-13}}

\sphinxAtStartPar
Listing files directly after the installation of a dataset will
work if done in a terminal with \sphinxcode{\sphinxupquote{ls}}.
However, certain file managers (such as OSX’s Finder%
\begin{footnote}[3]\sphinxAtStartFootnote
You can also upgrade your file manager to display file types in a
DataLad datasets (e.g., with the
\sphinxhref{https://github.com/andrewringler/git-annex-turtle}{git\sphinxhyphen{}annex\sphinxhyphen{}turtle extension}
for Finder)
%
\end{footnote}) may fail to
display files that are not yet present locally (i.e., before a
\sphinxcode{\sphinxupquote{datalad get}} was run). Therefore, be  mindful when exploring
a dataset hierarchy with a file manager \textendash{} it might not show you
the available but not yet retrieved files.
Consider browsing datasets with the {\hyperref[\detokenize{glossary:term-DataLad-Gooey}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad Gooey}}}} to be on the safe side.
More about why this is will be explained in section {\hyperref[\detokenize{basics/101-115-symlinks:symlink}]{\sphinxcrossref{\DUrole{std,std-ref}{Data integrity}}}} (\autopageref*{\detokenize{basics/101-115-symlinks:symlink}}).


\end{importantnote}

\sphinxstepscope

\index{dataset nesting@\spxentry{dataset nesting}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!dataset nesting@\spxentry{dataset nesting}}\ignorespaces 

\section{Dataset nesting}
\label{\detokenize{basics/101-106-nesting:dataset-nesting}}\label{\detokenize{basics/101-106-nesting:nesting}}\label{\detokenize{basics/101-106-nesting:index-0}}\label{\detokenize{basics/101-106-nesting::doc}}
\sphinxAtStartPar
Without noticing, the previous section demonstrated another core principle
and feature of DataLad datasets: \sphinxstyleemphasis{Nesting}.

\sphinxAtStartPar
Within DataLad datasets one can \sphinxstyleemphasis{nest} other DataLad
datasets arbitrarily deep. We for example just installed one dataset, the
\sphinxcode{\sphinxupquote{longnow}} podcasts, \sphinxstyleemphasis{into} another dataset, the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset.
This was done by supplying the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dataset}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}d}} flag in the command call.

\sphinxAtStartPar
At first glance, nesting does not seem particularly spectacular \textendash{}
after all, any directory on a file system can have other directories inside of it.
The possibility for nested Datasets, however, is one of many advantages
DataLad datasets have:

\sphinxAtStartPar
One aspect of nested datasets is that any DataLad dataset
(\sphinxstyleemphasis{subdataset} or \sphinxstyleemphasis{superdataset}) keeps their stand\sphinxhyphen{}alone
history. The top\sphinxhyphen{}level DataLad dataset (the \sphinxstyleemphasis{superdataset}) only stores
\sphinxstyleemphasis{which version} of the subdataset is currently used through an identifier.

\sphinxAtStartPar
Let’s dive into that.
Remember how we had to navigate into \sphinxcode{\sphinxupquote{recordings/longnow}} to see the history,
and how this history was completely independent of the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}
superdataset history? This was the subdataset’s own history.

\sphinxAtStartPar
Apart from stand\sphinxhyphen{}alone histories of super\sphinxhyphen{} or subdatasets, this highlights another
very important advantage that nesting provides: Note that the \sphinxcode{\sphinxupquote{longnow}} dataset
is a completely independent, standalone dataset that was once created and
published. Nesting allows for a modular reuse of any other DataLad dataset,
and this reuse is possible and simple precisely because all of the information
is kept within a (sub)dataset.

\sphinxAtStartPar
But now let’s also check out how the \sphinxstyleemphasis{superdataset’s} (\sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}) history
looks like after the addition of a subdataset. To do this, make sure you are
\sphinxstyleemphasis{outside} of the subdataset \sphinxcode{\sphinxupquote{longnow}}. Note that the first commit is our recent
addition to \sphinxcode{\sphinxupquote{notes.txt}}, so we’ll look at the second most recent commit in
this excerpt.

\index{show commit patches@\spxentry{show commit patches}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!show commit patches@\spxentry{show commit patches}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-106-nesting:index-1}}}
\fvset{hllines={, 25,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}p\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{3}
\PYG{g+go}{commit 3c016f73✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    [DATALAD] Added subdataset}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/.gitmodules b/.gitmodules}
\PYG{g+go}{new file mode 100644}
\PYG{g+go}{index 0000000..9bc9ee9}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/.gitmodules}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1,5 @@}
\PYG{g+go}{+[submodule \PYGZdq{}recordings/longnow\PYGZdq{}]}
\PYG{g+go}{+	path = recordings/longnow}
\PYG{g+go}{+	url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\PYG{g+go}{+	datalad\PYGZhy{}id = b3ca2718\PYGZhy{}8901\PYGZhy{}11e8\PYGZhy{}99aa\PYGZhy{}a0369f7c647e}
\PYG{g+go}{+	datalad\PYGZhy{}url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/recordings/longnow b/recordings/longnow}
\PYG{g+go}{new file mode 160000}
\PYG{g+go}{index 0000000..dcc34fb}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/recordings/longnow}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1 @@}
\PYG{g+go}{+Subproject commit dcc34fbe✂SHA1}

\PYG{g+go}{commit e310b465✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    add note on datalad save}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/notes.txt b/notes.txt}
\PYG{g+go}{index 3a7a1fe..0142412 100644}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} a/notes.txt}
\PYG{g+go}{+++ b/notes.txt}
\PYG{g+go}{@@ \PYGZhy{}1,3 +1,7 @@}
\PYG{g+go}{ One can create a new dataset with \PYGZsq{}datalad create [\PYGZhy{}\PYGZhy{}description] PATH\PYGZsq{}.}
\PYG{g+go}{ The dataset is created empty}

\PYG{g+go}{+The command \PYGZdq{}datalad save [\PYGZhy{}m] PATH\PYGZdq{} saves the file (modifications) to}
\PYG{g+go}{+history.}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
We have highlighted the important part of this rather long commit summary.
Note that you cannot see any \sphinxcode{\sphinxupquote{.mp3}}s being added to the dataset,
as was previously the case when we \sphinxcode{\sphinxupquote{datalad save}}d PDFs that we
downloaded into \sphinxcode{\sphinxupquote{books/}}. Instead,
DataLad stores what it calls a \sphinxstyleemphasis{subproject commit} of the subdataset.
The cryptic character sequence in this line is the {\hyperref[\detokenize{glossary:term-shasum}]{\sphinxtermref{\DUrole{xref,std,std-term}{shasum}}}} we have briefly
mentioned before, and it is the identifier that
DataLad internally used to identify the files and the changes to the files in the subdataset. Exactly this
{\hyperref[\detokenize{glossary:term-shasum}]{\sphinxtermref{\DUrole{xref,std,std-term}{shasum}}}} is what identifies the state of the subdataset.

\sphinxAtStartPar
Navigate back into \sphinxcode{\sphinxupquote{longnow}} and try to find the highlighted shasum in the
subdataset’s history:

\fvset{hllines={, 3,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }recordings/longnow
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{dcc34fb Update aggregated metadata}
\PYG{g+go}{36a30a1 [DATALAD RUNCMD] Update from feed}
\PYG{g+go}{bafdc04 Uniformize JSON\PYGZhy{}LD context with DataLad\PYGZsq{}s internal extractors}
\PYG{g+go}{004e484 [DATALAD RUNCMD] .datalad/maint/make\PYGZus{}readme.py}
\PYG{g+go}{7ee3ded Sort episodes newest\PYGZhy{}first}
\PYG{g+go}{e829615 Link to the handbook as a source of wisdom}
\PYG{g+go}{4b37790 Fix README generator to parse correct directory}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
We can see that it is the most recent commit shasum of the subdataset
(albeit we can see only the first seven characters here \textendash{} a \sphinxcode{\sphinxupquote{git log}}
would show you the full shasum). Thus, your dataset does not only know the origin
of its subdataset, but also which version of the subdataset to use,
i.e., it has the identifier of the stage/version in the subdataset’s evolution to be used.
This is what is meant by “the top\sphinxhyphen{}level DataLad dataset (the \sphinxstyleemphasis{superdataset}) only stores
\sphinxstyleemphasis{which version} of the subdataset is currently used through an identifier”.

\sphinxAtStartPar
Importantly, once we learn how to make use of the history of a dataset,
we can set subdatasets to previous states, or \sphinxstyleemphasis{update} them.

\sphinxAtStartPar
By the way, there is actually no need to navigate into different directories all the time.
Check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-tmp-cwd}} {\hyperref[\detokenize{basics/101-106-nesting:fom-tmp-cwd}]{\sphinxcrossref{\DUrole{std,std-ref}{on switching the working directory with Git}}}} (\autopageref*{\detokenize{basics/101-106-nesting:fom-tmp-cwd}}) for
an alternative.

\index{temporary working directory change@\spxentry{temporary working directory change}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!temporary working directory change@\spxentry{temporary working directory change}}\ignorespaces \begin{findoutmore}[label={fom-tmp-cwd}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Do I have to navigate into the subdataset to see it’s history?}
\label{\detokenize{basics/101-106-nesting:fom-tmp-cwd}}

\sphinxAtStartPar
Previously, we used \sphinxcode{\sphinxupquote{ cd}} to navigate into the subdataset, and
subsequently opened the Git log. This is necessary, because a \sphinxcode{\sphinxupquote{git log}}
in the superdataset would only return the superdatasets history.
While moving around with \sphinxcode{\sphinxupquote{cd}} is straightforward, you also found it
slightly annoying from time to time to use the \sphinxcode{\sphinxupquote{cd}} command so often and also
to remember in which directory you currently are in. There is one
trick, though: \sphinxcode{\sphinxupquote{git \sphinxhyphen{}C}} and \sphinxcode{\sphinxupquote{datalad \sphinxhyphen{}C}} (note that it is a capital C) let you perform any
Git or DataLad command in a provided path. Providing this option together with a path to
a Git or DataLad command let’s you run the command as if it was started in this path
instead of the current working directory.
Thus, from the root of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}, this command would have given you the
subdataset’s history as well:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }\PYGZhy{}C\PYG{+w}{ }recordings/longnow\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\end{sphinxVerbatim}


\end{findoutmore}

\sphinxAtStartPar
In the upcoming sections, we’ll experience the perks of dataset nesting
frequently, and everything that might seem vague at this point will become
clearer. To conclude this demonstration,
\hyperref[\detokenize{basics/101-106-nesting:fignesting}]{Fig.\@ \ref{\detokenize{basics/101-106-nesting:fignesting}}} illustrates the current state of our dataset, \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}, with its nested subdataset.
Thus, without being consciously aware of it, by taking advantage of dataset
nesting, we took a dataset \sphinxcode{\sphinxupquote{longnow}} and installed it as a
subdataset within the superdataset  \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}.

\begin{figure}[tbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{virtual_dstree_dl101}.pdf}
\caption{Virtual directory tree of a nested DataLad dataset}\label{\detokenize{basics/101-106-nesting:id1}}\label{\detokenize{basics/101-106-nesting:fignesting}}\end{figure}

\sphinxAtStartPar
If you have executed the above code snippets, make sure to go back into the
root of the dataset again:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../../
\end{sphinxVerbatim}

\sphinxstepscope


\section{Summary}
\label{\detokenize{basics/101-107-summary:summary}}\label{\detokenize{basics/101-107-summary::doc}}
\sphinxAtStartPar
In the last few sections, we have discovered the basics of starting a DataLad dataset from scratch,
and making simple modifications \sphinxstyleemphasis{locally}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
An empty dataset can be created with the \sphinxcode{\sphinxupquote{datalad create}} command. It’s useful to add a description
to the dataset and use the \sphinxcode{\sphinxupquote{\sphinxhyphen{}c text2git}} configuration, but we will see later why.
This is the command structure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}\PYGZhy{}description\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}here is a description\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }text2git\PYG{+w}{ }PATH
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Thanks to {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} and {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}, the dataset has a history to track files and their
modifications. Built\sphinxhyphen{}in Git tools (\sphinxcode{\sphinxupquote{git log}}) or external tools (such as \sphinxcode{\sphinxupquote{tig}}) allow to explore
the history.

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{datalad save}} command records the current state of the dataset to the history. Make it a habit
to specify a concise commit message to summarize the change. If several unrelated modifications
exist in your dataset, specify the path to the precise file (change) that should be saved to history.
Remember, if you run a \sphinxcode{\sphinxupquote{datalad save}} without
specifying a path, all untracked files and all file changes will be committed to the history together!
This is the command structure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}here is a commit message\PYGZdq{}}\PYG{+w}{ }\PYG{o}{[}PATH\PYG{o}{]}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
The typical local workflow is simple: \sphinxstyleemphasis{Modify} the dataset by adding or
modifying files, \sphinxstyleemphasis{save} the changes as meaningful units to the history,
\sphinxstyleemphasis{repeat} (see \hyperref[\detokenize{basics/101-107-summary:fig-simple-workflow}]{Fig.\@ \ref{\detokenize{basics/101-107-summary:fig-simple-workflow}}}).

\end{itemize}

\begin{figure}[tbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{local_wf_simple}.png}
\caption{A simple, local version control workflow with DataLad.}\label{\detokenize{basics/101-107-summary:id1}}\label{\detokenize{basics/101-107-summary:fig-simple-workflow}}\end{figure}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad status}} reports the current state of the dataset. It’s a very helpful command you should
run frequently to check for untracked or modified content.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}} can retrieve files from websources and save them
automatically to your dataset. This does not only save you the time of one
\sphinxcode{\sphinxupquote{datalad save}}, but it also records the source of the file as hidden
{\hyperref[\detokenize{glossary:term-provenance}]{\sphinxtermref{\DUrole{xref,std,std-term}{provenance}}}} information.

\end{itemize}

\sphinxAtStartPar
Furthermore, we have discovered the basics of installing a published DataLad dataset,
and experienced the concept of modular nesting datasets.

\index{clone@\spxentry{clone}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!clone@\spxentry{clone}}\ignorespaces \begin{itemize}
\item {} 
\sphinxAtStartPar
A published dataset can be installed with the \sphinxcode{\sphinxupquote{datalad clone}} command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }clone\PYG{+w}{ }\PYG{o}{[}\PYGZhy{}\PYGZhy{}dataset\PYG{+w}{ }PATH\PYG{o}{]}\PYG{+w}{ }SOURCE\PYGZhy{}PATH/URL\PYG{+w}{ }\PYG{o}{[}DESTINATION\PYG{+w}{ }PATH\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
It can be installed “on its own”, or within an existing dataset.

\item {} 
\sphinxAtStartPar
The command takes a location of an existing dataset as a positional argument,
and optionally a path to where you want the dataset to be installed. If you do not specify a path,
the dataset will be installed into the current directory, with the original name of the
dataset.

\item {} 
\sphinxAtStartPar
If a dataset is installed inside of another dataset as a subdataset, the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dataset}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}d}} option needs to specify the root of the containing dataset, the superdataset.

\item {} 
\sphinxAtStartPar
The source can be a URL, for example of a GitHub repository as in section {\hyperref[\detokenize{basics/101-105-install:installds}]{\sphinxcrossref{\DUrole{std,std-ref}{Install datasets}}}} (\autopageref*{\detokenize{basics/101-105-install:installds}}), but also
paths, or open data collections.

\item {} 
\sphinxAtStartPar
After \sphinxcode{\sphinxupquote{datalad clone}}, only small files and metadata about file availability are present locally.
To retrieve actual file content of larger files, \sphinxcode{\sphinxupquote{datalad get PATH}} downloads large file
content on demand.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad status \sphinxhyphen{}\sphinxhyphen{}annex}} or \sphinxcode{\sphinxupquote{datalad status \sphinxhyphen{}\sphinxhyphen{}annex all}} are helpful to determine
total repository size and the amount of data that is present locally.

\item {} 
\sphinxAtStartPar
Remember: Super\sphinxhyphen{} and subdatasets have standalone histories. A superdataset stores the currently used
version of a contained subdataset through an identifier.

\end{itemize}


\subsection{Now what can I do with that?}
\label{\detokenize{basics/101-107-summary:now-what-can-i-do-with-that}}
\sphinxAtStartPar
Simple, local workflows allow you to version control changing small files,
for example, your CV, your code, or a book that you are working on, but
you can also add very large files to your datasets history.
Currently, this can be considered “best\sphinxhyphen{}practice building”: Frequent \sphinxcode{\sphinxupquote{datalad status}}
commands, \sphinxcode{\sphinxupquote{datalad save}} commands to save dataset modifications,
and concise {\hyperref[\detokenize{glossary:term-commit-message}]{\sphinxtermref{\DUrole{xref,std,std-term}{commit message}}}}s are the main take always from this. You can already explore
the history of a dataset and you know about many types of provenance information
captured by DataLad, but for now, its been only informative, and has not been used
for anything more fancy. Later on, we will look into utilizing the history
in order to undo mistakes, how the origin of files or datasets becomes helpful
when sharing datasets or removing file contents, and how to make changes to large
content (as opposed to small content we have been modifying so far).

\sphinxAtStartPar
Additionally, you learned the basics on extending the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset and consuming
existing datasets:
You have procedurally experienced how to install a dataset, and simultaneously you have
learned a lot about the principles and features of DataLad datasets.
Cloning datasets and getting their content allows you to consume published datasets.
By nesting datasets within each other, you can reuse datasets in a modular fashion. While this may
appear abstract, upcoming sections will demonstrate many examples of why this can be handy.

\sphinxstepscope


\chapter{DataLad, run!}
\label{\detokenize{basics/basics-run:datalad-run}}\label{\detokenize{basics/basics-run:chapter-run}}\label{\detokenize{basics/basics-run:id1}}\label{\detokenize{basics/basics-run::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{keeptrack}.pdf}\hspace*{\fill}}

\sphinxstepscope

\index{provenance tracking@\spxentry{provenance tracking}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!provenance tracking@\spxentry{provenance tracking}}\ignorespaces 

\section{Keeping track}
\label{\detokenize{basics/101-108-run:keeping-track}}\label{\detokenize{basics/101-108-run:run}}\label{\detokenize{basics/101-108-run:index-0}}\label{\detokenize{basics/101-108-run::doc}}
\sphinxAtStartPar
In previous examples, with the exception of \sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}}, all
changes that happened to the dataset or the files it contains were
saved to the dataset’s history by hand. We added larger and smaller
files and saved them, and we also modified smaller file contents and
saved these modifications.

\sphinxAtStartPar
Often, however, files get changed by shell commands
or by scripts.
Consider a data scientist.
She has data files with numeric data,
and code scripts in Python, R, Matlab or any other programming language
that will use the data to compute results or figures. Such output is
stored in new files, or modifies existing files.

\sphinxAtStartPar
But only a few weeks after these scripts were executed she finds it hard
to remember which script was modified for which reason or created which
output. How did this result came to be? Which script would she need
to run again on which data to produce this particular figure?

\sphinxAtStartPar
In this section we will experience how DataLad can help
to record the changes in a dataset after executing a script
from the shell. Just as \sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}} was able to associate
a file with its origin and store this information, we want to be
able to associate a particular file with the commands, scripts, and inputs
it was produced from, and thus capture and store full {\hyperref[\detokenize{glossary:term-provenance}]{\sphinxtermref{\DUrole{xref,std,std-term}{provenance}}}}.

\sphinxAtStartPar
Let’s say, for example, that you enjoyed the longnow podcasts a lot,
and you start a podcast\sphinxhyphen{}night with friends to wind down from all of
the exciting DataLad lectures. They propose to make a
list of speakers and titles to cross out what they’ve already listened
to, and ask you to prepare such a list.

\sphinxAtStartPar
“Mhh… probably there is a DataLad way to do this… wasn’t there also
a note about metadata extraction at some point?” But as we are not that
far into the lectures, you decide to write a short shell script
to generate a text file that lists speaker and title
name instead.

\sphinxAtStartPar
To do this, we are following a best practice that will reappear in the
later section on {\hyperref[\detokenize{basics/101-127-yoda:yoda}]{\sphinxcrossref{\DUrole{std,std-ref}{YODA principles}}}} (\autopageref*{\detokenize{basics/101-127-yoda:yoda}}): Collecting all
additional scripts that work with content of a subdataset \sphinxstyleemphasis{outside}
of this subdataset, in a dedicated \sphinxcode{\sphinxupquote{code/}} directory,
and collating the output of the execution of these scripts
\sphinxstyleemphasis{outside} of the subdataset as well \textendash{} and
therefore not modifying the subdataset.

\sphinxAtStartPar
The motivation behind this will become clear in later sections,
but for now we’ll start with best\sphinxhyphen{}practice building.
Therefore, create a subdirectory \sphinxcode{\sphinxupquote{code/}} in the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}
superdataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mkdir\PYG{+w}{ }code
\PYG{g+gp}{\PYGZdl{} }tree\PYG{+w}{ }\PYGZhy{}d
\PYG{g+go}{.}
\PYG{g+go}{├── books}
\PYG{g+go}{├── code}
\PYG{g+go}{└── recordings}
\PYG{g+go}{    └── longnow}
\PYG{g+go}{        ├── Long\PYGZus{}Now\PYGZus{}\PYGZus{}Conversations\PYGZus{}at\PYGZus{}The\PYGZus{}Interval}
\PYG{g+go}{        └── Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking}

\PYG{g+go}{6 directories}
\end{sphinxVerbatim}

\sphinxAtStartPar
Inside of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101/code}}, create a simple shell script \sphinxcode{\sphinxupquote{list\_titles.sh}}.
This script will carry out a simple task:
It will loop through the file names of the \sphinxcode{\sphinxupquote{.mp3}} files and
write out speaker names and talk titles in a very basic fashion.
The \sphinxcode{\sphinxupquote{cat}} command will write the script content into \sphinxcode{\sphinxupquote{code/list\_titles.sh}}.
Make sure to see the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-heredoc-alt}} {\hyperref[\detokenize{basics/101-108-run:ww-heredoc-alt}]{\sphinxcrossref{\DUrole{std,std-ref}{on an alternative}}}} (\autopageref*{\detokenize{basics/101-108-run:ww-heredoc-alt}}), and check
the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-filename-extensions}} {\hyperref[\detokenize{basics/101-108-run:ww-filename-extensions}]{\sphinxcrossref{\DUrole{std,std-ref}{on automatic file name extensions}}}} (\autopageref*{\detokenize{basics/101-108-run:ww-filename-extensions}})
to avoid confusion when creating files manually.
\begin{windowswit}[label={ww-heredoc-alt}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Here’s a script for Windows users}
\label{\detokenize{basics/101-108-run:ww-heredoc-alt}}

\sphinxAtStartPar
Please use an editor of your choice to create a file \sphinxcode{\sphinxupquote{list\_titles.sh}} inside of the \sphinxcode{\sphinxupquote{code}} directory.
These should be the contents:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }i\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }recordings/longnow/Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars*/*.mp3\PYG{p}{;}\PYG{+w}{ }\PYG{k}{do}
\PYG{+w}{   }\PYG{c+c1}{\PYGZsh{} get the filename}
\PYG{+w}{   }\PYG{n+nv}{base}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}basename\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{k}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{c+c1}{\PYGZsh{} strip the extension}
\PYG{+w}{   }\PYG{n+nv}{base}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{base}\PYG{p}{\PYGZpc{}.mp3}\PYG{l+s+si}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{c+c1}{\PYGZsh{} date as yyyy\PYGZhy{}mm\PYGZhy{}dd}
\PYG{+w}{   }\PYG{n+nb}{printf}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{base}\PYG{p}{\PYGZpc{}\PYGZpc{}\PYGZus{}\PYGZus{}*}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZbs{}t}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }tr\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZsq{}}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{c+c1}{\PYGZsh{} name and title without underscores}
\PYG{+w}{   }\PYG{n+nb}{printf}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{base}\PYG{p}{\PYGZsh{}*\PYGZus{}\PYGZus{}}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }tr\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZsq{}}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{p}{;}
\PYG{k}{done}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that this is not identical to the script in the text \textendash{} it lacks a few \sphinxcode{\sphinxupquote{\textbackslash{}}} characters, which is a meaningful difference.


\end{windowswit}

\index{hidden file name extensions@\spxentry{hidden file name extensions}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!hidden file name extensions@\spxentry{hidden file name extensions}}\ignorespaces \begin{windowswit}[label={ww-filename-extensions}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Be mindful of hidden extensions when creating files!}
\label{\detokenize{basics/101-108-run:ww-filename-extensions}}

\sphinxAtStartPar
By default, Windows does not show common file extensions when you view directory contents with a file explorer.
Instead, it only displays the base of the file name and indicates the file type with the display icon.
You can see if this is the case for you, too, by opening the \sphinxcode{\sphinxupquote{books\textbackslash{}}} directory in a file explorer, and checking if the file extension (\sphinxcode{\sphinxupquote{.pdf}}) is a part of the file name displayed underneath its PDF icon.

\sphinxAtStartPar
Hidden file extensions can be a confusing source of errors, because some Windows editors (for example, Notepad) automatically add a \sphinxcode{\sphinxupquote{.txt}} extension to your files \textendash{} when you save the script above under the name \sphinxcode{\sphinxupquote{list\_titles.sh}}, your editor may add an extension (\sphinxcode{\sphinxupquote{list\_titles.sh.txt}}), and the file explorer displays your file as \sphinxcode{\sphinxupquote{list\_titles.sh}} (hiding the \sphinxcode{\sphinxupquote{.txt}} extension).

\sphinxAtStartPar
To prevent confusion, configure the file explorer to always show you the file extension.
For this, open the Explorer, click on the “View” tab, and tick the box “File name extensions”.

\sphinxAtStartPar
Beyond this, double check the correct naming of your file, ideally in the terminal.


\end{windowswit}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYG{+w}{ }code/list\PYGZus{}titles.sh
\PYG{g+go}{for i in recordings/longnow/Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars*/*.mp3; do}
\PYG{g+gp}{   \PYGZsh{} }get\PYG{+w}{ }the\PYG{+w}{ }filename
\PYG{g+go}{   base=\PYGZbs{}\PYGZdl{}(basename \PYGZdq{}\PYGZbs{}\PYGZdl{}i\PYGZdq{});}
\PYG{g+gp}{   \PYGZsh{} }strip\PYG{+w}{ }the\PYG{+w}{ }extension
\PYG{g+go}{   base=\PYGZbs{}\PYGZdl{}\PYGZob{}base\PYGZpc{}.mp3\PYGZcb{};}
\PYG{g+gp}{   \PYGZsh{} }date\PYG{+w}{ }as\PYG{+w}{ }yyyy\PYGZhy{}mm\PYGZhy{}dd
\PYG{g+go}{   printf \PYGZdq{}\PYGZbs{}\PYGZdl{}\PYGZob{}base\PYGZpc{}\PYGZpc{}\PYGZus{}\PYGZus{}*\PYGZcb{}\PYGZbs{}t\PYGZdq{} | tr \PYGZsq{}\PYGZus{}\PYGZsq{} \PYGZsq{}\PYGZhy{}\PYGZsq{};}
\PYG{g+gp}{   \PYGZsh{} }name\PYG{+w}{ }and\PYG{+w}{ }title\PYG{+w}{ }without\PYG{+w}{ }underscores
\PYG{g+go}{   printf \PYGZdq{}\PYGZbs{}\PYGZdl{}\PYGZob{}base\PYGZsh{}*\PYGZus{}\PYGZus{}\PYGZcb{}\PYGZbs{}n\PYGZdq{} | tr \PYGZsq{}\PYGZus{}\PYGZsq{} \PYGZsq{} \PYGZsq{};}
\PYG{g+go}{done}
\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\sphinxAtStartPar
Save this script to the dataset.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: code (directory)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Add short script to write a list of podcast speakers and titles\PYGZdq{}}
\PYG{g+go}{add(ok): code/list\PYGZus{}titles.sh (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Once we run this script, it will simply print dates, names and titles to
your terminal. We can save its outputs to a new file
\sphinxcode{\sphinxupquote{recordings/podcasts.tsv}} in the superdataset by redirecting these
outputs with \sphinxcode{\sphinxupquote{bash code/list\_titles.sh \textgreater{} recordings/podcasts.tsv}}.

\sphinxAtStartPar
Obviously, we could create this file, and subsequently save it to the superdataset.
However, just as in the example about the data scientist,
in a bit of time, we will forget how this file came into existence, or
that the script \sphinxcode{\sphinxupquote{code/list\_titles.sh}} is associated with this file, and
can be used to update it later on.

\index{run@\spxentry{run}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!run@\spxentry{run}}\index{run command with provenance capture@\spxentry{run command with provenance capture}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!run command with provenance capture@\spxentry{run command with provenance capture}}\index{run command with provenance capture@\spxentry{run command with provenance capture}!with DataLad run@\spxentry{with DataLad run}}\index{with DataLad run@\spxentry{with DataLad run}!run command with provenance capture@\spxentry{run command with provenance capture}}\ignorespaces 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{datalad run}} command
can help with this. Put simply, it records a command’s impact on a dataset. Put
more technically, it will record a shell command, and \sphinxcode{\sphinxupquote{datalad save}} all changes
this command triggered in the dataset \textendash{} be that new files or changes to existing
files.

\sphinxAtStartPar
Let’s try the simplest way to use this command: \sphinxcode{\sphinxupquote{datalad run}},
followed by a commit message (\sphinxcode{\sphinxupquote{\sphinxhyphen{}m "a concise summary"}}), and the
command that executes the script from the shell: \sphinxcode{\sphinxupquote{bash code/list\_titles.sh \textgreater{} recordings/podcasts.tsv}}.
It is helpful to enclose the command in quotation marks.

\sphinxAtStartPar
Note that we execute the command from the root of the superdataset.
It is recommended to use \sphinxcode{\sphinxupquote{datalad run}} in the root of the dataset
you want to record the changes in, so make sure to run this
command from the root of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}create a list of podcast titles\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYG{l+s+s2}{\PYGZdq{}bash code/list\PYGZus{}titles.sh \PYGZgt{} recordings/podcasts.tsv\PYGZdq{}}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{run(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 (dataset) [bash code/list\PYGZus{}titles.sh \PYGZgt{} recordings/po...]}
\PYG{g+go}{add(ok): recordings/podcasts.tsv (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s take a look into the history:

\fvset{hllines={, 6, 11, 25,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}p\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{   }\PYG{c+c1}{\PYGZsh{} On Windows, you may just want to type \PYGZdq{}git log\PYGZdq{}.}
\PYG{g+go}{commit e37c9fc9✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    [DATALAD RUNCMD] create a list of podcast titles}

\PYG{g+go}{    === Do not change lines below ===}
\PYG{g+go}{    \PYGZob{}}
\PYG{g+go}{     \PYGZdq{}chain\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}cmd\PYGZdq{}: \PYGZdq{}bash code/list\PYGZus{}titles.sh \PYGZgt{} recordings/podcasts.tsv\PYGZdq{},}
\PYG{g+go}{     \PYGZdq{}dsid\PYGZdq{}: \PYGZdq{}e3e70682\PYGZhy{}c209\PYGZhy{}4cac\PYGZhy{}629f\PYGZhy{}6fbed82c07cd\PYGZdq{},}
\PYG{g+go}{     \PYGZdq{}exit\PYGZdq{}: 0,}
\PYG{g+go}{     \PYGZdq{}extra\PYGZus{}inputs\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}inputs\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}outputs\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}pwd\PYGZdq{}: \PYGZdq{}.\PYGZdq{}}
\PYG{g+go}{    \PYGZcb{}}
\PYG{g+go}{    \PYGZca{}\PYGZca{}\PYGZca{} Do not change lines above \PYGZca{}\PYGZca{}\PYGZca{}}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/recordings/podcasts.tsv b/recordings/podcasts.tsv}
\PYG{g+go}{new file mode 100644}
\PYG{g+go}{index 0000000..f691b53}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/recordings/podcasts.tsv}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1,206 @@}
\PYG{g+go}{+2003\PYGZhy{}11\PYGZhy{}15	Brian Eno  The Long Now}
\PYG{g+go}{+2003\PYGZhy{}12\PYGZhy{}13	Peter Schwartz  The Art Of The Really Long View}
\PYG{g+go}{+2004\PYGZhy{}01\PYGZhy{}10	George Dyson  There s Plenty of Room at the Top  Long term Thinking About Large scale Computing}
\PYG{g+go}{+2004\PYGZhy{}02\PYGZhy{}14	James Dewar  Long term Policy Analysis}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
The commit message we have supplied with \sphinxcode{\sphinxupquote{\sphinxhyphen{}m}} directly after \sphinxcode{\sphinxupquote{datalad run}} appears
in our history as a short summary.
Additionally, the output of the command, \sphinxcode{\sphinxupquote{recordings/podcasts.tsv}},
was saved right away.

\sphinxAtStartPar
But there is more in this log entry, a section in between the markers

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{=== Do not change lines below ===}} and

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textasciicircum{}\textasciicircum{}\textasciicircum{} Do not change lines above \textasciicircum{}\textasciicircum{}\textasciicircum{}}}.

\sphinxAtStartPar
This is the so\sphinxhyphen{}called \sphinxcode{\sphinxupquote{run record}} \textendash{} a recording of all of the
information in the \sphinxcode{\sphinxupquote{datalad run}} command, generated by DataLad.
In this case, it is a very simple summary. One informative
part is highlighted:
\sphinxcode{\sphinxupquote{"cmd": "bash code/list\_titles.sh"}} is the command that was run
in the terminal.
This information therefore maps the command, and with it the script,
to the output file, in one commit. Nice, isn’t it?

\sphinxAtStartPar
Arguably, the {\hyperref[\detokenize{glossary:term-run-record}]{\sphinxtermref{\DUrole{xref,std,std-term}{run record}}}} is not the most human\sphinxhyphen{}readable way to display information.
This representation however is less for the human user (the human user should
rely on their informative commit message), but for DataLad, in particular for the
\sphinxcode{\sphinxupquote{datalad rerun}} command, which you will see in action shortly. This
\sphinxcode{\sphinxupquote{run record}} is machine\sphinxhyphen{}readable provenance that associates an output with
the command that produced it.

\sphinxAtStartPar
You have probably already guessed that every \sphinxcode{\sphinxupquote{datalad run}} command
ends with a \sphinxcode{\sphinxupquote{datalad save}}. A logical consequence from this fact is that any
\sphinxcode{\sphinxupquote{datalad run}} that does not result in any changes in a dataset (no modification
of existing content; no additional files) will not produce any record in the
dataset’s history (just as a \sphinxcode{\sphinxupquote{datalad save}} with no modifications present
will not create a history entry). Try to run the exact same
command as before, and check whether anything in your log changes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Try again to create a list of podcast titles\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYG{l+s+s2}{\PYGZdq{}bash code/list\PYGZus{}titles.sh \PYGZgt{} recordings/podcasts.tsv\PYGZdq{}}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{run(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 (dataset) [bash code/list\PYGZus{}titles.sh \PYGZgt{} recordings/po...]}
\end{sphinxVerbatim}

\fvset{hllines={, 2,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{e37c9fc [DATALAD RUNCMD] create a list of podcast titles}
\PYG{g+go}{e799b6b Add short script to write a list of podcast speakers and titles}
\PYG{g+go}{87609a3 Add note on datalad clone}
\PYG{g+go}{3c016f7 [DATALAD] Added subdataset}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
The most recent commit is still the \sphinxcode{\sphinxupquote{datalad run}} command from before,
and there was no second \sphinxcode{\sphinxupquote{datalad run}} commit created.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{datalad run}} can therefore help you to keep track of what you are doing
in a dataset and capture provenance of your files: When, by whom, and how exactly
was a particular file created or modified?
The next sections will demonstrate how to make use of this information,
and also how to extend the command with additional arguments that will prove to
be helpful over the course of this chapter.

\sphinxstepscope

\index{rerun@\spxentry{rerun}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!rerun@\spxentry{rerun}}\index{reproducibility@\spxentry{reproducibility}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!reproducibility@\spxentry{reproducibility}}\ignorespaces 

\section{DataLad, rerun!}
\label{\detokenize{basics/101-109-rerun:datalad-rerun}}\label{\detokenize{basics/101-109-rerun:run2}}\label{\detokenize{basics/101-109-rerun:index-0}}\label{\detokenize{basics/101-109-rerun::doc}}
\sphinxAtStartPar
So far, you created a \sphinxcode{\sphinxupquote{.tsv}} file of all
speakers and talk titles in the \sphinxcode{\sphinxupquote{longnow/}} podcasts subdataset.
Let’s actually take a look into this file now:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }less\PYG{+w}{ }recordings/podcasts.tsv
\PYG{g+go}{2003\PYGZhy{}11\PYGZhy{}15	Brian Eno  The Long Now}
\PYG{g+go}{2003\PYGZhy{}12\PYGZhy{}13	Peter Schwartz  The Art Of The Really Long View}
\PYG{g+go}{2004\PYGZhy{}02\PYGZhy{}14	James Dewar  Long term Policy Analysis}
\PYG{g+go}{2004\PYGZhy{}03\PYGZhy{}13	Rusty Schweickart  The Asteroid Threat Over the Next 100 000 Years}
\PYG{g+go}{2004\PYGZhy{}04\PYGZhy{}10	Daniel Janzen  Third World Conservation  It s ALL Gardening}
\PYG{g+go}{\PYGZhy{}✂\PYGZhy{}\PYGZhy{}✂\PYGZhy{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Not too bad, and certainly good enough for the podcast night people.
What’s been cool about creating this file is that it was created with
a script within a \sphinxcode{\sphinxupquote{datalad run}} command. Thanks to \sphinxcode{\sphinxupquote{datalad run}},
the output file \sphinxcode{\sphinxupquote{podcasts.tsv}} is associated with the script it
generated.

\sphinxAtStartPar
Upon reviewing the list you realized that you made a mistake, though: you only
listed the talks in the SALT series (the
\sphinxcode{\sphinxupquote{Long\_Now\_\_Seminars\_About\_Long\_term\_Thinking/}} directory), but not
in the \sphinxcode{\sphinxupquote{Long\_Now\_\_Conversations\_at\_The\_Interval/}} directory.
Let’s fix this in the script. Replace the contents in \sphinxcode{\sphinxupquote{code/list\_titles.sh}}
with the following, fixed script. Again, make sure to see the
\textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-heredoc-alt2}} {\hyperref[\detokenize{basics/101-109-rerun:ww-heredoc-alt2}]{\sphinxcrossref{\DUrole{std,std-ref}{on an alternative}}}} (\autopageref*{\detokenize{basics/101-109-rerun:ww-heredoc-alt2}}).
\begin{windowswit}[label={ww-heredoc-alt2}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Here’s a script adjustment for Windows users}
\label{\detokenize{basics/101-109-rerun:ww-heredoc-alt2}}

\sphinxAtStartPar
Please use an editor of your choice to replace the contents of \sphinxcode{\sphinxupquote{list\_titles.sh}} inside of the \sphinxcode{\sphinxupquote{code}} directory with the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for}\PYG{+w}{ }i\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }recordings/longnow/Long\PYGZus{}Now*/*.mp3\PYG{p}{;}\PYG{+w}{ }\PYG{k}{do}
\PYG{+w}{   }\PYG{c+c1}{\PYGZsh{} get the filename}
\PYG{+w}{   }\PYG{n+nv}{base}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}basename\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}i}\PYG{l+s+s2}{\PYGZdq{}}\PYG{k}{)}\PYG{p}{;}
\PYG{+w}{   }\PYG{c+c1}{\PYGZsh{} strip the extension}
\PYG{+w}{   }\PYG{n+nv}{base}\PYG{o}{=}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{base}\PYG{p}{\PYGZpc{}.mp3}\PYG{l+s+si}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{c+c1}{\PYGZsh{} date as yyyy\PYGZhy{}mm\PYGZhy{}dd}
\PYG{+w}{   }\PYG{n+nb}{printf}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{base}\PYG{p}{\PYGZpc{}\PYGZpc{}\PYGZus{}\PYGZus{}*}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZbs{}t}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }tr\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZsq{}}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{   }\PYG{c+c1}{\PYGZsh{} name and title without underscores}
\PYG{+w}{   }\PYG{n+nb}{printf}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{base}\PYG{p}{\PYGZsh{}*\PYGZus{}\PYGZus{}}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }tr\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZus{}\PYGZsq{}}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{} \PYGZsq{}}\PYG{p}{;}
\PYG{k}{done}
\end{sphinxVerbatim}


\end{windowswit}

\fvset{hllines={, 2,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYG{p}{|}\PYG{+w}{ }code/list\PYGZus{}titles.sh
\PYG{g+go}{for i in recordings/longnow/Long\PYGZus{}Now*/*.mp3; do}
\PYG{g+gp}{   \PYGZsh{} }get\PYG{+w}{ }the\PYG{+w}{ }filename
\PYG{g+go}{   base=\PYGZbs{}\PYGZdl{}(basename \PYGZdq{}\PYGZbs{}\PYGZdl{}i\PYGZdq{});}
\PYG{g+gp}{   \PYGZsh{} }strip\PYG{+w}{ }the\PYG{+w}{ }extension
\PYG{g+go}{   base=\PYGZbs{}\PYGZdl{}\PYGZob{}base\PYGZpc{}.mp3\PYGZcb{};}
\PYG{g+go}{   printf \PYGZdq{}\PYGZbs{}\PYGZdl{}\PYGZob{}base\PYGZpc{}\PYGZpc{}\PYGZus{}\PYGZus{}*\PYGZcb{}\PYGZbs{}t\PYGZdq{} | tr \PYGZsq{}\PYGZus{}\PYGZsq{} \PYGZsq{}\PYGZhy{}\PYGZsq{};}
\PYG{g+gp}{   \PYGZsh{} }name\PYG{+w}{ }and\PYG{+w}{ }title\PYG{+w}{ }without\PYG{+w}{ }underscores
\PYG{g+go}{   printf \PYGZdq{}\PYGZbs{}\PYGZdl{}\PYGZob{}base\PYGZsh{}*\PYGZus{}\PYGZus{}\PYGZcb{}\PYGZbs{}n\PYGZdq{} | tr \PYGZsq{}\PYGZus{}\PYGZsq{} \PYGZsq{} \PYGZsq{};}

\PYG{g+go}{done}
\PYG{g+go}{EOT}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Because the script is now modified, save the modifications to the dataset.
We can use the shorthand “BF” to denote “Bug fix” in the commit message.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{ modified: code/list\PYGZus{}titles.sh (file)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}BF: list both directories content\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }code/list\PYGZus{}titles.sh
\PYG{g+go}{add(ok): code/list\PYGZus{}titles.sh (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
What we \sphinxstyleemphasis{could} do is run the same \sphinxcode{\sphinxupquote{datalad run}} command as before to recreate
the file, but now with all of the contents:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} do not execute this!}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}create a list of podcast titles\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYG{l+s+s2}{\PYGZdq{}bash code/list\PYGZus{}titles.sh \PYGZgt{} recordings/podcasts.tsv\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
However, think about any situation where the command would be longer than this,
or that is many months past the first execution. It would not be easy to remember
the command, nor would it be very convenient to copy it from the \sphinxcode{\sphinxupquote{run record}}.

\sphinxAtStartPar
Luckily, a fellow student remembered the DataLad way of re\sphinxhyphen{}executing
a \sphinxcode{\sphinxupquote{run}} command, and he’s eager to show it to you.

\sphinxAtStartPar
“In order to re\sphinxhyphen{}execute a \sphinxcode{\sphinxupquote{datalad run}} command,
find the commit and use its {\hyperref[\detokenize{glossary:term-shasum}]{\sphinxtermref{\DUrole{xref,std,std-term}{shasum}}}} (or a {\hyperref[\detokenize{glossary:term-tag}]{\sphinxtermref{\DUrole{xref,std,std-term}{tag}}}}, or anything else that Git
understands) as an argument for the
\sphinxcode{\sphinxupquote{datalad rerun}} command! That’s it!”,
he says happily.

\sphinxAtStartPar
So you go ahead and find the commit {\hyperref[\detokenize{glossary:term-shasum}]{\sphinxtermref{\DUrole{xref,std,std-term}{shasum}}}} in your history:

\fvset{hllines={, 8,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{2}
\PYG{g+go}{commit f7ea9f3d✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    BF: list both directories content}

\PYG{g+go}{commit e37c9fc9✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    [DATALAD RUNCMD] create a list of podcast titles}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Take that shasum and paste it after \sphinxcode{\sphinxupquote{datalad rerun}}
(the first 6\sphinxhyphen{}8 characters of the shasum would be sufficient,
here we are using all of them).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }rerun\PYG{+w}{ }e37c9fc9✂SHA1
\PYG{g+go}{[INFO] run commit e37c9fc; (create a list of ...)}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{run(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 (dataset) [bash code/list\PYGZus{}titles.sh \PYGZgt{} recordings/po...]}
\PYG{g+go}{add(ok): recordings/podcasts.tsv (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{action summary:}
\PYG{g+go}{  add (ok: 1)}
\PYG{g+go}{  run (ok: 1)}
\PYG{g+go}{  save (notneeded: 1, ok: 1)}
\PYG{g+go}{  unlock (notneeded: 1)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now DataLad has made use of the \sphinxcode{\sphinxupquote{run record}}, and
re\sphinxhyphen{}executed the original command based on the information in it.
Because we updated the script, the output \sphinxcode{\sphinxupquote{podcasts.tsv}}
has changed and now contains the podcast
titles of both subdirectories.
You’ve probably already guessed it, but the easiest way
to check whether a \sphinxcode{\sphinxupquote{datalad rerun}}
has changed the desired output file is
to check whether the rerun command appears in the datasets history:
If a \sphinxcode{\sphinxupquote{datalad rerun}} does not add or change any content in the dataset,
it will also not be recorded in the history.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}
\PYG{g+go}{commit 08120c38✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    [DATALAD RUNCMD] create a list of podcast titles}

\PYG{g+go}{    === Do not change lines below ===}
\PYG{g+go}{    \PYGZob{}}
\PYG{g+go}{     \PYGZdq{}chain\PYGZdq{}: [}
\PYG{g+go}{      \PYGZdq{}e37c9fc9✂SHA1\PYGZdq{}}
\PYG{g+go}{     ],}
\PYG{g+go}{     \PYGZdq{}cmd\PYGZdq{}: \PYGZdq{}bash code/list\PYGZus{}titles.sh \PYGZgt{} recordings/podcasts.tsv\PYGZdq{},}
\PYG{g+go}{     \PYGZdq{}dsid\PYGZdq{}: \PYGZdq{}e3e70682\PYGZhy{}c209\PYGZhy{}4cac\PYGZhy{}629f\PYGZhy{}6fbed82c07cd\PYGZdq{},}
\PYG{g+go}{     \PYGZdq{}exit\PYGZdq{}: 0,}
\PYG{g+go}{     \PYGZdq{}extra\PYGZus{}inputs\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}inputs\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}outputs\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}pwd\PYGZdq{}: \PYGZdq{}.\PYGZdq{}}
\PYG{g+go}{    \PYGZcb{}}
\PYG{g+go}{    \PYGZca{}\PYGZca{}\PYGZca{} Do not change lines above \PYGZca{}\PYGZca{}\PYGZca{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the dataset’s history,
we can see that a new \sphinxcode{\sphinxupquote{datalad run}} was recorded. This action is
committed by DataLad under the original commit message of the \sphinxcode{\sphinxupquote{run}}
command, and looks just like the previous \sphinxcode{\sphinxupquote{datalad run}} commit.

\index{diff@\spxentry{diff}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!diff@\spxentry{diff}}\ignorespaces 
\sphinxAtStartPar
Two cool tools that go beyond the \sphinxcode{\sphinxupquote{git log}}
are the \sphinxcode{\sphinxupquote{datalad diff}} and \sphinxcode{\sphinxupquote{git diff}} commands.
Both commands can report differences between two states of
a dataset. Thus, you can get an overview of what changed between two commits.
Both commands have a similar, but not identical structure: \sphinxcode{\sphinxupquote{datalad diff}}
compares one state (a commit specified with \sphinxcode{\sphinxupquote{\sphinxhyphen{}f}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}from}},
by default the latest change)
and another state from the dataset’s history (a commit specified with
\sphinxcode{\sphinxupquote{\sphinxhyphen{}t}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}to}}). Let’s do a \sphinxcode{\sphinxupquote{datalad diff}} between the current state
of the dataset and the previous commit (called “\sphinxcode{\sphinxupquote{HEAD\textasciitilde{}1}}” in Git terminology%
\begin{footnote}[1]\sphinxAtStartFootnote
The section {\hyperref[\detokenize{basics/101-137-history:history}]{\sphinxcrossref{\DUrole{std,std-ref}{Git things done}}}} (\autopageref*{\detokenize{basics/101-137-history:history}}) will elaborate more on common {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} commands
and terminology.
%
\end{footnote}).
Check the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-diff-adjusted}} {\hyperref[\detokenize{basics/101-109-rerun:ww-diff-adjusted}]{\sphinxcrossref{\DUrole{std,std-ref}{on a command variant}}}} (\autopageref*{\detokenize{basics/101-109-rerun:ww-diff-adjusted}}).

\index{show dataset modification@\spxentry{show dataset modification}!on Windows with DataLad@\spxentry{on Windows with DataLad}}\index{on Windows with DataLad@\spxentry{on Windows with DataLad}!show dataset modification@\spxentry{show dataset modification}}\index{diff@\spxentry{diff}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!diff@\spxentry{diff}}\index{corresponding branch@\spxentry{corresponding branch}!in adjusted mode@\spxentry{in adjusted mode}}\index{in adjusted mode@\spxentry{in adjusted mode}!corresponding branch@\spxentry{corresponding branch}}\ignorespaces \begin{windowswit}[label={ww-diff-adjusted}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{please use ‘datalad diff –from main –to HEAD~1’}
\label{\detokenize{basics/101-109-rerun:ww-diff-adjusted}}

\sphinxAtStartPar
While this example works on Unix file systems, it will not provide the same output on Windows.
This is due to different file handling on Windows.
When executing this command, you will see \sphinxstyleemphasis{all} files being modified between the most recent and the second\sphinxhyphen{}most recent commit.
On a technical level, this is correct given the underlying file handling on Windows, and chapter {\hyperref[\detokenize{basics/basics-annex:chapter-gitannex}]{\sphinxcrossref{\DUrole{std,std-ref}{Under the hood: git\sphinxhyphen{}annex}}}} (\autopageref*{\detokenize{basics/basics-annex:chapter-gitannex}}) will shed light on why that is.

\sphinxAtStartPar
For now, to get the same output as shown in the code snippet below, use the following command where \sphinxcode{\sphinxupquote{main}} (or \sphinxcode{\sphinxupquote{master}}) is the name of your default branch:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }diff\PYG{+w}{ }\PYGZhy{}\PYGZhy{}from\PYG{+w}{ }main\PYG{+w}{ }\PYGZhy{}\PYGZhy{}to\PYG{+w}{ }HEAD\PYGZti{}1
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}from}} argument specifies a different starting point for the comparison \sphinxhyphen{} the \sphinxcode{\sphinxupquote{main}} or {\hyperref[\detokenize{glossary:term-master}]{\sphinxtermref{\DUrole{xref,std,std-term}{master}}}} {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}}, which would be the starting point on most Unix\sphinxhyphen{}based systems.


\end{windowswit}

\index{diff@\spxentry{diff}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!diff@\spxentry{diff}}\index{show dataset modification@\spxentry{show dataset modification}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!show dataset modification@\spxentry{show dataset modification}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-109-rerun:index-3}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }diff\PYG{+w}{ }\PYGZhy{}\PYGZhy{}to\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+go}{ modified: recordings/podcasts.tsv (file)}
\end{sphinxVerbatim}

\index{diff@\spxentry{diff}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!diff@\spxentry{diff}}\index{show dataset modification@\spxentry{show dataset modification}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!show dataset modification@\spxentry{show dataset modification}}\ignorespaces 
\sphinxAtStartPar
This indeed shows the output file as “modified”. However, we do not know
what exactly changed. This is a task for \sphinxcode{\sphinxupquote{git diff}} (get out of the
diff view by pressing \sphinxcode{\sphinxupquote{q}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }diff\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/recordings/podcasts.tsv b/recordings/podcasts.tsv}
\PYG{g+go}{index f691b53..d77891d 100644}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} a/recordings/podcasts.tsv}
\PYG{g+go}{+++ b/recordings/podcasts.tsv}
\PYG{g+go}{@@ \PYGZhy{}1,3 +1,31 @@}
\PYG{g+go}{+2017\PYGZhy{}06\PYGZhy{}09	How Digital Memory Is Shaping Our Future  Abby Smith Rumsey}
\PYG{g+go}{+2017\PYGZhy{}06\PYGZhy{}09	Pace Layers Thinking  Stewart Brand  Paul Saffo}
\PYG{g+go}{+2017\PYGZhy{}06\PYGZhy{}09	Proof  The Science of Booze  Adam Rogers}
\PYG{g+go}{+2017\PYGZhy{}06\PYGZhy{}09	Seveneves at The Interval  Neal Stephenson}
\PYG{g+go}{+2017\PYGZhy{}06\PYGZhy{}09	Talking with Robots about Architecture  Jeffrey McGrew}
\PYG{g+go}{+2017\PYGZhy{}06\PYGZhy{}09	The Red Planet for Real  Andy Weir}
\PYG{g+go}{+2017\PYGZhy{}07\PYGZhy{}03	Transforming Perception  One Sense at a Time  Kara Platoni}
\PYG{g+go}{+2017\PYGZhy{}08\PYGZhy{}01	How Climate Will Evolve Government and Society  Kim Stanley Robinson}
\PYG{g+go}{+2017\PYGZhy{}09\PYGZhy{}01	Envisioning Deep Time  Jonathon Keats}
\PYG{g+go}{+2017\PYGZhy{}10\PYGZhy{}01	Thinking Long term About the Evolving Global Challenge  The Refugee Reality}
\PYG{g+go}{+2017\PYGZhy{}11\PYGZhy{}01	The Web In An Eye Blink  Jason Scott}
\PYG{g+go}{+2017\PYGZhy{}12\PYGZhy{}01	Ideology in our Genes  The Biological Basis for Political Traits  Rose McDermott}
\PYG{g+go}{+2017\PYGZhy{}12\PYGZhy{}07	Can Democracy Survive the Internet   Nathaniel Persily}
\PYG{g+go}{+2018\PYGZhy{}01\PYGZhy{}02	The New Deal You Don t Know  Louis Hyman}
\end{sphinxVerbatim}

\sphinxAtStartPar
This output actually shows the precise changes between the contents created
with the first version of the script and the second script with the bug fix.
All of the files that are added after the second directory
was queried as well are shown in the \sphinxcode{\sphinxupquote{diff}}, preceded by a \sphinxcode{\sphinxupquote{+}}.

\sphinxAtStartPar
Quickly create a note about these two helpful commands in \sphinxcode{\sphinxupquote{notes.txt}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }notes.txt
\PYG{g+go}{There are two useful functions to display changes between two}
\PYG{g+go}{states of a dataset: \PYGZdq{}datalad diff \PYGZhy{}f/\PYGZhy{}\PYGZhy{}from COMMIT \PYGZhy{}t/\PYGZhy{}\PYGZhy{}to COMMIT\PYGZdq{}}
\PYG{g+go}{and \PYGZdq{}git diff COMMIT COMMIT\PYGZdq{}, where COMMIT is a shasum of a commit}
\PYG{g+go}{in the history.}

\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, save this note.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add note datalad and git diff\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{datalad rerun}} can re\sphinxhyphen{}execute the run records of both a \sphinxcode{\sphinxupquote{datalad run}}
or a \sphinxcode{\sphinxupquote{datalad rerun}} command,
but not with any other type of DataLad command in your history
such as a \sphinxcode{\sphinxupquote{datalad save}} on results or outputs after you executed a script.
Therefore, make it a
habit to record the execution of scripts by plugging it into \sphinxcode{\sphinxupquote{datalad run}}.

\sphinxAtStartPar
This very basic example of a \sphinxcode{\sphinxupquote{datalad run}} is as simple as it can get, but it
is already
convenient from a memory\sphinxhyphen{}load perspective: Now you do not need to
remember the commands or scripts involved in creating an output. DataLad kept track
of what you did, and you can instruct it to “\sphinxcode{\sphinxupquote{rerun}}” it.
Also, incidentally, we have generated {\hyperref[\detokenize{glossary:term-provenance}]{\sphinxtermref{\DUrole{xref,std,std-term}{provenance}}}} information. It is
now recorded in the history of the dataset how the output \sphinxcode{\sphinxupquote{podcasts.tsv}} came
into existence. And we can interact with and use this provenance information with
other tools than from the machine\sphinxhyphen{}readable \sphinxcode{\sphinxupquote{run record}}.
For example, to find out who (or what) created or modified a file,
give the file path to \sphinxcode{\sphinxupquote{git log}} (prefixed by \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}}}).
Check the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-log-adjusted}} {\hyperref[\detokenize{basics/101-109-rerun:ww-log-adjusted}]{\sphinxcrossref{\DUrole{std,std-ref}{on a command variant}}}} (\autopageref*{\detokenize{basics/101-109-rerun:ww-log-adjusted}}).

\index{show history for particular paths@\spxentry{show history for particular paths}!on Windows with Git@\spxentry{on Windows with Git}}\index{on Windows with Git@\spxentry{on Windows with Git}!show history for particular paths@\spxentry{show history for particular paths}}\index{log@\spxentry{log}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!log@\spxentry{log}}\index{corresponding branch@\spxentry{corresponding branch}!in adjusted mode@\spxentry{in adjusted mode}}\index{in adjusted mode@\spxentry{in adjusted mode}!corresponding branch@\spxentry{corresponding branch}}\ignorespaces \begin{windowswit}[label={ww-log-adjusted}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{use ‘git log main – recordings/podcasts.tsv’}
\label{\detokenize{basics/101-109-rerun:ww-log-adjusted}}

\sphinxAtStartPar
A previous Windows Wit already advised to append \sphinxcode{\sphinxupquote{main}} or \sphinxcode{\sphinxupquote{master}}, the common “default {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}}”, to any command that starts with \sphinxcode{\sphinxupquote{git log}}.
Here, the last part of the command specifies a file (\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{} recordings/podcasts.tsv}}).
Please append \sphinxcode{\sphinxupquote{main}} or \sphinxcode{\sphinxupquote{master}} to \sphinxcode{\sphinxupquote{git log}}, prior to the file specification.


\end{windowswit}

\index{show history for particular paths@\spxentry{show history for particular paths}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!show history for particular paths@\spxentry{show history for particular paths}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-109-rerun:index-6}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}\PYG{+w}{ }recordings/podcasts.tsv
\PYG{g+go}{commit 08120c38✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    [DATALAD RUNCMD] create a list of podcast titles}

\PYG{g+go}{    === Do not change lines below ===}
\PYG{g+go}{    \PYGZob{}}
\PYG{g+go}{     \PYGZdq{}chain\PYGZdq{}: [}
\PYG{g+go}{      \PYGZdq{}e37c9fc9✂SHA1\PYGZdq{}}
\PYG{g+go}{     ],}
\PYG{g+go}{     \PYGZdq{}cmd\PYGZdq{}: \PYGZdq{}bash code/list\PYGZus{}titles.sh \PYGZgt{} recordings/podcasts.tsv\PYGZdq{},}
\PYG{g+go}{     \PYGZdq{}dsid\PYGZdq{}: \PYGZdq{}e3e70682\PYGZhy{}c209\PYGZhy{}4cac\PYGZhy{}629f\PYGZhy{}6fbed82c07cd\PYGZdq{},}
\PYG{g+go}{     \PYGZdq{}exit\PYGZdq{}: 0,}
\PYG{g+go}{     \PYGZdq{}extra\PYGZus{}inputs\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}inputs\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}outputs\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}pwd\PYGZdq{}: \PYGZdq{}.\PYGZdq{}}
\PYG{g+go}{    \PYGZcb{}}
\PYG{g+go}{    \PYGZca{}\PYGZca{}\PYGZca{} Do not change lines above \PYGZca{}\PYGZca{}\PYGZca{}}

\PYG{g+go}{commit e37c9fc9✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    [DATALAD RUNCMD] create a list of podcast titles}

\PYG{g+go}{    === Do not change lines below ===}
\PYG{g+go}{    \PYGZob{}}
\PYG{g+go}{     \PYGZdq{}chain\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}cmd\PYGZdq{}: \PYGZdq{}bash code/list\PYGZus{}titles.sh \PYGZgt{} recordings/podcasts.tsv\PYGZdq{},}
\PYG{g+go}{     \PYGZdq{}dsid\PYGZdq{}: \PYGZdq{}e3e70682\PYGZhy{}c209\PYGZhy{}4cac\PYGZhy{}629f\PYGZhy{}6fbed82c07cd\PYGZdq{},}
\PYG{g+go}{     \PYGZdq{}exit\PYGZdq{}: 0,}
\PYG{g+go}{     \PYGZdq{}extra\PYGZus{}inputs\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}inputs\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}outputs\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}pwd\PYGZdq{}: \PYGZdq{}.\PYGZdq{}}
\PYG{g+go}{    \PYGZcb{}}
\PYG{g+go}{    \PYGZca{}\PYGZca{}\PYGZca{} Do not change lines above \PYGZca{}\PYGZca{}\PYGZca{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Neat, isn’t it?

\sphinxAtStartPar
Still, this \sphinxcode{\sphinxupquote{datalad run}} was very simple.
The next section will demonstrate how \sphinxcode{\sphinxupquote{datalad run}} becomes handy in
more complex standard use cases: situations with \sphinxstyleemphasis{locked} contents.

\sphinxAtStartPar
But prior to that, make a note about \sphinxcode{\sphinxupquote{datalad run}} and \sphinxcode{\sphinxupquote{datalad rerun}} in your
\sphinxcode{\sphinxupquote{notes.txt}} file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }notes.txt
\PYG{g+go}{The datalad run command can record the impact a script or command has}
\PYG{g+go}{on a Dataset. In its simplest form, datalad run only takes a commit}
\PYG{g+go}{message and the command that should be executed.}

\PYG{g+go}{Any datalad run command can be re\PYGZhy{}executed by using its commit shasum}
\PYG{g+go}{as an argument in datalad rerun CHECKSUM. DataLad will take}
\PYG{g+go}{information from the run record of the original commit, and re\PYGZhy{}execute}
\PYG{g+go}{it. If no changes happen with a rerun, the command will not be written}
\PYG{g+go}{to history. Note: you can also rerun a datalad rerun command!}

\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, save this note.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add note on basic datalad run and datalad rerun\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxstepscope

\index{provenance tracking@\spxentry{provenance tracking}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!provenance tracking@\spxentry{provenance tracking}}\ignorespaces 

\section{Input and output}
\label{\detokenize{basics/101-110-run2:input-and-output}}\label{\detokenize{basics/101-110-run2:run3}}\label{\detokenize{basics/101-110-run2:index-0}}\label{\detokenize{basics/101-110-run2::doc}}
\sphinxAtStartPar
In the previous two sections, you created a simple \sphinxcode{\sphinxupquote{.tsv}} file of all
speakers and talk titles in the \sphinxcode{\sphinxupquote{longnow/}} podcasts subdataset, and you have
re\sphinxhyphen{}executed a \sphinxcode{\sphinxupquote{datalad run}} command after a bug\sphinxhyphen{}fix in your script.

\sphinxAtStartPar
But these previous \sphinxcode{\sphinxupquote{datalad run}} and \sphinxcode{\sphinxupquote{datalad rerun}} command were very simple.
Maybe you noticed some values in the \sphinxcode{\sphinxupquote{run record}} were empty:
\sphinxcode{\sphinxupquote{inputs}} and \sphinxcode{\sphinxupquote{outputs}} for example did not have an entry. Let’s experience
a few situations in which
these two arguments can become necessary.

\sphinxAtStartPar
In our DataLad\sphinxhyphen{}101 course we were given a group assignment. Everyone should
give a small presentation about an open DataLad dataset they found. Conveniently,
you decided to settle for the longnow podcasts right away.
After all, you know the dataset quite well already,
and after listening to almost a third of the podcasts
and enjoying them a lot,
you also want to recommend them to the others.

\sphinxAtStartPar
Almost all of the slides are ready, but what’s still missing is the logo of the
longnow podcasts. Good thing that this is part of the subdataset,
so you can simply retrieve it from there.

\sphinxAtStartPar
The logos (one for the SALT series, one for the Interval series \textendash{} the two
directories in the subdataset)
were originally extracted from the podcasts metadata information by DataLad.
The online\sphinxhyphen{}handbook has a chapter on the metadata aggregation capabilities of DataLad,
but for now, let’s just use the logos instead of finding out where they
come from \textendash{} this will come later.
As part of the metadata of the dataset, the logos are
in the hidden paths
\sphinxcode{\sphinxupquote{.datalad/feed\_metadata/logo\_salt.jpg}} and
\sphinxcode{\sphinxupquote{.datalad/feed\_metadata/logo\_interval.jpg}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }recordings/longnow/.datalad/feed\PYGZus{}metadata/*jpg
\PYG{g+go}{recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}interval.jpg}
\PYG{g+go}{recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg}
\end{sphinxVerbatim}

\sphinxAtStartPar
For the slides you decide to prepare images of size 400x400 px, but
the logos’ original size is much larger (both are 3000x3000 pixel). Therefore
let’s try to resize the images \textendash{} currently, they are far too large to fit on a slide.

\sphinxAtStartPar
To resize an image from the command line we can use the Unix
command \sphinxcode{\sphinxupquote{convert \sphinxhyphen{}resize}} from the \sphinxhref{https://imagemagick.org/index.php}{ImageMagick tool}.
See the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-install-imagemagick}} {\hyperref[\detokenize{basics/101-110-run2:ww-install-imagemagick}]{\sphinxcrossref{\DUrole{std,std-ref}{on installing it}}}} (\autopageref*{\detokenize{basics/101-110-run2:ww-install-imagemagick}}), if your system does not provide it.
The command takes a new size in pixels as an argument, a path to the file that should be
resized, and a filename and path under which a new,
resized image will be saved.
To resize one image to 400x400 px, the command would thus be
\sphinxcode{\sphinxupquote{convert \sphinxhyphen{}resize 400x400 path/to/file.jpg path/to/newfilename.jpg}}.

\index{install ImageMagick@\spxentry{install ImageMagick}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!install ImageMagick@\spxentry{install ImageMagick}}\index{installation@\spxentry{installation}!ImageMagick@\spxentry{ImageMagick}}\ignorespaces \begin{windowswit}[label={ww-install-imagemagick}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Tool installation}
\label{\detokenize{basics/101-110-run2:ww-install-imagemagick}}

\sphinxAtStartPar
\sphinxhref{https://imagemagick.org/index.php}{ImageMagick} is not installed on Windows systems by default.
To use it, you need to install it, using the provided \sphinxhref{https://imagemagick.org/script/download.php}{Windows Binary Release on the Download page}.
During installation, it is important to install the tool into a place where it is easily accessible to your terminal, for example the \sphinxcode{\sphinxupquote{Program Files}} folder.
Do also make sure to tick the box “install legacy commands” in the installation wizard.


\end{windowswit}

\sphinxAtStartPar
Remembering the last lecture on \sphinxcode{\sphinxupquote{datalad run}}, you decide to plug this into
\sphinxcode{\sphinxupquote{datalad run}}. Even though this is not a script, it is a command, and you can wrap
commands like this conveniently with \sphinxcode{\sphinxupquote{datalad run}}.
Because they will be quite long, we line break the commands in the upcoming examples
for better readability \textendash{} in your terminal, you can always write the commands into
a single line.

\index{run command with provenance capture@\spxentry{run command with provenance capture}!with DataLad run@\spxentry{with DataLad run}}\index{with DataLad run@\spxentry{with DataLad run}!run command with provenance capture@\spxentry{run command with provenance capture}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-110-run2:index-2}}}
\fvset{hllines={, 4,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Resize logo for slides\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}convert \PYGZhy{}resize 400x400 recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg recordings/salt\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{convert convert: Unable to open file (recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg) [No such file or directory].}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{[INFO] The command had a non\PYGZhy{}zero exit code. If this is expected, you can save the changes with \PYGZsq{}datalad save \PYGZhy{}d . \PYGZhy{}r \PYGZhy{}F .git/COMMIT\PYGZus{}EDITMSG\PYGZsq{}}
\PYG{g+go}{run(error): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 (dataset) [convert \PYGZhy{}resize 400x400 recordings/longn...]}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
\sphinxstyleemphasis{Oh, crap!} Why didn’t this work?

\sphinxAtStartPar
Let’s take a look at the error message DataLad provides. In general, these error messages
might seem wordy, and maybe a bit intimidating as well, but usually they provide helpful
information to find out what is wrong. Whenever you encounter an error message,
make sure to read it, even if it feels like a mushroom cloud exploded in your terminal.

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{datalad run}} error message has several parts. The first starts after

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}INFO   {]} == Command start (output follows) =====}}.

\sphinxAtStartPar
This is displaying errors that the
terminal command threw: The \sphinxcode{\sphinxupquote{convert}} tool complains that it cannot open
the file, because there is “No such file or directory”.

\sphinxAtStartPar
The second part starts after

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}INFO   {]} == Command exit (modification check follows) =====}}.

\sphinxAtStartPar
DataLad adds information about a “non\sphinxhyphen{}zero exit code”. A non\sphinxhyphen{}zero exit code indicates
that something went wrong%
\begin{footnote}[1]\sphinxAtStartFootnote
In shell programming, commands exit with a specific code that indicates
whether they failed, and if so, how. Successful commands have the exit code zero. All failures
have exit codes greater than zero.
%
\end{footnote}. In principle, you could go ahead and google what this
specific exit status indicates. However, the solution might have already occurred to you when
reading the first error report: The file is not present.

\sphinxAtStartPar
How can that be?

\sphinxAtStartPar
“Right!”, you exclaim with a facepalm.
Just as the \sphinxcode{\sphinxupquote{.mp3}} files, the \sphinxcode{\sphinxupquote{.jpg}} file content is not present
locally after a \sphinxcode{\sphinxupquote{datalad clone}}, and we did not \sphinxcode{\sphinxupquote{datalad get}} it yet!

\index{declare command input@\spxentry{declare command input}!with DataLad run@\spxentry{with DataLad run}}\index{with DataLad run@\spxentry{with DataLad run}!declare command input@\spxentry{declare command input}}\ignorespaces 
\sphinxAtStartPar
This is where the \sphinxcode{\sphinxupquote{\sphinxhyphen{}i}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}input}} option for a \sphinxcode{\sphinxupquote{datalad run}} becomes useful.
The content of everything that is specified as an \sphinxcode{\sphinxupquote{input}} will be retrieved
prior to running the command.

\fvset{hllines={, 8,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Resize logo for slides\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}convert \PYGZhy{}resize 400x400 recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg recordings/salt\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} or shorter:}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Resize logo for slides\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}i\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}convert \PYGZhy{}resize 400x400 recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg recordings/salt\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}
\PYG{g+go}{get(ok): recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg (file) [from web...]}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{run(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 (dataset) [convert \PYGZhy{}resize 400x400 recordings/longn...]}
\PYG{g+go}{add(ok): recordings/salt\PYGZus{}logo\PYGZus{}small.jpg (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Cool! You can see in this output that prior to the data command execution, DataLad did a \sphinxcode{\sphinxupquote{datalad get}}.
This is useful for several reasons. For one, it saved us the work of manually
getting content. But moreover, this is useful for anyone with whom we might share the
dataset: With an installed dataset one can very simply rerun \sphinxcode{\sphinxupquote{datalad run}} commands
if they have the input argument appropriately specified. It is therefore good practice to
specify the inputs appropriately. Remember from section {\hyperref[\detokenize{basics/101-105-install:installds}]{\sphinxcrossref{\DUrole{std,std-ref}{Install datasets}}}} (\autopageref*{\detokenize{basics/101-105-install:installds}})
that \sphinxcode{\sphinxupquote{datalad get}} will only retrieve content if
it is not yet present, all input already downloaded will not be downloaded again \textendash{} so
specifying inputs even though they are already present will not do any harm.
The \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-run-multiple-inputs}} {\hyperref[\detokenize{basics/101-110-run2:fom-run-multiple-inputs}]{\sphinxcrossref{\DUrole{std,std-ref}{on using more than one input}}}} (\autopageref*{\detokenize{basics/101-110-run2:fom-run-multiple-inputs}}) provides
some more details.

\index{path globbing@\spxentry{path globbing}!with DataLad run@\spxentry{with DataLad run}}\index{with DataLad run@\spxentry{with DataLad run}!path globbing@\spxentry{path globbing}}\ignorespaces \begin{findoutmore}[label={fom-run-multiple-inputs}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{What if there are several inputs?}
\label{\detokenize{basics/101-110-run2:fom-run-multiple-inputs}}

\sphinxAtStartPar
Often, a command needs several inputs. In principle, every input (which could be files, directories, or subdatasets) gets its own \sphinxcode{\sphinxupquote{\sphinxhyphen{}i}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}input}}
flag. However, you can make use of {\hyperref[\detokenize{glossary:term-globbing}]{\sphinxtermref{\DUrole{xref,std,std-term}{globbing}}}}. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}*.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}COMMAND\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
will retrieve all \sphinxcode{\sphinxupquote{.jpg}} files prior to command execution.


\end{findoutmore}


\subsection{If outputs already exist…}
\label{\detokenize{basics/101-110-run2:if-outputs-already-exist}}
\index{files are unlocked by default@\spxentry{files are unlocked by default}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!files are unlocked by default@\spxentry{files are unlocked by default}}\index{unlocked files@\spxentry{unlocked files}!in adjusted mode@\spxentry{in adjusted mode}}\index{in adjusted mode@\spxentry{in adjusted mode}!unlocked files@\spxentry{unlocked files}}\ignorespaces \begin{windowswit}[label={fom-rerun-unlocked}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Good news! Here is something that is easier on Windows}
\label{\detokenize{basics/101-110-run2:fom-rerun-unlocked}}

\sphinxAtStartPar
The section below describes something that is very confusing for people that have just started with DataLad: Some files in a dataset can’t be modified, and if one tries, it results in a “permission denied” error.
Why is that?
The remainder of this section and the upcoming chapter {\hyperref[\detokenize{basics/basics-annex:chapter-gitannex}]{\sphinxcrossref{\DUrole{std,std-ref}{Under the hood: git\sphinxhyphen{}annex}}}} (\autopageref*{\detokenize{basics/basics-annex:chapter-gitannex}}) contain a procedural explanation.
However: This doesn’t happen on Windows.
The “unlocking” that is necessary on almost all other systems to modify a file is already done on Windows.
Thus, all files in your dataset will be readily modifiable, sparing you the need to adjust to the unexpected behavior that is described below.
While it is easier, it isn’t a “more useful” behavior, though.
A different Windows Wit in the next chapter will highlight how it rather is a suboptimal workaround.

\sphinxAtStartPar
Please don’t skip the next section \textendash{} it is useful to know how datasets behave on other systems.
Just be mindful that you will not encounter the errors that the book displays next.
And while this all sounds quite cryptic and vague, an upcoming Windows Wit will provide more information.


\end{windowswit}

\sphinxAtStartPar
Looking at the resulting image, you wonder whether 400x400 might be a tiny bit to small.
Maybe we should try to resize it to 450x450, and see whether that looks better?

\sphinxAtStartPar
Note that we cannot use a \sphinxcode{\sphinxupquote{datalad rerun}} for this: if we want to change the dimension option
in the command, we have to define a new \sphinxcode{\sphinxupquote{datalad run}} command.
If you would benefit from an extra bit of motivation, check the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{fom-rerun-unlocked}} {\hyperref[\detokenize{basics/101-110-run2:fom-rerun-unlocked}]{\sphinxcrossref{\DUrole{std,std-ref}{on why what we will do now is, for once, simpler on Windows}}}} (\autopageref*{\detokenize{basics/101-110-run2:fom-rerun-unlocked}}).

\sphinxAtStartPar
To establish best\sphinxhyphen{}practices, let’s specify the input even though it is already present:

\fvset{hllines={, 9,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Resize logo for slides\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}convert \PYGZhy{}resize 450x450 recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg recordings/salt\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} or shorter:}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Resize logo for slides\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}i\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}convert \PYGZhy{}resize 450x450 recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg recordings/salt\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{convert convert: Unable to open file (recordings/salt\PYGZus{}logo\PYGZus{}small.jpg) [Permission denied].}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{[INFO] The command had a non\PYGZhy{}zero exit code. If this is expected, you can save the changes with \PYGZsq{}datalad save \PYGZhy{}d . \PYGZhy{}r \PYGZhy{}F .git/COMMIT\PYGZus{}EDITMSG\PYGZsq{}}
\PYG{g+go}{run(error): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 (dataset) [convert \PYGZhy{}resize 450x450 recordings/longn...]}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
\sphinxstylestrong{Oh wtf}… \sphinxstyleemphasis{What is it now?}

\sphinxAtStartPar
A quick glimpse into the error message shows a different error than before:
The tool complains that it is “unable to open” the image, because the “Permission {[}is{]} denied”.

\sphinxAtStartPar
We have not seen anything like this before, and we need to turn to our lecturer for help.
Confused about what we might have
done wrong, we raise our hand to ask the instructor.
Knowingly, she smiles, and tells you about how DataLad protects content given
to it:

\sphinxAtStartPar
“Content in your DataLad dataset is protected by {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} from
accidental changes” our instructor begins.

\sphinxAtStartPar
“Wait!” we interrupt. “First off, that wasn’t accidental. And second, I was told this
course does not have \sphinxcode{\sphinxupquote{git\sphinxhyphen{}annex\sphinxhyphen{}101}} as a prerequisite?”

\sphinxAtStartPar
“Yes, hear me out” she says. “I promise you two different solutions at
the end of this explanation, and the concept behind this is quite relevant”.

\sphinxAtStartPar
DataLad usually gives content to {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} to store and track.
git\sphinxhyphen{}annex, let’s just say, takes this task \sphinxstyleemphasis{really} seriously. One of its
features that you have just experienced is that it \sphinxstyleemphasis{locks} content.

\sphinxAtStartPar
If files are \sphinxstyleemphasis{locked down}, their content cannot be modified. In principle,
that’s not a bad thing: It could be your late grandma’s secret cherry\sphinxhyphen{}pie
recipe, and you do not want to \sphinxstyleemphasis{accidentally} change that.
Therefore, a file needs to be consciously \sphinxstyleemphasis{unlocked} to apply modifications.

\sphinxAtStartPar
In the attempt to resize the image to 450x450 you tried to overwrite
\sphinxcode{\sphinxupquote{recordings/salt\_logo\_small.jpg}}, a file that was given to DataLad
and thus protected by git\sphinxhyphen{}annex.

\index{unlock@\spxentry{unlock}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!unlock@\spxentry{unlock}}\index{unlock file@\spxentry{unlock file}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!unlock file@\spxentry{unlock file}}\ignorespaces 
\sphinxAtStartPar
There is a DataLad command that takes care of unlocking file content,
and thus making locked files modifiable again: \sphinxcode{\sphinxupquote{datalad unlock}}.
Let us check out what it does, and also compare that to the
\textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-unlocking-unlocked}} {\hyperref[\detokenize{basics/101-110-run2:ww-unlocking-unlocked}]{\sphinxcrossref{\DUrole{std,std-ref}{on an entirely different explanation}}}} (\autopageref*{\detokenize{basics/101-110-run2:ww-unlocking-unlocked}}).

\index{files are unlocked by default@\spxentry{files are unlocked by default}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!files are unlocked by default@\spxentry{files are unlocked by default}}\index{adjusted branch@\spxentry{adjusted branch}!unlocked files@\spxentry{unlocked files}}\ignorespaces \begin{windowswit}[label={ww-unlocking-unlocked}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{What happens if I run ‘datalad unlock’ on Windows?}
\label{\detokenize{basics/101-110-run2:ww-unlocking-unlocked}}

\sphinxAtStartPar
Nothing. All of the files in your dataset are always unlocked, and actually \sphinxstyleemphasis{cannot} be locked at all.
Consequently, there will be nothing to show for \sphinxcode{\sphinxupquote{datalad status}} afterwards (as shown a few paragraphs below).
This is due to a file system limitation, and will be explained in more detail in chapter {\hyperref[\detokenize{basics/basics-annex:chapter-gitannex}]{\sphinxcrossref{\DUrole{std,std-ref}{Under the hood: git\sphinxhyphen{}annex}}}} (\autopageref*{\detokenize{basics/basics-annex:chapter-gitannex}}).


\end{windowswit}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }unlock\PYG{+w}{ }recordings/salt\PYGZus{}logo\PYGZus{}small.jpg
\PYG{g+go}{unlock(ok): recordings/salt\PYGZus{}logo\PYGZus{}small.jpg (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Well, \sphinxcode{\sphinxupquote{unlock(ok)}} does not sound too bad for a start. As always, we
feel the urge to run a \sphinxcode{\sphinxupquote{datalad status}} on this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{ modified: recordings/salt\PYGZus{}logo\PYGZus{}small.jpg (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
“Ah, do not mind that for now”, our instructor says, and with a wink she
continues: “We’ll talk about symlinks and object trees a while later”.
You are not really sure whether that’s a good thing, but you have a task to focus
on. Hastily, you run the command right from the terminal:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }convert\PYG{+w}{ }\PYGZhy{}resize\PYG{+w}{ }450x450\PYG{+w}{ }recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg\PYG{+w}{ }recordings/salt\PYGZus{}logo\PYGZus{}small.jpg
\end{sphinxVerbatim}

\sphinxAtStartPar
Hey, no permission denied error! You note that the instructor still stands
right next to you. “Sooo… now what do I do to \sphinxstyleemphasis{lock} the file again?” you ask.

\sphinxAtStartPar
“Well… what you just did there was quite suboptimal. Didn’t you want to
use \sphinxcode{\sphinxupquote{datalad run}}? But, anyway, in order to lock the file again, you would need to
run a \sphinxcode{\sphinxupquote{datalad save}}.”

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}resized picture by hand\PYGZdq{}}
\PYG{g+go}{add(ok): recordings/salt\PYGZus{}logo\PYGZus{}small.jpg (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
“So”, you wonder aloud, “whenever I want to modify I need to
\sphinxcode{\sphinxupquote{datalad unlock}} it, do the modifications, and then \sphinxcode{\sphinxupquote{datalad save}} it?”

\sphinxAtStartPar
“Well, this is certainly one way of doing it, and a completely valid workflow
if you would do that outside of a \sphinxcode{\sphinxupquote{datalad run}} command.
But within \sphinxcode{\sphinxupquote{datalad run}} there is actually a much easier way of doing this.
Let’s use the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}} argument.”

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad run}} \sphinxstyleemphasis{retrieves} everything that is specified as \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}input}} prior to
command execution, and it \sphinxstyleemphasis{unlocks} everything specified as \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}} prior to
command execution. Therefore, whenever the output of a \sphinxcode{\sphinxupquote{datalad run}} command already
exists and is tracked, it should be specified as an argument in
the \sphinxcode{\sphinxupquote{\sphinxhyphen{}o}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}} option. See \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-output-glob}} {\hyperref[\detokenize{basics/101-110-run2:fom-output-glob}]{\sphinxcrossref{\DUrole{std,std-ref}{on dealing with many
outputs}}}} (\autopageref*{\detokenize{basics/101-110-run2:fom-output-glob}}).

\index{path globbing@\spxentry{path globbing}!with DataLad run@\spxentry{with DataLad run}}\index{with DataLad run@\spxentry{with DataLad run}!path globbing@\spxentry{path globbing}}\ignorespaces \begin{findoutmore}[label={fom-output-glob}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{But what if I have a lot of outputs?}
\label{\detokenize{basics/101-110-run2:fom-output-glob}}

\sphinxAtStartPar
The use case here is simplistic \textendash{} a single file gets modified.
But there are commands and tools that create full directories with
many files as an output.
The easiest way to specify this type of output
is by supplying the directory name, or the directory name and a {\hyperref[\detokenize{glossary:term-globbing}]{\sphinxtermref{\DUrole{xref,std,std-term}{globbing}}}} character, such as
\sphinxcode{\sphinxupquote{\sphinxhyphen{}o directory/*.dat}}.
This would unlock all files with a \sphinxcode{\sphinxupquote{.dat}} extension inside of \sphinxcode{\sphinxupquote{directory}}.
To glob for files in multiple levels of directories, use \sphinxcode{\sphinxupquote{**}} (a so\sphinxhyphen{}called \sphinxhref{https://www.linuxjournal.com/content/globstar-new-bash-globbing-option}{globstar}) for a recursive glob through any number directories.
And, just as for \sphinxcode{\sphinxupquote{\sphinxhyphen{}i}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}input}}, you could use multiple \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}} specifications.


\end{findoutmore}

\index{declare command output@\spxentry{declare command output}!with DataLad run@\spxentry{with DataLad run}}\index{with DataLad run@\spxentry{with DataLad run}!declare command output@\spxentry{declare command output}}\ignorespaces 
\sphinxAtStartPar
In order to execute \sphinxcode{\sphinxupquote{datalad run}} with both the \sphinxcode{\sphinxupquote{\sphinxhyphen{}i}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}input}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}o}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}}
flag and see their magic, let’s crop the second logo, \sphinxcode{\sphinxupquote{logo\_interval.jpg}}.
The \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-run-outputs}} {\hyperref[\detokenize{basics/101-110-run2:ww-run-outputs}]{\sphinxcrossref{\DUrole{std,std-ref}{on output declaration}}}} (\autopageref*{\detokenize{basics/101-110-run2:ww-run-outputs}}) clarifies the impact
of not doing so, when it is technically not needed.

\index{files are unlocked by default@\spxentry{files are unlocked by default}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!files are unlocked by default@\spxentry{files are unlocked by default}}\index{run@\spxentry{run}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!run@\spxentry{run}}\index{unlocked files@\spxentry{unlocked files}!in adjusted mode@\spxentry{in adjusted mode}}\index{in adjusted mode@\spxentry{in adjusted mode}!unlocked files@\spxentry{unlocked files}}\ignorespaces \begin{windowswit}[label={ww-run-outputs}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Wait, would I need to specify outputs, too?}
\label{\detokenize{basics/101-110-run2:ww-run-outputs}}

\sphinxAtStartPar
Given that nothing in your dataset is locked, is there a \sphinxstyleemphasis{need} for you to bother with creating \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}} flags?
Not for you personally, if you only stay on your Windows machine.
However, you will be doing others that you share your dataset with a favor if they are not using Windows \textendash{} should you or others want to rerun a run record, \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}} flags will make it work on all operating systems.


\end{windowswit}

\fvset{hllines={, 11,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Resize logo for slides\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}interval.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/interval\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}convert \PYGZhy{}resize 450x450 recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}interval.jpg recordings/interval\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}

\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} or shorter:}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Resize logo for slides\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}i\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}interval.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}o\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/interval\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}convert \PYGZhy{}resize 450x450 recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}interval.jpg recordings/interval\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}
\PYG{g+go}{get(ok): recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}interval.jpg (file) [from web...]}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{run(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 (dataset) [convert \PYGZhy{}resize 450x450 recordings/longn...]}
\PYG{g+go}{add(ok): recordings/interval\PYGZus{}logo\PYGZus{}small.jpg (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
This time, with both \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}input}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}}
options specified, DataLad informs about the \sphinxcode{\sphinxupquote{datalad get}}
operations it performs prior to the command
execution, and \sphinxcode{\sphinxupquote{datalad run}} executes the command successfully.
It does \sphinxstyleemphasis{not} inform about any \sphinxcode{\sphinxupquote{datalad unlock}} operation,
because the output \sphinxcode{\sphinxupquote{recordings/interval\_logo\_small.jpg}} does not
exist before the command is run. Should you rerun this command however,
the summary will include a statement about content unlocking. You will
see an example of this in the next section.

\sphinxAtStartPar
Note now how many individual commands a \sphinxcode{\sphinxupquote{datalad run}} saves us:
\sphinxcode{\sphinxupquote{datalad get}}, \sphinxcode{\sphinxupquote{datalad unlock}}, and \sphinxcode{\sphinxupquote{datalad save}}!
But even better: Beyond saving time \sphinxstyleemphasis{now}, running commands reproducibly and
recorded with \sphinxcode{\sphinxupquote{datalad run}} saves us plenty of time in the future as soon
as we want to rerun a command, or find out how a file came into existence.

\sphinxAtStartPar
With this last code snippet, you have experienced a full \sphinxcode{\sphinxupquote{datalad run}} command: commit message,
input and output definitions (the order in which you give those two options is irrelevant),
and the command to be executed. Whenever a command takes input or produces output you should specify
this with the appropriate option.

\sphinxAtStartPar
Make a note of this behavior in your \sphinxcode{\sphinxupquote{notes.txt}} file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }notes.txt
\PYG{g+go}{You should specify all files that a command takes as input with an}
\PYG{g+go}{\PYGZhy{}i/\PYGZhy{}\PYGZhy{}input flag. These files will be retrieved prior to the command}
\PYG{g+go}{execution. Any content that is modified or produced by the command}
\PYG{g+go}{should be specified with an \PYGZhy{}o/\PYGZhy{}\PYGZhy{}output flag. Upon a run or rerun of}
\PYG{g+go}{the command, the contents of these files will get unlocked so that}
\PYG{g+go}{they can be modified.}

\PYG{g+go}{EOT}
\end{sphinxVerbatim}


\subsection{Save yourself the preparation time}
\label{\detokenize{basics/101-110-run2:save-yourself-the-preparation-time}}
\sphinxAtStartPar
Its generally good practice to specify \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}input}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}} even if your input files are already retrieved and your output files unlocked \textendash{} it makes sure that a recomputation can succeed, even if inputs are not yet retrieved, or if output needs to be unlocked.
However, the internal preparation steps of checking that inputs exist or that outputs are unlocked can take a bit of time, especially if it involves checking a large number of files.

\sphinxAtStartPar
If you want to avoid the expense of unnecessary preparation steps you can make use of the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}assume\sphinxhyphen{}ready}} argument of \sphinxcode{\sphinxupquote{datalad run}}.
Depending on whether your inputs are already retrieved, your outputs already unlocked (or not needed to be unlocked), or both, specify \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}assume\sphinxhyphen{}ready}} with the argument \sphinxcode{\sphinxupquote{inputs}}, \sphinxcode{\sphinxupquote{outputs}} or \sphinxcode{\sphinxupquote{both}} and save yourself a few seconds, without sacrificing the ability to rerun your command under conditions in which the preparation would be necessary.


\subsection{Placeholders}
\label{\detokenize{basics/101-110-run2:placeholders}}
\sphinxAtStartPar
Just after writing the note, you had to relax your fingers a bit. “Man, this was
so much typing. Not only did I need to specify the inputs and outputs, I also had
to repeat all of these lengthy paths in the command line call…” you think.

\sphinxAtStartPar
There is a neat little trick to spare you half of this typing effort, though: \sphinxstyleemphasis{Placeholders}
for inputs and outputs. This is how it works:

\sphinxAtStartPar
Instead of running

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Resize logo for slides\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}interval.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/interval\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}convert \PYGZhy{}resize 450x450 recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}interval.jpg recordings/interval\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
you could shorten this to

\fvset{hllines={, 4,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Resize logo for slides\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}interval.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/interval\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}convert \PYGZhy{}resize 450x450 \PYGZob{}inputs\PYGZcb{} \PYGZob{}outputs\PYGZcb{}\PYGZdq{}}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
The placeholder \sphinxcode{\sphinxupquote{\{inputs\}}} will expand to the path given as \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}input}}, and
the placeholder \sphinxcode{\sphinxupquote{\{outputs\}}} will expand to the path given as \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}}.
This means instead of writing the full paths in the command, you can simply reuse
the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}input}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}} specification done before.
The \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-multiple-inoutputs}} {\hyperref[\detokenize{basics/101-110-run2:fom-multiple-inoutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{on dealing with multiple inputs and outputs}}}} (\autopageref*{\detokenize{basics/101-110-run2:fom-multiple-inoutputs}}) provides more details on the general usage of this feature.

\index{multiple command inputs@\spxentry{multiple command inputs}!with DataLad run@\spxentry{with DataLad run}}\index{with DataLad run@\spxentry{with DataLad run}!multiple command inputs@\spxentry{multiple command inputs}}\ignorespaces \begin{findoutmore}[label={fom-multiple-inoutputs}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{What if I have multiple inputs or outputs?}
\label{\detokenize{basics/101-110-run2:fom-multiple-inoutputs}}

\sphinxAtStartPar
If multiple values are specified, e.g., as in

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}move a few files around\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}file1\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}file2\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}file3\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}directory\PYGZus{}a/\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}mv \PYGZob{}inputs\PYGZcb{} \PYGZob{}outputs\PYGZcb{}\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
the values will be joined by a space like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}move a few files around\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}file1\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}file2\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}file3\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}directory\PYGZus{}a/\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}mv file1 file2 file3 directory\PYGZus{}a/\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The order of the values will match that order from the command line.

\sphinxAtStartPar
If you use globs for input specification, as in

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}move a few files around\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}file*\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}directory\PYGZus{}a/\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}mv \PYGZob{}inputs\PYGZcb{} \PYGZob{}outputs\PYGZcb{}\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
the globs will expanded in alphabetical order (like bash):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}move a few files around\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}file1\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}file2\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}file3\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}directory\PYGZus{}a/\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}mv file1 file2 file3 directory\PYGZus{}a/\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If the command only needs a subset of the inputs or outputs, individual values
can be accessed with an integer index, e.g., \sphinxcode{\sphinxupquote{\{inputs{[}0{]}\}}} for the very first
input.

\sphinxAtStartPar
Check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-run-curly}} {\hyperref[\detokenize{basics/101-110-run2:fom-run-curly}]{\sphinxcrossref{\DUrole{std,std-ref}{on how to deal with commands that include
\{ or \} for other purposes}}}} (\autopageref*{\detokenize{basics/101-110-run2:fom-run-curly}}).


\end{findoutmore}

\index{run command with curly brackets@\spxentry{run command with curly brackets}!with DataLad run@\spxentry{with DataLad run}}\index{with DataLad run@\spxentry{with DataLad run}!run command with curly brackets@\spxentry{run command with curly brackets}}\ignorespaces \begin{findoutmore}[label={fom-run-curly}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Wait, what if I need a curly bracket in my ‘datalad run’ call?}
\label{\detokenize{basics/101-110-run2:fom-run-curly}}

\sphinxAtStartPar
If your command call involves a \sphinxcode{\sphinxupquote{\{}} or \sphinxcode{\sphinxupquote{\}}} character, you will need to escape
this brace character by doubling it, i.e., \sphinxcode{\sphinxupquote{\{\{}} or \sphinxcode{\sphinxupquote{\}\}}}.


\end{findoutmore}

\index{dry\sphinxhyphen{}run@\spxentry{dry\sphinxhyphen{}run}!with DataLad run@\spxentry{with DataLad run}}\index{with DataLad run@\spxentry{with DataLad run}!dry\sphinxhyphen{}run@\spxentry{dry\sphinxhyphen{}run}}\ignorespaces 

\subsection{Dry\sphinxhyphen{}running your run call}
\label{\detokenize{basics/101-110-run2:dry-running-your-run-call}}\label{\detokenize{basics/101-110-run2:dryrun}}\label{\detokenize{basics/101-110-run2:index-13}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad run}} commands can become confusing and long, especially when you make heavy use of placeholders or wrap a complex bash commands.
To better anticipate what you will be running, or help debug a failed command, you can make use of the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dry\sphinxhyphen{}run}}  flag of \sphinxcode{\sphinxupquote{datalad run}}.
This option needs a mode specification (\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dry\sphinxhyphen{}run=basic}} or \sphinxcode{\sphinxupquote{dry\sphinxhyphen{}run=command}}), followed by the \sphinxcode{\sphinxupquote{run}} command you want to execute, and it will decipher the commands elements:
The mode \sphinxcode{\sphinxupquote{command}} will display the command that is about to be ran.
The mode \sphinxcode{\sphinxupquote{basic}} will report a few important details about the execution:
Apart from displaying the command that will be ran, you will learn \sphinxstyleemphasis{where} the command runs, what its \sphinxstyleemphasis{inputs} are (helpful if your \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}input}} specification includes a {\hyperref[\detokenize{glossary:term-globbing}]{\sphinxtermref{\DUrole{xref,std,std-term}{globbing}}}} term), and what its \sphinxstyleemphasis{outputs} are.

\sphinxstepscope

\index{provenance tracking@\spxentry{provenance tracking}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!provenance tracking@\spxentry{provenance tracking}}\ignorespaces 

\section{Clean desk}
\label{\detokenize{basics/101-112-run4:clean-desk}}\label{\detokenize{basics/101-112-run4:run5}}\label{\detokenize{basics/101-112-run4:index-0}}\label{\detokenize{basics/101-112-run4::doc}}
\sphinxAtStartPar
Just now you realize that you need to fit both logos onto the same slide.
“Ah, damn, I might then really need to have them 400 by 400 pixel to fit”,
you think. “Good that I know how to not run into the permission denied errors anymore!”

\sphinxAtStartPar
Therefore, we need to do the \sphinxcode{\sphinxupquote{datalad run}} command yet again \sphinxhyphen{} we wanted to have
the image in 400x400 px size. “Now this definitely will be the last time I’m running this”,
you think.

\fvset{hllines={, 5,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Resize logo for slides\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}interval.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/interval\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}convert \PYGZhy{}resize 400x400 recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}interval.jpg recordings/interval\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}
\PYG{g+go}{run(impossible): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 (dataset) [clean dataset required to detect changes from command; use `datalad status` to inspect unsaved changes]}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines


\subsection{Oh for f**** sake… run is “impossible”?}
\label{\detokenize{basics/101-112-run4:oh-for-f-sake-run-is-impossible}}
\sphinxAtStartPar
Weird. After the initial annoyance about yet another error message faded,
and you read on,
DataLad informs that a “clean dataset” is required.
Run a \sphinxcode{\sphinxupquote{datalad status}} to see what is meant by this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{ modified: notes.txt (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Ah right. We forgot to save the notes we added, and thus there are
unsaved modifications present in \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}.
But why is this a problem?

\sphinxAtStartPar
By default, at the end of a \sphinxcode{\sphinxupquote{datalad run}} is a \sphinxcode{\sphinxupquote{datalad save}}.
Remember the section {\hyperref[\detokenize{basics/101-102-populate:populate}]{\sphinxcrossref{\DUrole{std,std-ref}{Populate a dataset}}}} (\autopageref*{\detokenize{basics/101-102-populate:populate}}): A general \sphinxcode{\sphinxupquote{datalad save}} without
a path specification will save \sphinxstyleemphasis{all} of the modified or untracked
contents to the dataset.

\sphinxAtStartPar
Therefore, in order to not mix any changes in the dataset that are unrelated
to the command plugged into \sphinxcode{\sphinxupquote{datalad run}}, by default it will only run
on a clean dataset with no changes or untracked files present.

\sphinxAtStartPar
There are two ways to get around this error message:
The more obvious \textendash{} and recommended \textendash{} one is to save the modifications,
and run the command in a clean dataset.
We will try this way with the \sphinxcode{\sphinxupquote{logo\_interval.jpg}}.
It would look like this:
First, save the changes,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add additional notes on run options\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
and then try again:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Resize logo for slides\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}interval.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/interval\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}convert \PYGZhy{}resize 400x400 recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}interval.jpg recordings/interval\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}
\PYG{g+go}{unlock(ok): recordings/interval\PYGZus{}logo\PYGZus{}small.jpg (file)}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{run(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 (dataset) [convert \PYGZhy{}resize 400x400 recordings/longn...]}
\PYG{g+go}{add(ok): recordings/interval\PYGZus{}logo\PYGZus{}small.jpg (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note how in this execution of \sphinxcode{\sphinxupquote{datalad run}}, output unlocking was actually
necessary and DataLad provides a summary of this action in its output.

\sphinxAtStartPar
Add a quick addition to your notes about this way of cleaning up prior
to a \sphinxcode{\sphinxupquote{datalad run}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }notes.txt
\PYG{g+go}{Important! If the dataset is not \PYGZdq{}clean\PYGZdq{} (a datalad status output is}
\PYG{g+go}{empty), datalad run will not work \PYGZhy{} you will have to save}
\PYG{g+go}{modifications present in your dataset.}
\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\index{run command on dirty dataset@\spxentry{run command on dirty dataset}!with DataLad run@\spxentry{with DataLad run}}\index{with DataLad run@\spxentry{with DataLad run}!run command on dirty dataset@\spxentry{run command on dirty dataset}}\ignorespaces 
\sphinxAtStartPar
A way of executing a \sphinxcode{\sphinxupquote{datalad run}} \sphinxstyleemphasis{despite} an “unclean” dataset,
though, is to add the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}explicit}} flag to \sphinxcode{\sphinxupquote{datalad run}}.
We will try this flag with the remaining \sphinxcode{\sphinxupquote{logo\_salt.jpg}}. Note that
we have an “unclean dataset” again because of the
additional note in \sphinxcode{\sphinxupquote{notes.txt}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Resize logo for slides\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}recordings/salt\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}explicit\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdq{}convert \PYGZhy{}resize 400x400 recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg recordings/salt\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}
\PYG{g+go}{unlock(ok): recordings/salt\PYGZus{}logo\PYGZus{}small.jpg (file)}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{run(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 (dataset) [convert \PYGZhy{}resize 400x400 recordings/longn...]}
\PYG{g+go}{add(ok): recordings/salt\PYGZus{}logo\PYGZus{}small.jpg (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
With this flag, DataLad considers the specification of inputs and outputs to be “explicit”.
It does not warn if the repository is dirty, but importantly, it
\sphinxstylestrong{only} saves modifications to the \sphinxstyleemphasis{listed outputs} (which is a problem in the
vast amount of cases where one does not exactly know which outputs are produced).

\index{explicit input/output declaration@\spxentry{explicit input/output declaration}!with DataLad run@\spxentry{with DataLad run}}\index{with DataLad run@\spxentry{with DataLad run}!explicit input/output declaration@\spxentry{explicit input/output declaration}}\ignorespaces \begin{importantnote}[label={index-2}, before title={\thetcbcounter\ }, check odd page=true]{Put explicit first!}
\label{\detokenize{basics/101-112-run4:index-2}}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}explicit}} flag has to be given anywhere \sphinxstyleemphasis{prior} to the command that
should be run \textendash{} the command needs to be the last element of a
\sphinxcode{\sphinxupquote{datalad run}} call.


\end{importantnote}

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{datalad status}} will show that your previously modified \sphinxcode{\sphinxupquote{notes.txt}}
is still modified:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{ modified: notes.txt (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Add an additional note on the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}explicit}} flag, and finally save your changes to \sphinxcode{\sphinxupquote{notes.txt}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }notes.txt
\PYG{g+go}{A suboptimal alternative is the \PYGZhy{}\PYGZhy{}explicit flag, used to record only}
\PYG{g+go}{those changes done to the files listed with \PYGZhy{}\PYGZhy{}output flags.}

\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add note on clean datasets\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
To conclude this section on \sphinxcode{\sphinxupquote{datalad run}}, take a look at the last \sphinxcode{\sphinxupquote{datalad run}}
commit to see a {\hyperref[\detokenize{glossary:term-run-record}]{\sphinxtermref{\DUrole{xref,std,std-term}{run record}}}} with more content:

\fvset{hllines={, 10, 14, 15, 16, 17, 18, 19,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}p\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{2}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    [DATALAD RUNCMD] Resize logo for slides}

\PYG{g+go}{    === Do not change lines below ===}
\PYG{g+go}{    \PYGZob{}}
\PYG{g+go}{     \PYGZdq{}chain\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}cmd\PYGZdq{}: \PYGZdq{}convert \PYGZhy{}resize 400x400 recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg recordings/salt\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{},}
\PYG{g+go}{     \PYGZdq{}dsid\PYGZdq{}: \PYGZdq{}e3e70682\PYGZhy{}c209\PYGZhy{}4cac\PYGZhy{}629f\PYGZhy{}6fbed82c07cd\PYGZdq{},}
\PYG{g+go}{     \PYGZdq{}exit\PYGZdq{}: 0,}
\PYG{g+go}{     \PYGZdq{}extra\PYGZus{}inputs\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}inputs\PYGZdq{}: [}
\PYG{g+go}{      \PYGZdq{}recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg\PYGZdq{}}
\PYG{g+go}{     ],}
\PYG{g+go}{     \PYGZdq{}outputs\PYGZdq{}: [}
\PYG{g+go}{      \PYGZdq{}recordings/salt\PYGZus{}logo\PYGZus{}small.jpg\PYGZdq{}}
\PYG{g+go}{     ],}
\PYG{g+go}{     \PYGZdq{}pwd\PYGZdq{}: \PYGZdq{}.\PYGZdq{}}
\PYG{g+go}{    \PYGZcb{}}
\PYG{g+go}{    \PYGZca{}\PYGZca{}\PYGZca{} Do not change lines above \PYGZca{}\PYGZca{}\PYGZca{}}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/recordings/salt\PYGZus{}logo\PYGZus{}small.jpg b/recordings/salt\PYGZus{}logo\PYGZus{}small.jpg}
\PYG{g+go}{index 0985399..d90c601 120000}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} a/recordings/salt\PYGZus{}logo\PYGZus{}small.jpg}
\PYG{g+go}{+++ b/recordings/salt\PYGZus{}logo\PYGZus{}small.jpg}
\PYG{g+go}{@@ \PYGZhy{}1 +1 @@}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxstepscope


\section{Summary}
\label{\detokenize{basics/101-113-summary:summary}}\label{\detokenize{basics/101-113-summary:run6}}\label{\detokenize{basics/101-113-summary::doc}}
\sphinxAtStartPar
In the last four sections, we demonstrated how to create a proper \sphinxcode{\sphinxupquote{datalad run}}
command (\hyperref[\detokenize{basics/101-113-summary:fig-run-schema}]{Fig.\@ \ref{\detokenize{basics/101-113-summary:fig-run-schema}}}), and discovered the concept of \sphinxstyleemphasis{locked} content.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad run}} records and saves the changes a command makes in a dataset. That means
that modifications to existing content or new content are associated with a specific command
and saved to the dataset’s history. Essentially, \sphinxcode{\sphinxupquote{datalad run}} helps you to keep
track of what you do in your dataset by capturing all {\hyperref[\detokenize{glossary:term-provenance}]{\sphinxtermref{\DUrole{xref,std,std-term}{provenance}}}}.

\item {} 
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{datalad run}} command generates a \sphinxcode{\sphinxupquote{run record}} in the commit. This {\hyperref[\detokenize{glossary:term-run-record}]{\sphinxtermref{\DUrole{xref,std,std-term}{run record}}}} can be used
by DataLad to re\sphinxhyphen{}execute a command with \sphinxcode{\sphinxupquote{datalad rerun SHASUM}}, where SHASUM is the
commit hash of the \sphinxcode{\sphinxupquote{datalad run}} command that should be re\sphinxhyphen{}executed.

\item {} 
\sphinxAtStartPar
If a \sphinxcode{\sphinxupquote{datalad run}} or \sphinxcode{\sphinxupquote{datalad rerun}} does not modify any content, it will not write a
record to history.

\item {} 
\sphinxAtStartPar
With any \sphinxcode{\sphinxupquote{datalad run}}, specify a commit message, and whenever appropriate, specify its inputs
to the executed command (using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}i}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}input}} flag) and/or its output (using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}o}}/
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}} flag). The full command structure is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{    }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}commit message here\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{    }\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}path/to/input/\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{    }\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}path/to/output\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{    }\PYG{l+s+s2}{\PYGZdq{}command\PYGZdq{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Anything specified as \sphinxcode{\sphinxupquote{input}} will be retrieved if necessary with a \sphinxcode{\sphinxupquote{datalad get}} prior to command
execution. Anything specified as \sphinxcode{\sphinxupquote{output}} will be \sphinxcode{\sphinxupquote{unlocked}} prior to modifications.

\item {} 
\sphinxAtStartPar
It is good practice to specify \sphinxcode{\sphinxupquote{input}} and \sphinxcode{\sphinxupquote{output}} to ensure that a \sphinxcode{\sphinxupquote{datalad rerun}} works, and to capture the relevant elements of a computation in a machine\sphinxhyphen{}readable record.
If you want to spare yourself preparation time in case everything is already retrieved and unlocked, you can use \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}assume\sphinxhyphen{}ready \{input|output|both\}}} to skip a check on whether inputs are already present or outputs already unlocked.

\end{itemize}

\begin{figure}[tbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.800\linewidth]{{run}.pdf}
\caption{Overview of \sphinxcode{\sphinxupquote{datalad run}}.}\label{\detokenize{basics/101-113-summary:id1}}\label{\detokenize{basics/101-113-summary:fig-run-schema}}\end{figure}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Getting and unlocking content is not only convenient for yourself, but enormously helpful
for anyone you share your dataset with, but this will be demonstrated in an upcoming section
in detail.

\item {} 
\sphinxAtStartPar
To execute a \sphinxcode{\sphinxupquote{datalad run}} or \sphinxcode{\sphinxupquote{datalad rerun}}, a \sphinxcode{\sphinxupquote{datalad status}}
either needs to report that the dataset has no uncommitted changes (the dataset state
should be “clean”), or the command needs to be extended with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}explicit}} option.

\end{itemize}


\subsection{Now what can I do with that?}
\label{\detokenize{basics/101-113-summary:now-what-can-i-do-with-that}}
\sphinxAtStartPar
You have procedurally experienced how to use \sphinxcode{\sphinxupquote{datalad run}} and \sphinxcode{\sphinxupquote{datalad rerun}}. Both
of these commands make it easier for you and others to associate changes in a dataset with
a script or command, and are helpful as the exact command for a given task is stored by
DataLad, and does not need to be remembered.

\sphinxAtStartPar
Furthermore, by experiencing many common error messages in the context of \sphinxcode{\sphinxupquote{datalad run}}
commands, you have gotten some clues on where to look for problems, should you encounter
those errors in your own work.

\sphinxAtStartPar
Lastly, we’ve started to unveil some principles of {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} that are relevant to
understanding how certain commands work and why certain commands may fail. We have seen that
git\sphinxhyphen{}annex locks large files’ content to prevent accidental modifications, and how the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}}
flag in \sphinxcode{\sphinxupquote{datalad run}} can save us an intermediate \sphinxcode{\sphinxupquote{datalad unlock}} to unlock this content.
The next section will elaborate on this a bit more.


\subsection{Further reading}
\label{\detokenize{basics/101-113-summary:further-reading}}
\sphinxAtStartPar
The chapter on \sphinxcode{\sphinxupquote{datalad run}} provided an almost complete feature overview of the command.
If you want, you can extend this knowledge with computational environments and \sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}run}} in chapter {\hyperref[\detokenize{basics/101-133-containersrun:containersrun}]{\sphinxcrossref{\DUrole{std,std-ref}{Computational reproducibility with software containers}}}} (\autopageref*{\detokenize{basics/101-133-containersrun:containersrun}}).
In addition, you can read up on other forms of computing usecases \sphinxhyphen{} for example, how to use \sphinxcode{\sphinxupquote{datalad run}} in interactive computing environments such as \sphinxhref{https://knowledge-base.psychoinformatics.de/kbi/0003}{Jupyter Notebooks}.

\sphinxstepscope


\chapter{Under the hood: git\sphinxhyphen{}annex}
\label{\detokenize{basics/basics-annex:under-the-hood-git-annex}}\label{\detokenize{basics/basics-annex:chapter-gitannex}}\label{\detokenize{basics/basics-annex::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{security}.pdf}\hspace*{\fill}}

\sphinxstepscope


\section{Data safety}
\label{\detokenize{basics/101-114-txt2git:data-safety}}\label{\detokenize{basics/101-114-txt2git:text2git}}\label{\detokenize{basics/101-114-txt2git::doc}}
\sphinxAtStartPar
Later in the day, after seeing and solving so many DataLad error messages,
you fall tired into your
bed. Just as you are about to fall asleep, a thought crosses your mind:

\sphinxAtStartPar
“I now know that tracked content in a dataset is protected by {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}.
Whenever tracked contents are \sphinxcode{\sphinxupquote{saved}}, they get locked and should not be
modifiable. But… what about the notes that I have been taking since the first day?
Should I not need to unlock them before I can modify them? And also the script!
I was able to modify this despite giving it to DataLad to track, with
no permission denied errors whatsoever! How does that work?”

\sphinxAtStartPar
This night, though, your question stays unanswered and you fall into a restless
sleep filled with bad dreams about “permission denied” errors. The next day you are
the first student in your lecturer’s office hours.

\sphinxAtStartPar
“Oh, you are really attentive. This is a great question!” our lecturer starts
to explain.

\index{dataset procedure@\spxentry{dataset procedure}!text2git@\spxentry{text2git}|spxpagem}\ignorespaces 
\sphinxAtStartPar
Do you remember that we created the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset with a
specific configuration template? It was the \sphinxcode{\sphinxupquote{\sphinxhyphen{}c text2git}} option we
provided in the beginning of {\hyperref[\detokenize{basics/101-101-create:createds}]{\sphinxcrossref{\DUrole{std,std-ref}{Create a dataset}}}} (\autopageref*{\detokenize{basics/101-101-create:createds}}). It is because of this configuration
that we can modify \sphinxcode{\sphinxupquote{notes.txt}} without unlocking its content first.

\sphinxAtStartPar
The second commit message in our datasets history summarizes this (outputs are shortened):

\fvset{hllines={, 3,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}reverse\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{4ce681d [DATALAD] new dataset}
\PYG{g+go}{e0ff3a7 Instruct annex to add text files to Git}
\PYG{g+go}{b40316a add books on Python and Unix to read later}
\PYG{g+go}{a875e49 add reference book about git}
\PYG{g+go}{59ac8d3 add beginners guide on bash}
\PYG{g+go}{874d766 Add notes on datalad create}
\PYG{g+go}{e310b46 add note on datalad save}
\PYG{g+go}{3c016f7 [DATALAD] Added subdataset}
\PYG{g+go}{87609a3 Add note on datalad clone}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Instead of giving text files such as your notes or your script
to git\sphinxhyphen{}annex, the dataset stores it in {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}}.
But what does it mean if files are in Git instead of git\sphinxhyphen{}annex?

\sphinxAtStartPar
Well, procedurally it means that everything that is stored in git\sphinxhyphen{}annex is
content\sphinxhyphen{}locked, and everything that is stored in Git is not. You can modify
content stored in Git straight away, without unlocking it first.
This is easy enough, and illustrated in \hyperref[\detokenize{basics/101-114-txt2git:fig-gitvsannex}]{Fig.\@ \ref{\detokenize{basics/101-114-txt2git:fig-gitvsannex}}}.

\begin{figure}[tbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{git_vs_gitannex}.pdf}
\caption{A simplified overview of the tools that manage data in your dataset.}\label{\detokenize{basics/101-114-txt2git:id2}}\label{\detokenize{basics/101-114-txt2git:fig-gitvsannex}}\end{figure}

\sphinxAtStartPar
“So, first of all: If we hadn’t provided the \sphinxcode{\sphinxupquote{\sphinxhyphen{}c text2git}} argument, text files
would get content\sphinxhyphen{}locked, too?”. “Yes, indeed. However, there are also ways to
later change how file content is handled based on its type or size. It can be specified
in the \sphinxcode{\sphinxupquote{.gitattributes}} file, using \sphinxcode{\sphinxupquote{annex.largefile}} options.
But there will be a lecture on that%
\begin{footnote}[1]\sphinxAtStartFootnote
If you cannot wait to read about \sphinxcode{\sphinxupquote{.gitattributes}} and other
configuration files, jump ahead to chapter {\hyperref[\detokenize{basics/basics-configuration:chapter-config}]{\sphinxcrossref{\DUrole{std,std-ref}{Tuning datasets to your needs}}}} (\autopageref*{\detokenize{basics/basics-configuration:chapter-config}}),
starting with section {\hyperref[\detokenize{basics/101-122-config:config}]{\sphinxcrossref{\DUrole{std,std-ref}{Local configuration}}}} (\autopageref*{\detokenize{basics/101-122-config:config}}).
%
\end{footnote}.”

\sphinxAtStartPar
“Okay, well, second: Isn’t it much easier to just not bother with locking and
unlocking, and have everything ‘stored in Git’? Even if \sphinxcode{\sphinxupquote{datalad run}} takes care
of unlocking content, I do not see the point of git\sphinxhyphen{}annex”, you continue.

\sphinxAtStartPar
Here it gets tricky. To begin with the most important, and most straight\sphinxhyphen{}forward fact:
It is not possible to store
large files in Git. This is because Git would very quickly run into severe performance
issues. And hosting sites for projects using Git, such as {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}} or {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}
also do not allow files larger than a few dozen MB of size.

\sphinxAtStartPar
For now, we have solved the mystery of why text files can be modified
without unlocking, and this is a small
improvement in the vast amount of questions that have piled up in our curious
minds. Essentially, git\sphinxhyphen{}annex protects your data from accidental modifications
and thus keeps it safe. \sphinxcode{\sphinxupquote{datalad run}} commands mitigate any technical
complexity of this completely if \sphinxcode{\sphinxupquote{\sphinxhyphen{}o/\sphinxhyphen{}\sphinxhyphen{}output}} is specified properly, and
\sphinxcode{\sphinxupquote{datalad unlock}} commands can be used to unlock content “by hand” if
modifications are performed outside of a \sphinxcode{\sphinxupquote{datalad run}}.

\index{adjusted mode@\spxentry{adjusted mode}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!adjusted mode@\spxentry{adjusted mode}}\ignorespaces 
\sphinxAtStartPar
But there comes the second, tricky part: There are ways to get rid of locking and
unlocking within git\sphinxhyphen{}annex, using so\sphinxhyphen{}called {\hyperref[\detokenize{glossary:term-adjusted-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{adjusted branch}}}}es.
This functionality is dependent on the git\sphinxhyphen{}annex version one has installed, the git\sphinxhyphen{}annex version of the repository, and a use\sphinxhyphen{}case dependent comparison of the pros and cons.
On Windows systems, this {\hyperref[\detokenize{glossary:term-adjusted-mode}]{\sphinxtermref{\DUrole{xref,std,std-term}{adjusted mode}}}} is even the \sphinxstyleemphasis{only} mode of operation.
In later sections we will see how to use this feature.
The next lecture, in any way, will guide us deeper into git\sphinxhyphen{}annex, and improve our understanding a slight bit further.

\sphinxstepscope

\index{data file handling@\spxentry{data file handling}!with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}}\index{with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}!data file handling@\spxentry{data file handling}}\ignorespaces 

\section{Data integrity}
\label{\detokenize{basics/101-115-symlinks:data-integrity}}\label{\detokenize{basics/101-115-symlinks:symlink}}\label{\detokenize{basics/101-115-symlinks:id1}}\label{\detokenize{basics/101-115-symlinks:index-0}}\label{\detokenize{basics/101-115-symlinks::doc}}
\sphinxAtStartPar
So far, we mastered quite a number of challenges:
Creating and populating a dataset with large and small files, modifying content and saving the changes to history, installing datasets, even as subdatasets within datasets, recording the impact of commands on a dataset with the \sphinxcode{\sphinxupquote{datalad run}} and \sphinxcode{\sphinxupquote{datalad rerun}} commands, and capturing plenty of {\hyperref[\detokenize{glossary:term-provenance}]{\sphinxtermref{\DUrole{xref,std,std-term}{provenance}}}} on the way.
We further noticed that when we modified content in \sphinxcode{\sphinxupquote{notes.txt}} or \sphinxcode{\sphinxupquote{list\_titles.sh}}, the modified content was in a \sphinxstyleemphasis{text file}.
We learned that this precise type of file, in conjunction with the initial configuration template \sphinxcode{\sphinxupquote{text2git}} we gave to \sphinxcode{\sphinxupquote{datalad create}}, is meaningful:
As the text file is stored in Git and not git\sphinxhyphen{}annex, no content unlocking is necessary.
As we saw within the demonstrations of \sphinxcode{\sphinxupquote{datalad run}}, modifying content of non\sphinxhyphen{}text files, such as \sphinxcode{\sphinxupquote{.jpg}}s, typically requires the additional step of \sphinxstyleemphasis{unlocking} file content, either by hand with the \sphinxcode{\sphinxupquote{datalad unlock}} command, or within \sphinxcode{\sphinxupquote{datalad run}} using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}o}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}} flag.

\sphinxAtStartPar
There is one detail about DataLad datasets that we have not covered yet.
It is a crucial component to understanding certain aspects of a dataset, but it is also a potential source of confusion that we want to eradicate.

\sphinxAtStartPar
You might have noticed already that an \sphinxcode{\sphinxupquote{ls \sphinxhyphen{}l}} or \sphinxcode{\sphinxupquote{tree}} command in your dataset shows small arrows and quite cryptic paths following each non\sphinxhyphen{}text file.
Maybe your shell also displays these files in a different color than text files when listing them.
We’ll take a look together, using the \sphinxcode{\sphinxupquote{books/}} directory as an example.
Also check the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-directories}} {\hyperref[\detokenize{basics/101-115-symlinks:ww-directories}]{\sphinxcrossref{\DUrole{std,std-ref}{on directory appearance}}}} (\autopageref*{\detokenize{basics/101-115-symlinks:ww-directories}}) for comparison:

\index{no symlinks@\spxentry{no symlinks}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!no symlinks@\spxentry{no symlinks}}\index{tree@\spxentry{tree}!terminal command@\spxentry{terminal command}}\index{terminal command@\spxentry{terminal command}!tree@\spxentry{tree}}\ignorespaces \begin{windowswit}[label={ww-directories}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Dataset directories look different on Windows}
\label{\detokenize{basics/101-115-symlinks:ww-directories}}

\sphinxAtStartPar
First of all, the Windows \sphinxcode{\sphinxupquote{tree}} command lists only directories by default, unless you parametrize it with \sphinxcode{\sphinxupquote{/f}}.
And, secondly, even if you list the individual files, you would not see the {\hyperref[\detokenize{glossary:term-symlink}]{\sphinxtermref{\DUrole{xref,std,std-term}{symlink}}}}s shown below.
Due to insufficient support for symlinks on Windows, git\sphinxhyphen{}annex does not use them.
The \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-adjusted-mode}} {\hyperref[\detokenize{basics/101-115-symlinks:ww-adjusted-mode}]{\sphinxcrossref{\DUrole{std,std-ref}{on git\sphinxhyphen{}annex\textquotesingle{}s adjusted mode}}}} (\autopageref*{\detokenize{basics/101-115-symlinks:ww-adjusted-mode}}) has more on that.


\end{windowswit}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} in the root of DataLad\PYGZhy{}101}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }books
\PYG{g+gp}{\PYGZdl{} }tree
\PYG{g+go}{.}
\PYG{g+go}{├── bash\PYGZus{}guide.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/WF/Gq/✂/MD5E\PYGZhy{}s1198170\PYGZhy{}\PYGZhy{}0ab2c121✂MD5.pdf}
\PYG{g+go}{├── byte\PYGZhy{}of\PYGZhy{}python.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/xF/42/✂/MD5E\PYGZhy{}s4161086\PYGZhy{}\PYGZhy{}c832fc13✂MD5.pdf}
\PYG{g+go}{├── progit.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/G6/Gj/✂/MD5E\PYGZhy{}s12465653\PYGZhy{}\PYGZhy{}05cd7ed5✂MD5.pdf}
\PYG{g+go}{└── TLCL.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}

\PYG{g+go}{0 directories, 4 files}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you do not know what you are looking at,
this looks weird, if not worse: intimidating, wrong, or broken.
First of all: no, \sphinxstylestrong{it is all fine}. But let’s start with the basics of what is displayed
here to understand it.

\sphinxAtStartPar
The small \sphinxcode{\sphinxupquote{\sphinxhyphen{}\textgreater{}}} symbol connecting one path (the book’s name) to another path (the weird
sequence of characters ending in \sphinxcode{\sphinxupquote{.pdf}}) is what is called a
\sphinxstyleemphasis{symbolic link}, {\hyperref[\detokenize{glossary:term-symlink}]{\sphinxtermref{\DUrole{xref,std,std-term}{symlink}}}} or \sphinxstyleemphasis{softlink} for short.
It is a term for any file that contains a reference to another file or directory as
a {\hyperref[\detokenize{glossary:term-relative-path}]{\sphinxtermref{\DUrole{xref,std,std-term}{relative path}}}} or {\hyperref[\detokenize{glossary:term-absolute-path}]{\sphinxtermref{\DUrole{xref,std,std-term}{absolute path}}}}.
If you use Windows, you are familiar with a related, although more basic concept: a shortcut. But see the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-adjusted-mode}} {\hyperref[\detokenize{basics/101-115-symlinks:ww-adjusted-mode}]{\sphinxcrossref{\DUrole{std,std-ref}{on how the actual behavior is there}}}} (\autopageref*{\detokenize{basics/101-115-symlinks:ww-adjusted-mode}}).

\sphinxAtStartPar
This means that the files that are in the locations in which you saved content
and are named as you named your files (e.g., \sphinxcode{\sphinxupquote{TLCL.pdf}}),
do \sphinxstyleemphasis{not actually contain your files’ content}:
they just point to the place where the actual file content resides.

\sphinxAtStartPar
This sounds weird, and like an unnecessary complication of things. But we will
get to why this is relevant and useful shortly. First, however,
where exactly are the contents of the files you created or saved?

\sphinxAtStartPar
The start of the link path is \sphinxcode{\sphinxupquote{../.git}}. The section {\hyperref[\detokenize{basics/101-101-create:createds}]{\sphinxcrossref{\DUrole{std,std-ref}{Create a dataset}}}} (\autopageref*{\detokenize{basics/101-101-create:createds}}) contained
a note that strongly advised that you to not tamper with
(or in the worst case, delete) the \sphinxcode{\sphinxupquote{.git}}
repository in the root of any dataset. One reason
why you should not do this is because \sphinxstyleemphasis{this} \sphinxcode{\sphinxupquote{.git}} directory is where all of your file content
is actually stored.

\sphinxAtStartPar
But why is that? We have to talk a bit git\sphinxhyphen{}annex now in order to understand it.

\sphinxAtStartPar
When a file is saved into a dataset to be tracked,
by default \textendash{} that is in a dataset created without any configuration template \textendash{}
DataLad gives this file to git\sphinxhyphen{}annex. Exceptions to this behavior can be
defined based on
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
file size

\item {} 
\sphinxAtStartPar
and/or path/pattern, and thus, for example, file extensions,
or names, or file types (e.g., text files, as with the
\sphinxcode{\sphinxupquote{text2git}} configuration template).

\end{enumerate}

\sphinxAtStartPar
git\sphinxhyphen{}annex, in order to version control the data, takes the file content
and moves it under \sphinxcode{\sphinxupquote{.git/annex/objects}} \textendash{} the so called {\hyperref[\detokenize{glossary:term-object-tree}]{\sphinxtermref{\DUrole{xref,std,std-term}{object\sphinxhyphen{}tree}}}}.
It further renames the file into the sequence of characters you can see
in the path, and in its place
creates a symlink with the original file name, pointing to the new location.
This process is often referred to as a file being \sphinxstyleemphasis{annexed}, and the object
tree is also known as the \sphinxstyleemphasis{annex} of a dataset.

\index{elevated storage demand@\spxentry{elevated storage demand}!in adjusted mode@\spxentry{in adjusted mode}}\index{in adjusted mode@\spxentry{in adjusted mode}!elevated storage demand@\spxentry{elevated storage demand}}\index{no symlinks@\spxentry{no symlinks}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!no symlinks@\spxentry{no symlinks}}\index{adjusted mode@\spxentry{adjusted mode}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!adjusted mode@\spxentry{adjusted mode}}\ignorespaces \begin{windowswit}[label={ww-adjusted-mode}, before title={\thetcbcounter\ }, float, floatplacement=tbp, check odd page=true]{File content management on Windows (adjusted mode)}
\label{\detokenize{basics/101-115-symlinks:ww-adjusted-mode}}

\sphinxAtStartPar
Windows has insufficient support for {\hyperref[\detokenize{glossary:term-symlink}]{\sphinxtermref{\DUrole{xref,std,std-term}{symlink}}}}s and revoking write {\hyperref[\detokenize{glossary:term-permissions}]{\sphinxtermref{\DUrole{xref,std,std-term}{permissions}}}} on files.
Therefore, {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} classifies it as a {\hyperref[\detokenize{glossary:term-crippled-file-system}]{\sphinxtermref{\DUrole{xref,std,std-term}{crippled file system}}}} and has to stray from its default behavior: it enters {\hyperref[\detokenize{glossary:term-adjusted-mode}]{\sphinxtermref{\DUrole{xref,std,std-term}{adjusted mode}}}}.
While git\sphinxhyphen{}annex on Unix\sphinxhyphen{}based file operating systems stores data in the annex and creates a symlink in the data’s original place, on Windows it moves data into the {\hyperref[\detokenize{glossary:term-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{annex}}}} and creates a \sphinxstyleemphasis{copy} of the data in its original place. This behavior is not specific to Windows, but is done for any impaired file system, such as a dataset on a USB\sphinxhyphen{}stick plugged into a Mac.

\sphinxAtStartPar
\sphinxstylestrong{Why is that?}
Data \sphinxstyleemphasis{needs} to be in the annex for version control and transport logistics \textendash{} the annex is able to store all previous versions of the data, and manage the transport to other storage locations if you want to publish your dataset.
But as the {\hyperref[\detokenize{basics/101-115-symlinks:fom-objecttree}]{\sphinxcrossref{\DUrole{std,std-ref}{Findoutmore in this section}}}} (\autopageref*{\detokenize{basics/101-115-symlinks:fom-objecttree}}) shows, the {\hyperref[\detokenize{glossary:term-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{annex}}}} is a non\sphinxhyphen{}human readable tree structure, and data thus also needs to exist in its original location.
Thus, it exists in both places: it has moved into the annex, and copied back into its original location.
Once you edit an annexed file, the most recent version of the file is available in its original location, and past versions are stored and readily available in the annex.
If you reset your dataset to a previous state, as is shown in the section {\hyperref[\detokenize{basics/101-137-history:history}]{\sphinxcrossref{\DUrole{std,std-ref}{Git things done}}}} (\autopageref*{\detokenize{basics/101-137-history:history}}), the respective version of your data is taken from the annex and copied to replace the newer version, and vice versa.

\sphinxAtStartPar
\sphinxstylestrong{But doesn’t a copy mean data duplication?}
Yes, absolutely!
And that is a big downside to DataLad and {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} on Windows.
If you have a dataset with annexed file contents (be that a dataset you created and populated yourself, or one that you cloned and got file contents with \sphinxcode{\sphinxupquote{datalad get}} from), it will take up more space than on a Unix\sphinxhyphen{}based system.
How much more?
Every file that exists in your file hierarchy exists twice.
A fresh dataset with one version of each file is thus twice as big as it would be on a Linux computer.
Any past version of data does not exist in duplication.

\sphinxAtStartPar
\sphinxstylestrong{Step\sphinxhyphen{}by\sphinxhyphen{}step demonstration}:
Let’s take a concrete example to explain the last point in more detail.
How much space, do you think, is taken up in your dataset by the resized \sphinxcode{\sphinxupquote{salt\_logo\_small.jpg}} image?
As a reminder: It exists in two versions, a 400 by 400 pixel version (about 250Kb in size), and a 450 by 450 pixel version (about 310Kb in size).
The 400 by 400 pixel version is the most recent one.
The answer is: about 810Kb (\textasciitilde{}0.8 MB).
The most recent 400x400px version exists twice (in the annex and as a copy), and the 450x450px copy exists once in the annex.
If you would reset your dataset to the state when we created the 450x450px version, this file would instead exist twice.

\index{unused@\spxentry{unused}!git\sphinxhyphen{}annex command@\spxentry{git\sphinxhyphen{}annex command}}\index{git\sphinxhyphen{}annex command@\spxentry{git\sphinxhyphen{}annex command}!unused@\spxentry{unused}}\index{dropunused@\spxentry{dropunused}!git\sphinxhyphen{}annex command@\spxentry{git\sphinxhyphen{}annex command}}\index{git\sphinxhyphen{}annex command@\spxentry{git\sphinxhyphen{}annex command}!dropunused@\spxentry{dropunused}}\ignorespaces 
\sphinxAtStartPar
\sphinxstylestrong{Can I at least get unused or irrelevant data out of the dataset?}
Yes, either with convenience commands (e.g., \sphinxcode{\sphinxupquote{git annex unused}} followed by \sphinxcode{\sphinxupquote{git annex dropunused}}), or by explicitly using \sphinxcode{\sphinxupquote{drop}} on files (or their past versions) that you don’t want to keep anymore.
Alternatively, you can transfer data you don’t need but want to preserve to a different storage location.
Later parts of the book will demonstrate each of these alternatives.


\end{windowswit}

\sphinxAtStartPar
For a demonstration that this file path is not complete gibberish,
take the target path of any of the book’s symlinks and
open it, for example with \sphinxcode{\sphinxupquote{evince \textless{}path\textgreater{}}}, or any other PDF reader in exchange for \sphinxcode{\sphinxupquote{evince}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{evince ../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
Even though the path looks cryptic, it works and opens the file. Whenever you
use a command like \sphinxcode{\sphinxupquote{evince TLCL.pdf}}, internally, programs will follow
the same cryptic symlink like the one you have just opened.

\sphinxAtStartPar
But \sphinxstyleemphasis{why} does this symlink\sphinxhyphen{}ing happen? Up until now, it still seems like a very
unnecessary, superfluous thing to do, right?

\sphinxAtStartPar
The resulting symlinks that look like
your files but only point to the actual content in \sphinxcode{\sphinxupquote{.git/annex/objects}} are
small in size. An \sphinxcode{\sphinxupquote{ls \sphinxhyphen{}lh}} reveals that all of these symlinks have roughly the same,
small size of \textasciitilde{}130 Bytes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}lh
\PYG{g+go}{total 16K}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 131 2019\PYGZhy{}06\PYGZhy{}18 16:13 bash\PYGZus{}guide.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/WF/Gq/✂/MD5E\PYGZhy{}s1198170\PYGZhy{}\PYGZhy{}0ab2c121✂MD5.pdf}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 131 2019\PYGZhy{}06\PYGZhy{}18 16:13 byte\PYGZhy{}of\PYGZhy{}python.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/xF/42/✂/MD5E\PYGZhy{}s4161086\PYGZhy{}\PYGZhy{}c832fc13✂MD5.pdf}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 133 2019\PYGZhy{}06\PYGZhy{}18 16:13 progit.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/G6/Gj/✂/MD5E\PYGZhy{}s12465653\PYGZhy{}\PYGZhy{}05cd7ed5✂MD5.pdf}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 131 2019\PYGZhy{}06\PYGZhy{}18 16:13 TLCL.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here you can see the reason why content is symlinked: Small file size means that
\sphinxstyleemphasis{Git can handle those symlinks}!
Therefore, instead of large file content, only the symlinks are committed into
Git, and the Git repository thus stays lean. Simultaneously, still, all
files stored in Git as symlinks can point to arbitrarily large files in the
object tree. Within the object tree, git\sphinxhyphen{}annex handles file content tracking,
and is busy creating and maintaining appropriate symlinks so that your data
can be version controlled just as any text file.

\sphinxAtStartPar
This comes with two very important advantages:

\sphinxAtStartPar
One, should you have copies of the
same data in different places of your dataset, the symlinks of these files
point to the same place \sphinxhyphen{} in order to understand why this is the case, you
will need to read the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-objecttree}} {\hyperref[\detokenize{basics/101-115-symlinks:fom-objecttree}]{\sphinxcrossref{\DUrole{std,std-ref}{on how git\sphinxhyphen{}annex manages file content}}}} (\autopageref*{\detokenize{basics/101-115-symlinks:fom-objecttree}}).
Therefore, any amount of copies of a piece of data
is only one single piece of data in your object tree. This, depending on
how much identical file content lies in different parts of your dataset,
can save you much disk space and time.

\sphinxAtStartPar
The second advantage is less intuitive but clear for users familiar with Git.
Compared to copying and deleting huge data files, small symlinks can be written very very fast, for example, when switching dataset versions, or {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}}es.
\begin{gitusernote}[before title={\thetcbcounter\ }, check odd page=true]{Speedy branch switches}

\sphinxAtStartPar
Switching branches fast, even when they track vasts amounts of data, lets you work with data using the same routines as in software development workflows.


\end{gitusernote}

\sphinxAtStartPar
This leads to a few conclusions:

\sphinxAtStartPar
The first is that you should not be worried
to see cryptic looking symlinks in your repository \textendash{} this is how it should look.
Again, you can read the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-objecttree}} {\hyperref[\detokenize{basics/101-115-symlinks:fom-objecttree}]{\sphinxcrossref{\DUrole{std,std-ref}{on why these paths look so weird}}}} (\autopageref*{\detokenize{basics/101-115-symlinks:fom-objecttree}}) and what all of this has to do with data integrity, if you want to.
It has additional information that can help to establish trust in that your data are safely stored and tracked, and understanding more about the object tree and knowing bits of the git\sphinxhyphen{}annex basics can make you more confident in working with your datasets.

\sphinxAtStartPar
The second is that it should now be clear to you why the \sphinxcode{\sphinxupquote{.git}} directory
should not be deleted or in any way modified by hand. This place is where
your data are stored, and you can trust git\sphinxhyphen{}annex to be better able to
work with the paths in the object tree than you or any other human are.

\sphinxAtStartPar
Lastly, understanding that annexed files in your dataset are symlinked
will be helpful to understand how common file system operations such as
moving, renaming, or copying content translate to dataset modifications
in certain situations. Later in this book, the section {\hyperref[\detokenize{basics/101-136-filesystem:file-system}]{\sphinxcrossref{\DUrole{std,std-ref}{Dataset ops}}}} (\autopageref*{\detokenize{basics/101-136-filesystem:file-system}})
will take a closer look at that.

\index{key@\spxentry{key}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!key@\spxentry{key}}\ignorespaces \phantomsection\label{\detokenize{basics/101-115-symlinks:objecttree}}\begin{findoutmore}[label={fom-objecttree}, before title={\thetcbcounter\ }, float, floatplacement=tbp, check odd page=true]{Data integrity and annex keys}
\label{\detokenize{basics/101-115-symlinks:fom-objecttree}}

\sphinxAtStartPar
So how do these cryptic paths and names in the object tree come into existence?
It’s not malicious intent that leads to these paths and file names \sphinxhyphen{} its checksums.

\sphinxAtStartPar
When a file is annexed, git\sphinxhyphen{}annex typically generates a \sphinxstyleemphasis{key} (or {\hyperref[\detokenize{glossary:term-annex-key}]{\sphinxtermref{\DUrole{xref,std,std-term}{annex key}}}}) from the \sphinxstylestrong{file content}.
It uses this key (in part) as a name for the file and as the path
in the object tree.
Thus, the key is associated with the content of the file (the \sphinxstyleemphasis{value}),
and therefore, using this key, file content can be identified.

\sphinxAtStartPar
Most key types contain a {\hyperref[\detokenize{glossary:term-checksum}]{\sphinxtermref{\DUrole{xref,std,std-term}{checksum}}}}. This is a string of a fixed number of characters
computed from some input, for example the content of a PDF file,
by a \sphinxstyleemphasis{hash} function.

\sphinxAtStartPar
This checksum \sphinxstyleemphasis{uniquely} identifies a file’s content.
A hash function will generate the same character sequence for the same file content, and once file content changes, the generated checksum changes, too.
Basing the file name on its contents thus becomes a way of ensuring data integrity:
File content cannot be changed without git\sphinxhyphen{}annex noticing, because the file’s checksum, and thus its key in its symlink, will change.
Furthermore, if two files have identical checksums, the content in these files is identical.
Consequently, if two files have the same symlink, and thus link the same file in the object\sphinxhyphen{}tree, they are identical in content.
This can save disk space if a dataset contains many identical files: Copies of the same data only need one instance of that content in the object tree, and all copies will symlink to it.
If you want to read more about the computer science basics about hash functions check out the \sphinxhref{https://en.wikipedia.org/wiki/Hash\_function}{Wikipedia page}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} take a look at the last part of the target path:}
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}lh\PYG{+w}{ }TLCL.pdf
\PYG{g+go}{lrwxrwxrwx 1 elena elena 131 2019\PYGZhy{}06\PYGZhy{}18 16:13 TLCL.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s take a closer look at the structure of the symlink.
The key from the hash function is the last part of the name of the file the symlink links to (in which the actual data content is stored).

\index{compute checksum@\spxentry{compute checksum}!in a terminal@\spxentry{in a terminal}}\index{in a terminal@\spxentry{in a terminal}!compute checksum@\spxentry{compute checksum}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-115-symlinks:index-5}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} compare it to the checksum (here of type md5sum) of the PDF file and the subdirectory name}
\PYG{g+gp}{\PYGZdl{} }md5sum\PYG{+w}{ }TLCL.pdf
\PYG{g+go}{06d1efcb✂MD5  TLCL.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
The extension (e.g., \sphinxcode{\sphinxupquote{.pdf}}) is appended, because some programs require it, and would fail when not working directly with the symlink, but the file that it points to.
Right at the beginning, the symlink starts with two directories just after \sphinxcode{\sphinxupquote{.git/annex/objects/}},
consisting of two letters each.
These two letters are derived from the md5sum of the key, and their sole purpose to exist is to avoid issues with too many files in one directory (which is a situation that certain file systems have problems with).
The next subdirectory in the symlink helps to prevent accidental deletions and changes, as it does not have write {\hyperref[\detokenize{glossary:term-permissions}]{\sphinxtermref{\DUrole{xref,std,std-term}{permissions}}}}, so that users cannot modify any of its underlying contents.
This is the reason that annexed files need to be unlocked prior to modifications, and this information will be helpful to understand some file system management operations such as removing files or datasets. Section {\hyperref[\detokenize{basics/101-136-filesystem:file-system}]{\sphinxcrossref{\DUrole{std,std-ref}{Dataset ops}}}} (\autopageref*{\detokenize{basics/101-136-filesystem:file-system}}) takes a look at that.

\sphinxAtStartPar
The next part of the symlink contains the actual checksum.
There are different {\hyperref[\detokenize{glossary:term-annex-key}]{\sphinxtermref{\DUrole{xref,std,std-term}{annex key}}}} backends that use different checksums.
Depending on which is used, the resulting {\hyperref[\detokenize{glossary:term-checksum}]{\sphinxtermref{\DUrole{xref,std,std-term}{checksum}}}} has a certain length and structure, and the first part of the symlink actually states which hash function is used.
By default, DataLad uses the \sphinxcode{\sphinxupquote{MD5E}} git\sphinxhyphen{}annex backend (the \sphinxcode{\sphinxupquote{E}} adds file extensions to annex keys), but should you want to, you can change this default to \sphinxhref{https://git-annex.branchable.com/backends}{one of many other types}.
The reason why MD5E is used is the relatively short length of the underlying MD5 checksums \textendash{} which facilitates cross\sphinxhyphen{}platform compatibility for sharing datasets also with users on operating systems that have restrictions on total path length, such as Windows.

\sphinxAtStartPar
The one remaining unidentified bit in the file name is the one after the checksum identifier.
This part is the size of the content in bytes.
An annexed file in the object tree thus has a file name following this structure
(but see \sphinxhref{https://git-annex.branchable.com/internals/key\_format}{the git\sphinxhyphen{}annex documentation on keys} for the complete details):

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textless{}backend type\textgreater{}\sphinxhyphen{}s\textless{}size\textgreater{}\sphinxhyphen{}\sphinxhyphen{}\textless{}checksum\textgreater{}.\textless{}extension\textgreater{}}}

\sphinxAtStartPar
You now know a great deal more about git\sphinxhyphen{}annex and the object tree.
Maybe you are as amazed as we are about some of the ingenuity used behind the scenes.
Even more mesmerizing things about git\sphinxhyphen{}annex can be found in its \sphinxhref{https://git-annex.branchable.com/git-annex}{documentation}.


\end{findoutmore}

\vspace{1cm}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{teacher}.pdf}\hspace*{\fill}}

\index{broken symlink@\spxentry{broken symlink}|spxpagem}\index{symlink@\spxentry{symlink}!broken@\spxentry{broken}|spxpagem}\ignorespaces 

\subsection{Broken symlinks}
\label{\detokenize{basics/101-115-symlinks:broken-symlinks}}\label{\detokenize{basics/101-115-symlinks:wslfiles}}\label{\detokenize{basics/101-115-symlinks:index-6}}
\sphinxAtStartPar
Whenever a symlink points to a non\sphinxhyphen{}existent target, this symlink is called
\sphinxstyleemphasis{broken} or \sphinxstyleemphasis{dangling}, and opening the symlink would not work as it does not resolve. The
section {\hyperref[\detokenize{basics/101-136-filesystem:file-system}]{\sphinxcrossref{\DUrole{std,std-ref}{Dataset ops}}}} (\autopageref*{\detokenize{basics/101-136-filesystem:file-system}}) will give a thorough demonstration of how symlinks can
break, and how one can fix them again. Even though \sphinxstyleemphasis{broken} sounds
troublesome, most types of broken symlinks you will encounter can be fixed,
or are not problematic. At this point, you actually have already seen broken
symlinks: Back in section {\hyperref[\detokenize{basics/101-105-install:installds}]{\sphinxcrossref{\DUrole{std,std-ref}{Install datasets}}}} (\autopageref*{\detokenize{basics/101-105-install:installds}}) we explored
the file hierarchy in an installed subdataset that contained many annexed
\sphinxcode{\sphinxupquote{mp3}} files. Upon the initial \sphinxcode{\sphinxupquote{datalad clone}}, the annexed files were not present locally.
Instead, their symlinks (stored in Git) existed and allowed to explore which
file’s contents could be retrieved. These symlinks point to nothing, though, as
the content isn’t yet present locally, and are thus \sphinxstyleemphasis{broken}. This state,
however, is not problematic at all. Once the content is retrieved via
\sphinxcode{\sphinxupquote{datalad get}}, the symlink is functional again.

\sphinxAtStartPar
Nevertheless, it may be important to know that some tools that you would expect to work in a dataset with not yet retrieved file contents can encounter unintuitive problems.
Some \sphinxstylestrong{file managers} (e.g., OSX’s Finder) may not display broken symlinks.
In these cases, it will be impossible to browse and explore the file hierarchy of not\sphinxhyphen{}yet\sphinxhyphen{}retrieved files with the file manager.
You can make sure to always be able to see the file hierarchy in two separate ways:
Upgrade your file manager to display file types in DataLad datasets (e.g., the \sphinxhref{https://github.com/andrewringler/git-annex-turtle}{git\sphinxhyphen{}annex\sphinxhyphen{}turtle extension} for Finder), or use the \sphinxhref{https://docs.datalad.org/projects/gooey}{DataLad Gooey} to browse datasets.
Alternatively, use the \sphinxcode{\sphinxupquote{ ls}} command in a terminal instead of a file manager GUI.
Other tools may be more more specialized, smaller, or domain\sphinxhyphen{}specific, and may fail to correctly work with broken symlinks, or display unhelpful error messages when handling them, or require additional flags to modify their behavior.
When encountering unexpected behavior or failures, try to keep in mind that a dataset without retrieved content appears to be a pile of broken symlinks to a range of tools, consult a tools documentation with regard to symlinks, and check whether data retrieval fixes persisting problems.

\sphinxAtStartPar
A last special case on symlinks exists if you are using DataLad on the Windows Subsystem for Linux. Take a look at the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-wsl2-symlinks}} {\hyperref[\detokenize{basics/101-115-symlinks:ww-wsl2-symlinks}]{\sphinxcrossref{\DUrole{std,std-ref}{on WSL2 symlink access}}}} (\autopageref*{\detokenize{basics/101-115-symlinks:ww-wsl2-symlinks}})
for that.

\index{access WSL2 symlinked files@\spxentry{access WSL2 symlinked files}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!access WSL2 symlinked files@\spxentry{access WSL2 symlinked files}}\index{WSL2@\spxentry{WSL2}!symlink access@\spxentry{symlink access}}\index{log@\spxentry{log}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!log@\spxentry{log}}\ignorespaces \begin{windowswit}[label={ww-wsl2-symlinks}, before title={\thetcbcounter\ }, float, floatplacement=tbp, check odd page=true]{Accessing symlinked files from your Windows system}
\label{\detokenize{basics/101-115-symlinks:ww-wsl2-symlinks}}

\sphinxAtStartPar
If you are using WSL2 you have access to a Linux kernel and POSIX file system, including symlink support.
Your DataLad experience has therefore been exactly as it has been for macOS or Linux users.
But one thing that bears the need for additional information is sharing files in dataset between your Linux and Windows system.

\sphinxAtStartPar
It’s fantastic that files created under Linux can be shared to Windows and used by Windows tools.
Usually, you should be able to open an explorer and type \sphinxcode{\sphinxupquote{\textbackslash{}\textbackslash{}wsl\$\textbackslash{}\textless{}distro\textgreater{}\textbackslash{}\textless{}path\textgreater{}}} in the address bar to navigate to files under Linux, or type \sphinxcode{\sphinxupquote{explorer.exe}} into the WSL2 terminal.
Some core limitations of Windows can’t be overcome, though: Windows usually isn’t capable of handling symlinks.
So while WSL2 can expose your dataset filled with symlinked files to Windows, your Windows tools can fail to open them.
How can this be fixed?

\index{checkout@\spxentry{checkout}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!checkout@\spxentry{checkout}}\index{check out particular version@\spxentry{check out particular version}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!check out particular version@\spxentry{check out particular version}}\ignorespaces 
\sphinxAtStartPar
Whenever you need to work with files from your datasets under Windows, you should \sphinxstyleemphasis{unlock} with \sphinxcode{\sphinxupquote{datalad unlock}}.
This operation copies the file from the annex back to its original location, and thus removes the symlink (and also returns write {\hyperref[\detokenize{glossary:term-permissions}]{\sphinxtermref{\DUrole{xref,std,std-term}{permissions}}}} to the file).
Alternatively, use \sphinxhref{https://git-annex.branchable.com/git-annex-adjust}{git\sphinxhyphen{}annex adjust \textendash{}unlock} to switch to a new dataset {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} in which all files are unlocked.
The branch is called \sphinxcode{\sphinxupquote{adjusted/\textless{}branchname\textgreater{}(unlocked)}} (e.g., if the original branch name was \sphinxcode{\sphinxupquote{main}}, the new, adjusted branch will be called \sphinxcode{\sphinxupquote{adjusted/main(unlocked)}}).
You can switch back to your original branch using \sphinxcode{\sphinxupquote{git checkout \textless{}branchname\textgreater{}}}.


\end{windowswit}

\sphinxAtStartPar
Finally, if you are still in the \sphinxcode{\sphinxupquote{books/}} directory, go back into the root of
the superdataset.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Collaboration}
\label{\detokenize{basics/basics-collaboration:collaboration}}\label{\detokenize{basics/basics-collaboration:chapter-collaboration}}\label{\detokenize{basics/basics-collaboration::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{collaboration_sketch}.pdf}\hspace*{\fill}}

\sphinxstepscope

\index{data sharing@\spxentry{data sharing}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!data sharing@\spxentry{data sharing}}\ignorespaces 

\section{Looking without touching}
\label{\detokenize{basics/101-116-sharelocal:looking-without-touching}}\label{\detokenize{basics/101-116-sharelocal:sharelocal1}}\label{\detokenize{basics/101-116-sharelocal:index-0}}\label{\detokenize{basics/101-116-sharelocal::doc}}
\sphinxAtStartPar
Only now, several weeks into the DataLad\sphinxhyphen{}101 course does your room
mate realize that he has enrolled in the course as well, but has not
yet attended at all. “Oh man, can you help me catch up?” he asks
you one day. “Sharing just your notes would be really cool for a
start already!”

\sphinxAtStartPar
“Sure thing”, you say, and decide that it’s probably best if he gets
all of the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} course dataset. Sharing datasets was
something you wanted to look into soon, anyway.

\sphinxAtStartPar
This is one exciting aspect of DataLad datasets that has yet been missing
from this course: How does one share a dataset?
In this section, we will cover the simplest way of sharing a dataset:
on a local or shared file system, via an \sphinxstyleemphasis{installation} with a path as
a source.
\begin{importantnote}[before title={\thetcbcounter\ }, check odd page=true]{More on public data sharing}

\sphinxAtStartPar
Interested in sharing datasets \sphinxstyleemphasis{publicly}? Read this chapter to get a feel
for all relevant basic concepts of sharing datasets. Afterwards, head over
to chapter {\hyperref[\detokenize{basics/basics-thirdparty:chapter-thirdparty}]{\sphinxcrossref{\DUrole{std,std-ref}{Distributing datasets}}}} (\autopageref*{\detokenize{basics/basics-thirdparty:chapter-thirdparty}}) to find out how to share a dataset
on third\sphinxhyphen{}party infrastructure.


\end{importantnote}

\sphinxAtStartPar
In this scenario multiple people can access the very same files at the
same time, often on the same machine (e.g., a shared workstation, or
a server that people can “{\hyperref[\detokenize{glossary:term-SSH}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH}}}}” into). You might think: “What do I need
DataLad for, if everyone can already access everything?” However,
universal, unrestricted access can easily lead to chaos. DataLad can
help facilitate collaboration without requiring ultimate trust and
reliability of all participants. Essentially, with a shared dataset,
collaborators can see and use your dataset without any danger
of undesired, or uncontrolled modification.

\sphinxAtStartPar
To demonstrate how to share a DataLad dataset on a common file system,
we will pretend that your personal computer
can be accessed by other users. Let’s say that
your room mate has access, and you are making sure that there is
a \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset in a different place on the file system
for him to access and work with.

\sphinxAtStartPar
This is indeed a common real\sphinxhyphen{}world use case: Two users on a shared
file system sharing a dataset with each other.
But as we cannot easily simulate a second user in this book,
for now, you will have to share your dataset with yourself.
This endeavor serves several purposes: For one, you will experience a very easy
way of sharing a dataset. Secondly, it will show you
how a dataset can be obtained from a path, instead of a URL as shown in section
{\hyperref[\detokenize{basics/101-105-install:installds}]{\sphinxcrossref{\DUrole{std,std-ref}{Install datasets}}}} (\autopageref*{\detokenize{basics/101-105-install:installds}}). Thirdly, \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} is a dataset that can
showcase many different properties of a dataset already, but it will
be an additional learning experience to see how the different parts
of the dataset \textendash{} text files, larger files, subdatasets,
{\hyperref[\detokenize{glossary:term-run-record}]{\sphinxtermref{\DUrole{xref,std,std-term}{run record}}}}s \textendash{} will appear upon installation when shared.
And lastly, you will likely “share a dataset with yourself” whenever you
will be using a particular dataset of your own creation as input for
one or more projects.

\sphinxAtStartPar
“Awesome!” exclaims your room mate as you take out your laptop to
share the dataset. “You are really saving my ass
here. I’ll make up for it when we prepare for the final”, he promises.

\sphinxAtStartPar
To install \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} into a different part
of your file system, navigate out of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}, and \textendash{} for
simplicity \textendash{} create a new directory, \sphinxcode{\sphinxupquote{mock\_user}}, right next to it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\PYG{g+gp}{\PYGZdl{} }mkdir\PYG{+w}{ }mock\PYGZus{}user
\end{sphinxVerbatim}

\sphinxAtStartPar
For simplicity, pretend that this is a second user’s \textendash{} your room mate’s \textendash{}
home directory. Furthermore, let’s for now disregard anything about
{\hyperref[\detokenize{glossary:term-permissions}]{\sphinxtermref{\DUrole{xref,std,std-term}{permissions}}}}. In a real\sphinxhyphen{}world example you likely would not be able to read and write
to a different user’s directories, but we will talk about permissions later.

\index{clone@\spxentry{clone}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!clone@\spxentry{clone}}\index{clone dataset (set location description)@\spxentry{clone dataset}\spxextra{set location description}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!clone dataset (set location description)@\spxentry{clone dataset}\spxextra{set location description}}\ignorespaces 
\sphinxAtStartPar
After creation, navigate into \sphinxcode{\sphinxupquote{mock\_user}} and install the dataset \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}.
To do this, use \sphinxcode{\sphinxupquote{datalad clone}}, and provide a path to your original
dataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }mock\PYGZus{}user
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }clone\PYG{+w}{ }\PYGZhy{}\PYGZhy{}description\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}DataLad\PYGZhy{}101 in mock\PYGZus{}user\PYGZdq{}}\PYG{+w}{ }../DataLad\PYGZhy{}101
\PYG{g+go}{install(ok): /home/me/dl\PYGZhy{}101/mock\PYGZus{}user/DataLad\PYGZhy{}101 (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will install your dataset \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} into your room mate’s home
directory. Note that we have given this new
dataset a description about its location. Note further that we
have not provided the optional destination path to \sphinxcode{\sphinxupquote{datalad clone}},
and hence it installed the dataset under its original name in the current directory.

\sphinxAtStartPar
Together with your room mate, you go ahead and see what this dataset looks
like. Before running the command, try to predict what you will see.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }DataLad\PYGZhy{}101
\PYG{g+gp}{\PYGZdl{} }tree
\PYG{g+go}{.}
\PYG{g+go}{├── books}
\PYG{g+go}{│   ├── bash\PYGZus{}guide.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/WF/Gq/✂/MD5E\PYGZhy{}s1198170\PYGZhy{}\PYGZhy{}0ab2c121✂MD5.pdf}
\PYG{g+go}{│   ├── byte\PYGZhy{}of\PYGZhy{}python.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/xF/42/✂/MD5E\PYGZhy{}s4161086\PYGZhy{}\PYGZhy{}c832fc13✂MD5.pdf}
\PYG{g+go}{│   ├── progit.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/G6/Gj/✂/MD5E\PYGZhy{}s12465653\PYGZhy{}\PYGZhy{}05cd7ed5✂MD5.pdf}
\PYG{g+go}{│   └── TLCL.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\PYG{g+go}{├── code}
\PYG{g+go}{│   └── list\PYGZus{}titles.sh}
\PYG{g+go}{├── notes.txt}
\PYG{g+go}{└── recordings}
\PYG{g+go}{    ├── interval\PYGZus{}logo\PYGZus{}small.jpg \PYGZhy{}\PYGZgt{} ../.git/annex/objects/pw/Mf/✂/MD5E\PYGZhy{}s70348\PYGZhy{}\PYGZhy{}4b2ec0db✂MD5.jpg}
\PYG{g+go}{    ├── longnow}
\PYG{g+go}{    ├── podcasts.tsv}
\PYG{g+go}{    └── salt\PYGZus{}logo\PYGZus{}small.jpg \PYGZhy{}\PYGZgt{} ../.git/annex/objects/fZ/wg/✂/MD5E\PYGZhy{}s76402\PYGZhy{}\PYGZhy{}87da732f✂MD5.jpg}

\PYG{g+go}{4 directories, 9 files}
\end{sphinxVerbatim}

\sphinxAtStartPar
There are a number of interesting things, and your room mate is the
first to notice them:

\sphinxAtStartPar
“Hey, can you explain some things to me?”, he asks. “This directory
here, “\sphinxcode{\sphinxupquote{longnow}}”, why is it empty?”
True, the subdataset has a directory name but apart from this,
the \sphinxcode{\sphinxupquote{longnow}} directory appears empty.

\sphinxAtStartPar
“Also, why do the PDFs in \sphinxcode{\sphinxupquote{books/}} and the \sphinxcode{\sphinxupquote{.jpg}} files
appear so weird? They have
this cryptic path right next to them, and look, if I try to open
one of them, it fails! Did something go wrong when we installed
the dataset?” he worries.
Indeed, the PDFs and pictures appear just as they did in the original dataset
on first sight: They are symlinks pointing to some location in the
object tree. To reassure your room mate that everything is fine you
quickly explain to him the concept of a symlink and the {\hyperref[\detokenize{glossary:term-object-tree}]{\sphinxtermref{\DUrole{xref,std,std-term}{object\sphinxhyphen{}tree}}}}
of {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}.

\index{clone@\spxentry{clone}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!clone@\spxentry{clone}}\ignorespaces 
\sphinxAtStartPar
“But why does the PDF not open when I try to open it?” he repeats.
True, these files cannot be opened. This mimics our experience when
installing the \sphinxcode{\sphinxupquote{longnow}} subdataset: Right after installation,
the \sphinxcode{\sphinxupquote{.mp3}} files also could not be opened, because their file
content was not yet retrieved. You begin to explain to your room mate
how DataLad retrieves only minimal metadata about which files actually
exist in a dataset upon a \sphinxcode{\sphinxupquote{datalad clone}}. “It’s really handy”,
you tell him. “This way you can decide which book you want to read,
and then retrieve what you need. Everything that is \sphinxstyleemphasis{annexed} is retrieved
on demand. Note though that the text files
contents are present, and the files can be opened \textendash{} this is because
these files are stored in {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}}. So you already have my notes,
and you can decide for yourself whether you want to \sphinxcode{\sphinxupquote{get}} the books.”

\sphinxAtStartPar
To demonstrate this, you decide to examine the PDFs further.
“Try to get one of the books”, you instruct your room mate:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }books/progit.pdf
\PYG{g+go}{get(ok): books/progit.pdf (file) [from origin...]}
\end{sphinxVerbatim}

\sphinxAtStartPar
“Opening this file will work, because the content was retrieved from
the original dataset.”, you explain, proud that this worked just as you
thought it would.

\sphinxAtStartPar
Let’s now turn to the fact that the subdataset \sphinxcode{\sphinxupquote{longnow}} contains neither
file content nor file metadata information to explore the contents of the
dataset: there are no subdirectories or any files under \sphinxcode{\sphinxupquote{recordings/longnow/}}.
This is behavior that you have not observed until now.
To fix this and obtain file availability metadata,
you have to run a somewhat unexpected command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }recordings/longnow
\PYG{g+go}{[INFO] Remote origin not usable by git\PYGZhy{}annex; setting annex\PYGZhy{}ignore}
\PYG{g+go}{install(ok): /home/me/dl\PYGZhy{}101/mock\PYGZus{}user/DataLad\PYGZhy{}101/recordings/longnow (dataset) [Installed subdataset in order to get /home/me/dl\PYGZhy{}101/mock\PYGZus{}user/DataLad\PYGZhy{}101/recordings/longnow]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Before we look further into \sphinxcode{\sphinxupquote{datalad get}} and the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}n/\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}data}} option, let’s first see what has changed after
running the above command (excerpt):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }tree
\PYG{g+go}{.}
\PYG{g+go}{├── books}
\PYG{g+go}{│   ├── bash\PYGZus{}guide.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/WF/Gq/✂/MD5E\PYGZhy{}s1198170\PYGZhy{}\PYGZhy{}0ab2c121✂MD5.pdf}
\PYG{g+go}{│   ├── byte\PYGZhy{}of\PYGZhy{}python.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/xF/42/✂/MD5E\PYGZhy{}s4161086\PYGZhy{}\PYGZhy{}c832fc13✂MD5.pdf}
\PYG{g+go}{│   ├── progit.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/G6/Gj/✂/MD5E\PYGZhy{}s12465653\PYGZhy{}\PYGZhy{}05cd7ed5✂MD5.pdf}
\PYG{g+go}{│   └── TLCL.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\PYG{g+go}{├── code}
\PYG{g+go}{│   └── list\PYGZus{}titles.sh}
\PYG{g+go}{├── notes.txt}
\PYG{g+go}{└── recordings}
\PYG{g+go}{    ├── interval\PYGZus{}logo\PYGZus{}small.jpg \PYGZhy{}\PYGZgt{} ../.git/annex/objects/pw/Mf/✂/MD5E\PYGZhy{}s70348\PYGZhy{}\PYGZhy{}4b2ec0db✂MD5.jpg}
\PYG{g+go}{    ├── longnow}
\PYG{g+go}{    │   ├── Long\PYGZus{}Now\PYGZus{}\PYGZus{}Conversations\PYGZus{}at\PYGZus{}The\PYGZus{}Interval}
\PYG{g+go}{    │   │   ├── 2017\PYGZus{}06\PYGZus{}09\PYGZus{}\PYGZus{}How\PYGZus{}Digital\PYGZus{}Memory\PYGZus{}Is\PYGZus{}Shaping\PYGZus{}Our\PYGZus{}Future\PYGZus{}\PYGZus{}Abby\PYGZus{}Smith\PYGZus{}Rumsey.mp3 \PYGZhy{}\PYGZgt{} ../.git/annex/objects/8j/kQ/✂/MD5E\PYGZhy{}s66305442\PYGZhy{}\PYGZhy{}c723d53d✂MD5.mp3}
\PYG{g+go}{    │   │   ├── 2017\PYGZus{}06\PYGZus{}09\PYGZus{}\PYGZus{}Pace\PYGZus{}Layers\PYGZus{}Thinking\PYGZus{}\PYGZus{}Stewart\PYGZus{}Brand\PYGZus{}\PYGZus{}Paul\PYGZus{}Saffo.mp3 \PYGZhy{}\PYGZgt{} ../.git/annex/objects/Qk/9M/✂/MD5E\PYGZhy{}s112801659\PYGZhy{}\PYGZhy{}00a42a1a✂MD5.mp3}
\PYG{g+go}{    │   │   ├── 2017\PYGZus{}06\PYGZus{}09\PYGZus{}\PYGZus{}Proof\PYGZus{}\PYGZus{}The\PYGZus{}Science\PYGZus{}of\PYGZus{}Booze\PYGZus{}\PYGZus{}Adam\PYGZus{}Rogers.mp3 \PYGZhy{}\PYGZgt{} ../.git/annex/objects/FP/96/✂/MD5E\PYGZhy{}s60091960\PYGZhy{}\PYGZhy{}6e48eceb✂MD5.mp3}
\PYG{g+go}{    │   │   ├── 2017\PYGZus{}06\PYGZus{}09\PYGZus{}\PYGZus{}Seveneves\PYGZus{}at\PYGZus{}The\PYGZus{}Interval\PYGZus{}\PYGZus{}Neal\PYGZus{}Stephenson.mp3 \PYGZhy{}\PYGZgt{} ../.git/annex/objects/Wf/5Q/✂/MD5E\PYGZhy{}s66431897\PYGZhy{}\PYGZhy{}aff90c83✂MD5.mp3}
\PYG{g+go}{    │   │   ├── 2017\PYGZus{}06\PYGZus{}09\PYGZus{}\PYGZus{}Talking\PYGZus{}with\PYGZus{}Robots\PYGZus{}about\PYGZus{}Architecture\PYGZus{}\PYGZus{}Jeffrey\PYGZus{}McGrew.mp3 \PYGZhy{}\PYGZgt{} ../.git/annex/objects/Fj/9V/✂/MD5E\PYGZhy{}s61491081\PYGZhy{}\PYGZhy{}c4e88ea0✂MD5.mp3}
\PYG{g+go}{    │   │   ├── 2017\PYGZus{}06\PYGZus{}09\PYGZus{}\PYGZus{}The\PYGZus{}Red\PYGZus{}Planet\PYGZus{}for\PYGZus{}Real\PYGZus{}\PYGZus{}Andy\PYGZus{}Weir.mp3 \PYGZhy{}\PYGZgt{} ../.git/annex/objects/xq/Q3/✂/MD5E\PYGZhy{}s136924472\PYGZhy{}\PYGZhy{}0d107210✂MD5.mp3}
\end{sphinxVerbatim}

\sphinxAtStartPar
Interesting! The file metadata information is now present, and we can
explore the file hierarchy. The file content, however, is not present yet.

\sphinxAtStartPar
What has happened here?

\sphinxAtStartPar
When DataLad installs a dataset, it will by default only obtain the
superdataset, and not any subdatasets. The superdataset contains the
information that a subdataset exists though \textendash{} the subdataset is \sphinxstyleemphasis{registered}
in the superdataset.  This is why the subdataset name exists as a directory.
A subsequent \sphinxcode{\sphinxupquote{datalad get \sphinxhyphen{}n path/to/longnow}} will install the registered
subdataset again, just as we did in the example above.

\sphinxAtStartPar
But what about the \sphinxcode{\sphinxupquote{\sphinxhyphen{}n}} option for \sphinxcode{\sphinxupquote{datalad get}}?
Previously, we used \sphinxcode{\sphinxupquote{datalad get}} to get file content. However,
\sphinxcode{\sphinxupquote{datalad get}} operates on more than just the level of \sphinxstyleemphasis{files} or \sphinxstyleemphasis{directories}.
Instead, it can also operate on the level of \sphinxstyleemphasis{datasets}. Regardless of whether
it is a single file (such as \sphinxcode{\sphinxupquote{books/TLCL.pdf}}) or a registered subdataset
(such as \sphinxcode{\sphinxupquote{recordings/longnow}}), \sphinxcode{\sphinxupquote{datalad get}} will operate on it to 1) install
it \textendash{} if it is a not yet installed subdataset \textendash{} and 2) retrieve the contents of any files.
That makes it very easy to get your file content, regardless of
how your dataset may be structured \textendash{} it is always the same command, and DataLad
blurs the boundaries between superdatasets and subdatasets.

\sphinxAtStartPar
In the above example, we called \sphinxcode{\sphinxupquote{datalad get}} with the option \sphinxcode{\sphinxupquote{\sphinxhyphen{}n/\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}data}}.
This option prevents that \sphinxcode{\sphinxupquote{datalad get}} obtains the data of individual files or
directories, thus limiting its scope to the level of datasets as only a
\sphinxcode{\sphinxupquote{datalad clone}} is performed. Without this option, the command would
have retrieved all of the subdatasets contents right away. But with \sphinxcode{\sphinxupquote{\sphinxhyphen{}n/\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}data}},
it only installed the subdataset to retrieve the meta data about file availability.

\index{get all dataset content@\spxentry{get all dataset content}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!get all dataset content@\spxentry{get all dataset content}}\ignorespaces 
\sphinxAtStartPar
To explicitly install all potential subdatasets \sphinxstyleemphasis{recursively}, that is,
all of the subdatasets inside it as well, one can give the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}r}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}recursive}} option to \sphinxcode{\sphinxupquote{datalad get}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }\PYGZlt{}subds\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
This would install the \sphinxcode{\sphinxupquote{subds}} subdataset and all potential further
subdatasets inside of it, and the meta data about file hierarchies would
have been available right away for every subdataset inside of \sphinxcode{\sphinxupquote{subds}}. If you
had several subdatasets and would not provide a path to a single dataset,
but, say, the current directory (\sphinxcode{\sphinxupquote{.}} as in \sphinxcode{\sphinxupquote{datalad get \sphinxhyphen{}n \sphinxhyphen{}r .}}), it
would clone all registered subdatasets recursively.

\sphinxAtStartPar
So why is a recursive get not the default behavior?
In {\hyperref[\detokenize{basics/101-106-nesting:nesting}]{\sphinxcrossref{\DUrole{std,std-ref}{Dataset nesting}}}} (\autopageref*{\detokenize{basics/101-106-nesting:nesting}}) we learned that datasets can be nested \sphinxstyleemphasis{arbitrarily} deep.
Upon getting the meta data of one dataset you might not want to also install
a few dozen levels of nested subdatasets right away.

\sphinxAtStartPar
However, there is a middle way%
\begin{footnote}[1]\sphinxAtStartFootnote
Another alternative to a recursion limit to \sphinxcode{\sphinxupquote{datalad get \sphinxhyphen{}n \sphinxhyphen{}r}} is
a dataset configuration that specifies subdatasets that should \sphinxstyleemphasis{not} be
cloned recursively, unless explicitly given to the command with a path. With
this configuration, a superdataset’s maintainer can safeguard users and prevent
potentially large amounts of subdatasets to be cloned.
You can learn more about this configuration in the section {\hyperref[\detokenize{basics/101-123-config2:config2}]{\sphinxcrossref{\DUrole{std,std-ref}{Shipping and overriding configuration}}}} (\autopageref*{\detokenize{basics/101-123-config2:config2}}).
%
\end{footnote}: The \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}recursion\sphinxhyphen{}limit}} option let’s
you specify how many levels of subdatasets should be installed together
with the first subdataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }\PYGZhy{}\PYGZhy{}recursion\PYGZhy{}limit\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYGZlt{}subds\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
To summarize what you learned in this section, write a note on how to
install a dataset using a path as a source on a common file system.

\sphinxAtStartPar
Write this note in “your own” (the original) \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset, though!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} navigate back into the original dataset}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../../DataLad\PYGZhy{}101
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} write the note}
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }notes.txt
\PYG{g+go}{A source to install a dataset from can also be a path, for example as}
\PYG{g+go}{in \PYGZdq{}datalad clone ../DataLad\PYGZhy{}101\PYGZdq{}.}

\PYG{g+go}{Just as in creating datasets, you can add a description on the}
\PYG{g+go}{location of the new dataset clone with the \PYGZhy{}D/\PYGZhy{}\PYGZhy{}description option.}

\PYG{g+go}{Note that subdatasets will not be installed by default, but are only}
\PYG{g+go}{registered in the superdataset \PYGZhy{}\PYGZhy{} you will have to do a}
\PYG{g+go}{\PYGZdq{}datalad get \PYGZhy{}n PATH/TO/SUBDATASET\PYGZdq{} to install the subdataset for file}
\PYG{g+go}{availability meta data. The \PYGZhy{}n/\PYGZhy{}\PYGZhy{}no\PYGZhy{}data options prevents that file}
\PYG{g+go}{contents are also downloaded.}

\PYG{g+go}{Note that a recursive \PYGZdq{}datalad get\PYGZdq{} would install all further}
\PYG{g+go}{registered subdatasets underneath a subdataset, so a safer way to}
\PYG{g+go}{proceed is to set a decent \PYGZhy{}\PYGZhy{}recursion\PYGZhy{}limit:}
\PYG{g+go}{\PYGZdq{}datalad get \PYGZhy{}n \PYGZhy{}r \PYGZhy{}\PYGZhy{}recursion\PYGZhy{}limit 2 \PYGZlt{}subds\PYGZgt{}\PYGZdq{}}

\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\sphinxAtStartPar
Save this note.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add note about cloning from paths and recursive datalad get\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\index{clone@\spxentry{clone}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!clone@\spxentry{clone}}\ignorespaces \begin{gitusernote}[label={index-4}, before title={\thetcbcounter\ }, check odd page=true]{Get a clone}
\label{\detokenize{basics/101-116-sharelocal:index-4}}

\sphinxAtStartPar
A dataset that is installed from an existing source, e.g., a path or URL,
is the DataLad equivalent of a \sphinxstyleemphasis{clone} in Git.


\end{gitusernote}

\sphinxstepscope

\index{data sharing@\spxentry{data sharing}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!data sharing@\spxentry{data sharing}}\index{data availability tracking@\spxentry{data availability tracking}!with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}}\index{with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}!data availability tracking@\spxentry{data availability tracking}}\ignorespaces 

\section{Where’s Waldo?}
\label{\detokenize{basics/101-117-sharelocal2:where-s-waldo}}\label{\detokenize{basics/101-117-sharelocal2:sharelocal2}}\label{\detokenize{basics/101-117-sharelocal2:index-0}}\label{\detokenize{basics/101-117-sharelocal2::doc}}
\sphinxAtStartPar
So far, you and your room mate have created a copy of the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}
dataset on the same file system but a different place by installing
it from a path.

\sphinxAtStartPar
You have observed that the \sphinxcode{\sphinxupquote{\sphinxhyphen{}r}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}recursive}}
option needs to be given to \sphinxcode{\sphinxupquote{datalad get {[}\sphinxhyphen{}n/\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}data{]}}}
in order to install further potential subdatasets in one go. Only then
is the subdatasets file content availability metadata present to explore
the file hierarchy available within the subdataset.
Alternatively, a \sphinxcode{\sphinxupquote{datalad get \sphinxhyphen{}n \textless{}subds\textgreater{}}} takes care of installing
exactly the specified registered subdataset.

\sphinxAtStartPar
And you have mesmerized your room mate by showing him how {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}
retrieved large file contents from the original dataset.
Your room mate is excited by this magical command.
You however begin to wonder: how does DataLad know where to look for that original content?

\sphinxAtStartPar
This information comes from git\sphinxhyphen{}annex.
Before getting another PDF, let’s query git\sphinxhyphen{}annex where its content is stored:

\index{whereis@\spxentry{whereis}!git\sphinxhyphen{}annex command@\spxentry{git\sphinxhyphen{}annex command}}\index{git\sphinxhyphen{}annex command@\spxentry{git\sphinxhyphen{}annex command}!whereis@\spxentry{whereis}}\index{show file content availability@\spxentry{show file content availability}!with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}}\index{with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}!show file content availability@\spxentry{show file content availability}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-117-sharelocal2:index-1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} navigate back into the clone of DataLad\PYGZhy{}101}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../mock\PYGZus{}user/DataLad\PYGZhy{}101
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }annex\PYG{+w}{ }whereis\PYG{+w}{ }books/TLCL.pdf
\PYG{g+go}{whereis books/TLCL.pdf (1 copy)}
\PYG{g+go}{  0c450dc0\PYGZhy{}c48c\PYGZhy{}4057\PYGZhy{}a231\PYGZhy{}e2654b689600 \PYGZhy{}\PYGZhy{} me@appveyor\PYGZhy{}vm:\PYGZti{}/dl\PYGZhy{}101/DataLad\PYGZhy{}101 [origin]}
\PYG{g+go}{ok}
\end{sphinxVerbatim}

\sphinxAtStartPar
Oh, another cryptic character sequence \sphinxhyphen{} this time however not a symlink, but an {\hyperref[\detokenize{glossary:term-annex-UUID}]{\sphinxtermref{\DUrole{xref,std,std-term}{annex UUID}}}}.
“That’s hard to read \textendash{} what is it?” your room mate asks.
You can recognize a path to the dataset on your computer, prefixed with the user and hostname of your computer.
“This”, you exclaim, excited about your own realization, “is my dataset’s location I’m sharing it from!” You can check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-clone-description}} {\hyperref[\detokenize{basics/101-117-sharelocal2:fom-clone-description}]{\sphinxcrossref{\DUrole{std,std-ref}{on customizing this description}}}} (\autopageref*{\detokenize{basics/101-117-sharelocal2:fom-clone-description}}) and learn how to tweak this accoridng to your taste.

\index{set description for dataset location@\spxentry{set description for dataset location}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!set description for dataset location@\spxentry{set description for dataset location}}\ignorespaces \begin{findoutmore}[label={fom-clone-description}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{What is this location, and what if I provided a description?}
\label{\detokenize{basics/101-117-sharelocal2:fom-clone-description}}

\sphinxAtStartPar
Back in the very first section of the Basics, {\hyperref[\detokenize{basics/101-101-create:createds}]{\sphinxcrossref{\DUrole{std,std-ref}{Create a dataset}}}} (\autopageref*{\detokenize{basics/101-101-create:createds}}), a {\hyperref[\detokenize{basics/101-101-create:createdescription}]{\sphinxcrossref{\DUrole{std,std-ref}{Find\sphinxhyphen{}out\sphinxhyphen{}more mentioned the ‘\textendash{}description’ option}}}} (\autopageref*{\detokenize{basics/101-101-create:createdescription}})   of \sphinxcode{\sphinxupquote{datalad create}}.
With this option, you can provide a description about the dataset \sphinxstyleemphasis{location}.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{git annex whereis}} command, finally, is where such a description
can become handy: If you had created the dataset with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}\PYGZhy{}description\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}course on DataLad\PYGZhy{}101 on my private laptop\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }text2git\PYG{+w}{ }DataLad\PYGZhy{}101
\end{sphinxVerbatim}

\sphinxAtStartPar
the command would show \sphinxcode{\sphinxupquote{course on DataLad\sphinxhyphen{}101 on my private laptop}} after
the {\hyperref[\detokenize{glossary:term-UUID}]{\sphinxtermref{\DUrole{xref,std,std-term}{UUID}}}} \textendash{} and thus a more human\sphinxhyphen{}readable description of \sphinxstyleemphasis{where}
file content is stored.
This becomes especially useful when the number of repository copies
increases. If you have only one other dataset it may be easy to
remember what and where it is. But once you have one back\sphinxhyphen{}up
of your dataset on a USB stick, one dataset shared with
Dropbox, and a third one on your institutions
{\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}} instance you will be grateful for the descriptions
you provided these locations with.

\sphinxAtStartPar
The current report of the location of the dataset is in the format
\sphinxcode{\sphinxupquote{user@host:path}}.

\sphinxAtStartPar
If the physical location of a dataset is not relevant, ambiguous, or volatile,
or if it has an {\hyperref[\detokenize{glossary:term-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{annex}}}} that could move within the foreseeable lifetime of a
dataset, a custom description with the relevant information on the dataset is
superior. If this is not the case, decide for yourself whether you want to use
the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}description}} option for future datasets or not depending on what you
find more readable \textendash{} a self\sphinxhyphen{}made location description, or an automatic
\sphinxcode{\sphinxupquote{user@host:path}} information.


\end{findoutmore}

\sphinxAtStartPar
The message further informs you that there is only “\sphinxcode{\sphinxupquote{(1 copy)}}” of this file content.
This makes sense: There is only your own, original \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset in which this book is saved.

\sphinxAtStartPar
To retrieve file content of an annexed file such as one of these PDFs, git\sphinxhyphen{}annex will try to obtain it from the locations it knows to contain this content.
It uses the UUID to identify these locations.
Every copy of a dataset will get a UUID as a unique identifier.
Note however that just because git\sphinxhyphen{}annex knows a certain location where content was once it does not guarantee that retrieval will work.
If one location is a USB stick that is in your bag pack instead of your USB port, a second location is a hard drive that you deleted all of its previous contents (including dataset content) from,
and another location is a web server, but you are not connected to the internet, git\sphinxhyphen{}annex will not succeed in retrieving contents from these locations.
As long as there is at least one location that contains the file and is accessible, though, git\sphinxhyphen{}annex will get the content.
Therefore, for the books in your dataset, retrieving contents works because you and your room mate share the same file system.
If you’d share the dataset with anyone without access to your file system, \sphinxcode{\sphinxupquote{datalad get}} would not work, because it cannot access your files.

\sphinxAtStartPar
But there is one book that does not suffer from this restriction:
The \sphinxcode{\sphinxupquote{bash\_guide.pdf}}.
This book was not manually downloaded and saved to the dataset with \sphinxcode{\sphinxupquote{wget}} (thus keeping DataLad in the dark about where it came from), but it was obtained with the \sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}} command.
This registered the books original source in the dataset, and here is why that is useful:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }annex\PYG{+w}{ }whereis\PYG{+w}{ }books/bash\PYGZus{}guide.pdf
\PYG{g+go}{whereis books/bash\PYGZus{}guide.pdf (2 copies)}
\PYG{g+go}{  00000000\PYGZhy{}0000\PYGZhy{}0000\PYGZhy{}0000\PYGZhy{}000000000001 \PYGZhy{}\PYGZhy{} web}
\PYG{g+go}{  0c450dc0\PYGZhy{}c48c\PYGZhy{}4057\PYGZhy{}a231\PYGZhy{}e2654b689600 \PYGZhy{}\PYGZhy{} me@appveyor\PYGZhy{}vm:\PYGZti{}/dl\PYGZhy{}101/DataLad\PYGZhy{}101 [origin]}

\PYG{g+go}{  web: https://www.tldp.org/LDP/Bash\PYGZhy{}Beginners\PYGZhy{}Guide/Bash\PYGZhy{}Beginners\PYGZhy{}Guide.pdf}
\PYG{g+go}{ok}
\end{sphinxVerbatim}

\sphinxAtStartPar
Unlike the \sphinxcode{\sphinxupquote{TLCL.pdf}} book, this book has two sources, and one of them is \sphinxcode{\sphinxupquote{web}}.
The second to last line specifies the precise URL you downloaded the file from.
Thus, for this book, your room mate is always able to obtain it (as long as the URL remains valid), even if you would delete your \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset.

\sphinxAtStartPar
We can also see a report of the source that git\sphinxhyphen{}annex uses to retrieve the content from if we look at the very end of the \sphinxcode{\sphinxupquote{get}} summary.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }books/TLCL.pdf
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }books/bash\PYGZus{}guide.pdf
\PYG{g+go}{get(ok): books/TLCL.pdf (file) [from origin...]}
\PYG{g+go}{get(ok): books/bash\PYGZus{}guide.pdf (file) [from origin...]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Both of these files were retrieved “\sphinxcode{\sphinxupquote{from origin...}}”.
\sphinxcode{\sphinxupquote{Origin}} is Git terminology for “from where the dataset was copied from” \textendash{} \sphinxcode{\sphinxupquote{origin}} therefore is the original \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset from which file content can be retrieved from very fast.

\sphinxAtStartPar
If your room mate did not have access to the same file system or you deleted your \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset, this output would look differently.
The \sphinxcode{\sphinxupquote{datalad get}} command would fail on the \sphinxcode{\sphinxupquote{TLCL.pdf}} book without a known second source, and \sphinxcode{\sphinxupquote{bash\_guide.pdf}} would be retrieved “\sphinxcode{\sphinxupquote{from web...}}” \sphinxhyphen{} the registered second source, its original download URL.
Let’s see a retrieval from \sphinxcode{\sphinxupquote{web}} in action for another file.
The \sphinxcode{\sphinxupquote{.mp3}} files in the \sphinxcode{\sphinxupquote{longnow}} seminar series have registered web URLs%
\begin{footnote}[1]\sphinxAtStartFootnote
Maybe you wonder what the location \sphinxcode{\sphinxupquote{mih@medusa}} is. It is a copy of the
data on an account belonging to user \sphinxcode{\sphinxupquote{mih}} on the host name \sphinxcode{\sphinxupquote{medusa}}.
Because we do not have the host names’ address, nor log\sphinxhyphen{}in credentials for
this user, we cannot retrieve content from this location. However, somebody
else (for example, the user \sphinxcode{\sphinxupquote{mih}}) could.
%
\end{footnote}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} navigate into the subdirectory}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }recordings/longnow
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }annex\PYG{+w}{ }whereis\PYG{+w}{ }Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2003\PYGZus{}11\PYGZus{}15\PYGZus{}\PYGZus{}Brian\PYGZus{}Eno\PYGZus{}\PYGZus{}The\PYGZus{}Long\PYGZus{}Now.mp3
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2003\PYGZus{}11\PYGZus{}15\PYGZus{}\PYGZus{}Brian\PYGZus{}Eno\PYGZus{}\PYGZus{}The\PYGZus{}Long\PYGZus{}Now.mp3
\PYG{g+go}{whereis Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2003\PYGZus{}11\PYGZus{}15\PYGZus{}\PYGZus{}Brian\PYGZus{}Eno\PYGZus{}\PYGZus{}The\PYGZus{}Long\PYGZus{}Now.mp3 (2 copies)}
\PYG{g+go}{	00000000\PYGZhy{}0000\PYGZhy{}0000\PYGZhy{}0000\PYGZhy{}000000000001 \PYGZhy{}\PYGZhy{} web}
\PYG{g+go}{	✂UUID✂ \PYGZhy{}\PYGZhy{} mih@medusa:/tmp/seminars\PYGZhy{}on\PYGZhy{}longterm\PYGZhy{}thinking}

\PYG{g+go}{  web: http://podcast.longnow.org/salt/redirect/salt\PYGZhy{}020031114\PYGZhy{}eno\PYGZhy{}podcast.mp3}
\PYG{g+go}{ok}
\PYG{g+go}{get(ok): Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking/2003\PYGZus{}11\PYGZus{}15\PYGZus{}\PYGZus{}Brian\PYGZus{}Eno\PYGZus{}\PYGZus{}The\PYGZus{}Long\PYGZus{}Now.mp3 (file) [from web...]}
\end{sphinxVerbatim}

\sphinxAtStartPar
As you can see at the end of the \sphinxcode{\sphinxupquote{get}} result, the files has been retrieved “\sphinxcode{\sphinxupquote{from web...}}”.
Quite useful, this provenance, right?
Let’s add a note on the \sphinxcode{\sphinxupquote{git annex whereis}} command.
Again, do this in the original \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} directory, and do not forget to save it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} navigate back:}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../../../../DataLad\PYGZhy{}101

\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} write the note}
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }notes.txt
\PYG{g+go}{The command \PYGZdq{}git annex whereis PATH\PYGZdq{} lists the repositories that have}
\PYG{g+go}{the file content of an annexed file. When using \PYGZdq{}datalad get\PYGZdq{} to}
\PYG{g+go}{retrieve file content, those repositories will be queried.}

\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{ modified: notes.txt (file)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add note on git annex whereis\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxstepscope

\index{reproducibility@\spxentry{reproducibility}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!reproducibility@\spxentry{reproducibility}}\ignorespaces 

\section{Retrace and reenact}
\label{\detokenize{basics/101-118-sharelocal3:retrace-and-reenact}}\label{\detokenize{basics/101-118-sharelocal3:sharelocal3}}\label{\detokenize{basics/101-118-sharelocal3:index-0}}\label{\detokenize{basics/101-118-sharelocal3::doc}}
\sphinxAtStartPar
“Thanks a lot for sharing your dataset with me! This
is super helpful. I’m sure I’ll catch up in no time!”,
your room mate says confidently. “How far did you get
with the DataLad commands yet?” he asks at last.

\sphinxAtStartPar
“Mhh, I think the last big one was \sphinxcode{\sphinxupquote{datalad run}}.
Actually, let me quickly show you what this command
does. There is something that I’ve been wanting to try
anyway.” you say.

\sphinxAtStartPar
The dataset you shared contained a number of \sphinxcode{\sphinxupquote{datalad run}}
commands. For example, you created the simple \sphinxcode{\sphinxupquote{podcasts.tsv}}
file that listed all titles and speaker names of the longnow
podcasts.

\sphinxAtStartPar
Given that you learned to create “proper” \sphinxcode{\sphinxupquote{datalad run}} commands,
complete with \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}input}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}} specification,
anyone should be able to \sphinxcode{\sphinxupquote{datalad rerun}} these commits
easily. This is what you want to try now.

\sphinxAtStartPar
You begin to think about which \sphinxcode{\sphinxupquote{datalad run}} commit would be
the most useful one to take a look at. The creation of
\sphinxcode{\sphinxupquote{podcasts.tsv}} was a bit dull \textendash{} at this point in time, you
didn’t yet know about \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}input}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output}} arguments,
and the resulting output is present anyway because text files
like this \sphinxcode{\sphinxupquote{.tsv}} file are stored in Git.
However, one of the attempts to resize a picture could be
useful. The input, the podcast logos, is not yet retrieved,
nor is the resulting, resized image. “Let’s go for this!”,
you say, and drag your confused room mate to the computer
screen.

\sphinxAtStartPar
First of all, find the commit shasum of the command you
want to run by taking a look into the history of the dataset
(in the shared dataset):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} navigate into the shared copy}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../mock\PYGZus{}user/DataLad\PYGZhy{}101
\end{sphinxVerbatim}

\fvset{hllines={, 4,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} lets view the history}
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{10}
\PYG{g+go}{41fdaab add note on clean datasets}
\PYG{g+go}{fd4a25e [DATALAD RUNCMD] Resize logo for slides}
\PYG{g+go}{08f2efb [DATALAD RUNCMD] Resize logo for slides}
\PYG{g+go}{87b4f80 add additional notes on run options}
\PYG{g+go}{d0c060f [DATALAD RUNCMD] convert \PYGZhy{}resize 450x450 recordings/longn...}
\PYG{g+go}{5227d93 resized picture by hand}
\PYG{g+go}{6686234 [DATALAD RUNCMD] convert \PYGZhy{}resize 400x400 recordings/longn...}
\PYG{g+go}{4b7a0a0 add note on basic datalad run and datalad rerun}
\PYG{g+go}{cdedbc3 add note datalad and git diff}
\PYG{g+go}{08120c3 [DATALAD RUNCMD] create a list of podcast titles}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Ah, there it is, the second most recent commit.
Just as already done in section {\hyperref[\detokenize{basics/101-109-rerun:run2}]{\sphinxcrossref{\DUrole{std,std-ref}{DataLad, rerun!}}}} (\autopageref*{\detokenize{basics/101-109-rerun:run2}}),
take this shasum and plug it into a \sphinxcode{\sphinxupquote{datalad rerun}}
command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }rerun\PYG{+w}{ }fd4a25e6✂SHA1
\PYG{g+go}{[INFO] run commit fd4a25e; (Resize logo for s...)}
\PYG{g+go}{get(ok): recordings/longnow/.datalad/feed\PYGZus{}metadata/logo\PYGZus{}salt.jpg (file) [from web...]}
\PYG{g+go}{run.remove(ok): recordings/salt\PYGZus{}logo\PYGZus{}small.jpg (file) [Removed file]}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{run(ok): /home/me/dl\PYGZhy{}101/mock\PYGZus{}user/DataLad\PYGZhy{}101 (dataset) [convert \PYGZhy{}resize 400x400 recordings/longn...]}
\PYG{g+go}{add(ok): recordings/salt\PYGZus{}logo\PYGZus{}small.jpg (file)}
\PYG{g+go}{action summary:}
\PYG{g+go}{  add (ok: 1)}
\PYG{g+go}{  get (notneeded: 1, ok: 1)}
\PYG{g+go}{  run (ok: 1)}
\PYG{g+go}{  run.remove (ok: 1)}
\PYG{g+go}{  save (notneeded: 2)}
\end{sphinxVerbatim}

\sphinxAtStartPar
“This was so easy!” you exclaim. DataLad retrieved the missing
file content from the subdataset and it tried to unlock the output
prior to the command execution. Note that because you did not retrieve
the output, \sphinxcode{\sphinxupquote{recordings/salt\_logo\_small.jpg}}, yet, the missing content
could not be “unlocked”, but is reportedly “removed” prior to the successful rerun.

\sphinxAtStartPar
Your room mate now not only knows how exactly the resized file
came into existence, but he can also reproduce your exact steps to
create it. “This is as reproducible as it can be!” you think in awe.

\sphinxstepscope

\index{update dataset@\spxentry{update dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!update dataset@\spxentry{update dataset}}\ignorespaces 

\section{Stay up to date}
\label{\detokenize{basics/101-119-sharelocal4:stay-up-to-date}}\label{\detokenize{basics/101-119-sharelocal4:update}}\label{\detokenize{basics/101-119-sharelocal4:sharelocal4}}\label{\detokenize{basics/101-119-sharelocal4:index-0}}\label{\detokenize{basics/101-119-sharelocal4::doc}}
\sphinxAtStartPar
All of what you have seen about sharing dataset was really
cool, and for the most part also surprisingly intuitive.
\sphinxcode{\sphinxupquote{datalad run}} commands or file retrieval worked exactly as
you imagined it to work, and you begin to think that slowly but
steadily you are getting a feel about how DataLad really works.

\sphinxAtStartPar
But to be honest, so far, sharing the dataset with DataLad was
also remarkably unexciting given that you already knew most of
the dataset magic that your room mate currently is still
mesmerized about.
To be honest, you are not yet certain whether
sharing data with DataLad really improves your life up
until this point. After all, you could have just copied
your directory into your \sphinxcode{\sphinxupquote{mock\_user}} directory and
this would have resulted in about the same output, right?

\sphinxAtStartPar
What we will be looking into now is how shared DataLad
datasets can be updated.

\sphinxAtStartPar
Remember that you added some notes on \sphinxcode{\sphinxupquote{datalad clone}},
\sphinxcode{\sphinxupquote{datalad get}}, and \sphinxcode{\sphinxupquote{git annex whereis}} into the
original \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}?

\sphinxAtStartPar
This is a change that is not reflected in your “shared”
installation in \sphinxcode{\sphinxupquote{../mock\_user/DataLad\sphinxhyphen{}101}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYGZsh{} Inside the installed copy, view the last 15 lines of notes.txt
\PYGZdl{} tail notes.txt
should be specified with an \PYGZhy{}o/\PYGZhy{}\PYGZhy{}output flag. Upon a run or rerun of
the command, the contents of these files will get unlocked so that
they can be modified.

Important! If the dataset is not \PYGZdq{}clean\PYGZdq{} (a datalad status output is
empty), datalad run will not work \PYGZhy{} you will have to save
modifications present in your dataset.
A suboptimal alternative is the \PYGZhy{}\PYGZhy{}explicit flag, used to record only
those changes done to the files listed with \PYGZhy{}\PYGZhy{}output flags.

\end{sphinxVerbatim}

\sphinxAtStartPar
But the original intention of sharing the dataset with
your room mate was to give him access to your notes.
How does he get the notes that you have added in the last
two sections, for example?

\sphinxAtStartPar
This installed copy of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} knows its \sphinxcode{\sphinxupquote{origin}}, i.e.,
the place it was installed from. Using this information,
it can query the original dataset whether any changes
happened since the last time it checked, and if so, retrieve and
integrate them.

\index{update@\spxentry{update}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!update@\spxentry{update}}\index{update dataset with remote change@\spxentry{update dataset with remote change}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!update dataset with remote change@\spxentry{update dataset with remote change}}\ignorespaces 
\sphinxAtStartPar
This is done with the \sphinxcode{\sphinxupquote{datalad update \sphinxhyphen{}\sphinxhyphen{}how merge}}
command.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }update\PYG{+w}{ }\PYGZhy{}\PYGZhy{}how\PYG{+w}{ }merge
\PYG{g+go}{merge(ok): . (dataset) [Merged origin/main]}
\PYG{g+go}{update.annex\PYGZus{}merge(ok): . (dataset) [Merged annex branch]}
\PYG{g+go}{update(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Importantly, run this command either within the specific
(sub)dataset you are interested in, or provide a path to
the root of the dataset you are interested in with the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}d}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dataset}} flag. If you would run the command
within the \sphinxcode{\sphinxupquote{longnow}} subdataset, you would query this
subdatasets’ \sphinxcode{\sphinxupquote{origin}} for updates, not the original
\sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset.

\sphinxAtStartPar
Let’s check the contents in \sphinxcode{\sphinxupquote{notes.txt}} to see whether
the previously missing changes are now present:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} view the last 15 lines of notes.txt}
\PYG{g+gp}{\PYGZdl{} }tail\PYG{+w}{ }notes.txt

\PYG{g+go}{Note that a recursive \PYGZdq{}datalad get\PYGZdq{} would install all further}
\PYG{g+go}{registered subdatasets underneath a subdataset, so a safer way to}
\PYG{g+go}{proceed is to set a decent \PYGZhy{}\PYGZhy{}recursion\PYGZhy{}limit:}
\PYG{g+go}{\PYGZdq{}datalad get \PYGZhy{}n \PYGZhy{}r \PYGZhy{}\PYGZhy{}recursion\PYGZhy{}limit 2 \PYGZlt{}subds\PYGZgt{}\PYGZdq{}}

\PYG{g+go}{The command \PYGZdq{}git annex whereis PATH\PYGZdq{} lists the repositories that have}
\PYG{g+go}{the file content of an annexed file. When using \PYGZdq{}datalad get\PYGZdq{} to}
\PYG{g+go}{retrieve file content, those repositories will be queried.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Wohoo, the contents are here!

\sphinxAtStartPar
Therefore, sharing DataLad datasets by installing them
enables you to update the datasets content should the
original datasets’ content change \textendash{} in only a single
command. How cool is that?!

\sphinxAtStartPar
Conclude this section by adding a note about updating a
dataset to your own \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} navigate back:}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../../DataLad\PYGZhy{}101

\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} write the note}
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }notes.txt
\PYG{g+go}{To update a shared dataset, run the command \PYGZdq{}datalad update \PYGZhy{}\PYGZhy{}how merge\PYGZdq{}.}
\PYG{g+go}{This command will query its origin for changes, and integrate the}
\PYG{g+go}{changes into the dataset.}

\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} save the changes}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add note about datalad update\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
PS: You might wonder what a plain \sphinxcode{\sphinxupquote{datalad update}} command with no option does.
If you are a Git\sphinxhyphen{}user and know about branches and merging you can read the
\sphinxcode{\sphinxupquote{Note for Git\sphinxhyphen{}users}}. However, a thorough explanation
and demonstration will be in the next section.

\index{update@\spxentry{update}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!update@\spxentry{update}}\ignorespaces \begin{gitusernote}[label={index-2}, before title={\thetcbcounter\ }, check odd page=true]{Update internals}
\label{\detokenize{basics/101-119-sharelocal4:index-2}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad update}} is the DataLad equivalent of a \sphinxcode{\sphinxupquote{git fetch}},
\sphinxcode{\sphinxupquote{datalad update \sphinxhyphen{}\sphinxhyphen{}how merge}} is the DataLad equivalent of a
\sphinxcode{\sphinxupquote{git pull}}.
Upon a simple \sphinxcode{\sphinxupquote{datalad update}}, the remote information
is available on a branch separate from the main branch
\textendash{} in most cases this will be \sphinxcode{\sphinxupquote{remotes/origin/main}}.
You can \sphinxcode{\sphinxupquote{git checkout}} this branch or run \sphinxcode{\sphinxupquote{git diff}} to
explore the changes and identify potential merge conflicts.


\end{gitusernote}

\sphinxstepscope

\index{update dataset@\spxentry{update dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!update dataset@\spxentry{update dataset}}\ignorespaces 

\section{Networking}
\label{\detokenize{basics/101-121-siblings:networking}}\label{\detokenize{basics/101-121-siblings:sibling}}\label{\detokenize{basics/101-121-siblings:index-0}}\label{\detokenize{basics/101-121-siblings::doc}}
\sphinxAtStartPar
To get a hang on the basics of sharing a dataset,
you shared your \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset with your
room mate on a common, local file system. Your lucky
room mate now has your notes and can thus try to catch
up to still pass the course.
Moreover, though, he can also integrate all other notes
or changes you make to your dataset, and stay up to date.
This is because a DataLad dataset makes updating shared
data a matter of a single \sphinxcode{\sphinxupquote{datalad update \sphinxhyphen{}\sphinxhyphen{}how merge}} command.

\sphinxAtStartPar
But why does this need to be a one\sphinxhyphen{}way street? “I want to
provide helpful information for you as well!”, says your
room mate. “How could you get any insightful notes that
I make in my dataset, or maybe the results of our upcoming
mid\sphinxhyphen{}term project? Its a bit unfair that I can get your work,
but you cannot get mine.”

\index{register file with URL in dataset@\spxentry{register file with URL in dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!register file with URL in dataset@\spxentry{register file with URL in dataset}}\ignorespaces 
\sphinxAtStartPar
Consider, for example, that your room mate might have googled about DataLad
a bit. In the depths of the web, he might have found useful additional information, such
a script on \sphinxhref{https://raw.githubusercontent.com/datalad/datalad.org/7e8e39b1/content/asciicast/seamless\_nested\_repos.sh}{dataset nesting}.
Because he found this very helpful in understanding dataset
nesting concepts, he decided to download it from GitHub, and saved it in the \sphinxcode{\sphinxupquote{code/}} directory.

\sphinxAtStartPar
He does it using the DataLad command \sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}}
that you experienced in section {\hyperref[\detokenize{basics/101-101-create:createds}]{\sphinxcrossref{\DUrole{std,std-ref}{Create a dataset}}}} (\autopageref*{\detokenize{basics/101-101-create:createds}}) already: This command will
download a file just as \sphinxcode{\sphinxupquote{wget}}, but it can also take a commit message
and will save the download right to the history of the dataset that you specify,
while recording its origin as provenance information.

\sphinxAtStartPar
Navigate into your dataset copy in \sphinxcode{\sphinxupquote{mock\_user/DataLad\sphinxhyphen{}101}},
and run the following command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} navigate into the installed copy}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../mock\PYGZus{}user/DataLad\PYGZhy{}101

\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} download the shell script and save it in your code/ directory}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }download\PYGZhy{}url\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Include nesting demo from datalad website\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}O\PYG{+w}{ }code/nested\PYGZus{}repos.sh\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }https://raw.githubusercontent.com/datalad/datalad.org/7e8e39b1/content/asciicast/seamless\PYGZus{}nested\PYGZus{}repos.sh
\PYG{g+go}{download\PYGZus{}url(ok): /home/me/dl\PYGZhy{}101/mock\PYGZus{}user/DataLad\PYGZhy{}101/code/nested\PYGZus{}repos.sh (file)}
\PYG{g+go}{add(ok): code/nested\PYGZus{}repos.sh (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Run a quick \sphinxcode{\sphinxupquote{datalad status}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\sphinxAtStartPar
Nice, the \sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}} command saved this download
right into the history, and \sphinxcode{\sphinxupquote{datalad status}} does not report
unsaved modifications! We’ll show an excerpt of the last commit
here%
\begin{footnote}[1]\sphinxAtStartFootnote
As this example, simplistically, created a “pretend” room mate by only changing directories, not user accounts, the recorded Git identity of your “room mate” will, of course, be the same as yours.
%
\end{footnote}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYGZhy{}p
\PYG{g+go}{commit 5b6e19a5✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    Include nesting demo from datalad website}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/code/nested\PYGZus{}repos.sh b/code/nested\PYGZus{}repos.sh}
\PYG{g+go}{new file mode 100644}
\PYG{g+go}{index 0000000..f84c817}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/code/nested\PYGZus{}repos.sh}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1,59 @@}
\end{sphinxVerbatim}

\sphinxAtStartPar
Suddenly, your room mate has a file change that you do not have.
His dataset evolved.

\sphinxAtStartPar
So how do we link back from the copy of the dataset to its
origin, such that your room mate’s changes can be included in
your dataset? How do we let the original dataset “know” about
this copy your room mate has?
Do we need to install the installed dataset of our room mate
as a copy again?

\sphinxAtStartPar
No, luckily, it’s simpler and less convoluted. What we have to
do is to \sphinxstyleemphasis{register} a DataLad {\hyperref[\detokenize{glossary:term-sibling}]{\sphinxtermref{\DUrole{xref,std,std-term}{sibling}}}}: A reference to our room mate’s
dataset in our own, original dataset.

\index{sibling@\spxentry{sibling}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!sibling@\spxentry{sibling}}\ignorespaces \begin{gitusernote}[label={index-2}, before title={\thetcbcounter\ }, check odd page=true]{Remote siblings}
\label{\detokenize{basics/101-121-siblings:index-2}}

\sphinxAtStartPar
Git repositories can configure clones of a dataset as \sphinxstyleemphasis{remotes} in
order to fetch, pull, or push from and to them. A \sphinxcode{\sphinxupquote{datalad sibling}}
is the equivalent of a git clone that is configured as a remote.


\end{gitusernote}

\sphinxAtStartPar
Let’s see how this is done.

\index{siblings@\spxentry{siblings}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!siblings@\spxentry{siblings}}\index{register sibling in dataset@\spxentry{register sibling in dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!register sibling in dataset@\spxentry{register sibling in dataset}}\ignorespaces 
\sphinxAtStartPar
First of all, navigate back into the original dataset.
In the original dataset, “add” a “sibling” by using
the \sphinxcode{\sphinxupquote{datalad siblings}} command.
The command takes the base command,
\sphinxcode{\sphinxupquote{datalad siblings}}, an action, in this case \sphinxcode{\sphinxupquote{add}}, a path to the
root of the dataset \sphinxcode{\sphinxupquote{\sphinxhyphen{}d .}}, a name for the sibling, \sphinxcode{\sphinxupquote{\sphinxhyphen{}s/\sphinxhyphen{}\sphinxhyphen{}name roommate}},
and a URL or path to the sibling, \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}url ../mock\_user/DataLad\sphinxhyphen{}101}}.
This registers your room mate’s \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} as a “sibling” (we will call it
“roommate”) to your own \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../../DataLad\PYGZhy{}101
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} add a sibling}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }siblings\PYG{+w}{ }add\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}name\PYG{+w}{ }roommate\PYG{+w}{ }\PYGZhy{}\PYGZhy{}url\PYG{+w}{ }../mock\PYGZus{}user/DataLad\PYGZhy{}101
\PYG{g+go}{.: roommate(+) [../mock\PYGZus{}user/DataLad\PYGZhy{}101 (git)]}
\end{sphinxVerbatim}

\sphinxAtStartPar
There are a few confusing parts about this command: For one, do not be surprised
about the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}url}} argument \textendash{} it’s called “URL” but it can be a path as well.
Also, do not forget to give a name to your dataset’s sibling. Without the \sphinxcode{\sphinxupquote{\sphinxhyphen{}s}}/
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}name}} argument the command will fail. The reason behind this is that the default
name of a sibling if no name is given will be the host name of the specified URL,
but as you provide a path and not a URL, there is no host name to take as a default.

\sphinxAtStartPar
As you can see in the command output, the addition of a {\hyperref[\detokenize{glossary:term-sibling}]{\sphinxtermref{\DUrole{xref,std,std-term}{sibling}}}} succeeded:
\sphinxcode{\sphinxupquote{roommate(+){[}../mock\_user/DataLad\sphinxhyphen{}101{]}}} means that your room mate’s dataset
is now known to your own dataset as “roommate”.

\index{list dataset siblings@\spxentry{list dataset siblings}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!list dataset siblings@\spxentry{list dataset siblings}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-121-siblings:index-4}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }siblings
\PYG{g+go}{.: here(+) [git]}
\PYG{g+go}{.: roommate(+) [../mock\PYGZus{}user/DataLad\PYGZhy{}101 (git)]}
\end{sphinxVerbatim}

\sphinxAtStartPar
This command will list all known siblings of the dataset. You can see it
in the resulting list with the name “roommate” you have given to it.
And just as a brief remark: siblings do not have to stay around forever.
Check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-remove-sibling}} {\hyperref[\detokenize{basics/101-121-siblings:fom-remove-sibling}]{\sphinxcrossref{\DUrole{std,std-ref}{on removing a sibling}}}} (\autopageref*{\detokenize{basics/101-121-siblings:fom-remove-sibling}}).

\index{remove dataset sibling@\spxentry{remove dataset sibling}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!remove dataset sibling@\spxentry{remove dataset sibling}}\ignorespaces \begin{findoutmore}[label={fom-remove-sibling}, before title={\thetcbcounter\ }, float, floatplacement=tbp, check odd page=true]{What if I mistyped the name or want to remove the sibling?}
\label{\detokenize{basics/101-121-siblings:fom-remove-sibling}}

\sphinxAtStartPar
You can remove a sibling using \sphinxcode{\sphinxupquote{datalad siblings remove \sphinxhyphen{}s roommate}}


\end{findoutmore}

\sphinxAtStartPar
The fact that the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset now has a sibling means that we
can also \sphinxcode{\sphinxupquote{datalad update}} this repository. Awesome!

\sphinxAtStartPar
Your room mate previously ran a \sphinxcode{\sphinxupquote{datalad update \sphinxhyphen{}\sphinxhyphen{}how merge}} in the section
{\hyperref[\detokenize{basics/101-119-sharelocal4:update}]{\sphinxcrossref{\DUrole{std,std-ref}{Stay up to date}}}} (\autopageref*{\detokenize{basics/101-119-sharelocal4:update}}). This got him
changes \sphinxstyleemphasis{he knew you made} into a dataset that \sphinxstyleemphasis{he so far did not change}.
This meant that nothing unexpected would happen with the
\sphinxcode{\sphinxupquote{datalad update \sphinxhyphen{}\sphinxhyphen{}how merge}}.

\sphinxAtStartPar
But consider the current case: Your room mate made changes to his
dataset, but you do not necessarily know which. You also made
changes to your dataset in the meantime, and added a note on
\sphinxcode{\sphinxupquote{datalad update}}.
How would you know that his changes and
your changes are not in conflict with each other?

\sphinxAtStartPar
This scenario is where a plain \sphinxcode{\sphinxupquote{datalad update}} becomes useful.
If you run a plain \sphinxcode{\sphinxupquote{datalad update}} (which uses the default option \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}how fetch}}), DataLad will query the sibling
for changes, and store those changes in a safe place in your own
dataset, \sphinxstyleemphasis{but it will not yet integrate them into your dataset}.
This gives you a chance to see whether you actually want to have the
changes your room mate made.

\index{update dataset from particular sibling@\spxentry{update dataset from particular sibling}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!update dataset from particular sibling@\spxentry{update dataset from particular sibling}}\ignorespaces 
\sphinxAtStartPar
Let’s see how it’s done. First, run a plain \sphinxcode{\sphinxupquote{datalad update}} without
the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}how merge}} option.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }update\PYG{+w}{ }\PYGZhy{}s\PYG{+w}{ }roommate
\PYG{g+go}{update(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that we supplied the sibling’s name with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}s}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}name}} option.
This is good practice, and allows you to be precise in where you want to get
updates from. It would have worked without the specification (just as a bare
\sphinxcode{\sphinxupquote{datalad update \sphinxhyphen{}\sphinxhyphen{}how merge}} worked for your room mate), because there is only
one other known location, though.

\sphinxAtStartPar
This plain \sphinxcode{\sphinxupquote{datalad update}} “fetched” updates from
the dataset. The changes however, are not yet visible \textendash{} the script that
he added is not yet in your \sphinxcode{\sphinxupquote{code/}} directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }code/
\PYG{g+go}{list\PYGZus{}titles.sh}
\end{sphinxVerbatim}

\sphinxAtStartPar
So where is the file? It is in a different \sphinxstyleemphasis{branch} of your dataset.

\sphinxAtStartPar
If you do not use {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}}, the concept of a {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} can be a big
source of confusion. There will be sections later in this book that will
elaborate a bit more what branches are, and how to work with them, but
for now envision a branch just like a bunch of drawers on your desk.
The paperwork that you have in front of you right on your desk is your
dataset as you currently see it.
These drawers instead hold documents that you are in principle working on,
just not now \textendash{} maybe different versions of paperwork you currently have in
front of you, or maybe other files than the ones currently in front of you
on your desk.

\sphinxAtStartPar
Imagine that a \sphinxcode{\sphinxupquote{datalad update}} created a small drawer, placed all of
the changed or added files from the sibling inside, and put it on your
desk. You can now take a look into that drawer to see whether you want
to have the changes right in front of you.

\sphinxAtStartPar
The drawer is a branch, and it is usually called \sphinxcode{\sphinxupquote{remotes/origin/main}}.
To look inside of it you can \sphinxcode{\sphinxupquote{git checkout BRANCHNAME}}, or you can
do a \sphinxcode{\sphinxupquote{diff}} between the branch (your drawer) and the dataset as it
is currently in front of you (your desk). We will do the latter, and leave
the former for a different lecture. Make sure to see the
\textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-datalad-diff-calls}} {\hyperref[\detokenize{basics/101-121-siblings:ww-datalad-diff-calls}]{\sphinxcrossref{\DUrole{std,std-ref}{on using \textquotesingle{}datalad diff\textquotesingle{}}}}} (\autopageref*{\detokenize{basics/101-121-siblings:ww-datalad-diff-calls}}) too.

\index{corresponding branch@\spxentry{corresponding branch}!in adjusted mode@\spxentry{in adjusted mode}}\index{in adjusted mode@\spxentry{in adjusted mode}!corresponding branch@\spxentry{corresponding branch}}\index{show dataset modification for particular path@\spxentry{show dataset modification for particular path}!on Windows with DataLad@\spxentry{on Windows with DataLad}}\index{on Windows with DataLad@\spxentry{on Windows with DataLad}!show dataset modification for particular path@\spxentry{show dataset modification for particular path}}\index{diff@\spxentry{diff}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!diff@\spxentry{diff}}\ignorespaces \begin{windowswit}[label={ww-datalad-diff-calls}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{‘datalad diff’ needs the corresponding branch}
\label{\detokenize{basics/101-121-siblings:ww-datalad-diff-calls}}

\sphinxAtStartPar
Please use the following command instead:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }diff\PYG{+w}{ }\PYGZhy{}\PYGZhy{}from\PYG{+w}{ }main\PYG{+w}{ }\PYGZhy{}\PYGZhy{}to\PYG{+w}{ }remotes/roommate/main
\end{sphinxVerbatim}

\sphinxAtStartPar
This syntax specifies the {\hyperref[\detokenize{glossary:term-main}]{\sphinxtermref{\DUrole{xref,std,std-term}{main}}}} {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} as a starting point for the comparison instead of the current \sphinxcode{\sphinxupquote{adjusted/main(unlocked)}} branch.


\end{windowswit}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }diff\PYG{+w}{ }\PYGZhy{}\PYGZhy{}to\PYG{+w}{ }remotes/roommate/main
\PYG{g+go}{    added: code/nested\PYGZus{}repos.sh (file)}
\PYG{g+go}{ modified: notes.txt (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This shows us that there is an additional file, and it also shows us
that there is a difference in \sphinxcode{\sphinxupquote{notes.txt}}! Let’s ask
\sphinxcode{\sphinxupquote{git diff}} to show us what the differences in detail (note that it is a shortened excerpt, cut in the middle to reduce its length):
Again, check the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-git-diff-calls}} {\hyperref[\detokenize{basics/101-121-siblings:ww-git-diff-calls}]{\sphinxcrossref{\DUrole{std,std-ref}{on using \textquotesingle{}git diff\textquotesingle{}}}}} (\autopageref*{\detokenize{basics/101-121-siblings:ww-git-diff-calls}}) too.

\index{corresponding branch@\spxentry{corresponding branch}!in adjusted mode@\spxentry{in adjusted mode}}\index{in adjusted mode@\spxentry{in adjusted mode}!corresponding branch@\spxentry{corresponding branch}}\index{show dataset modification@\spxentry{show dataset modification}!on Windows with Git@\spxentry{on Windows with Git}}\index{on Windows with Git@\spxentry{on Windows with Git}!show dataset modification@\spxentry{show dataset modification}}\index{diff@\spxentry{diff}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!diff@\spxentry{diff}}\ignorespaces \begin{windowswit}[label={ww-git-diff-calls}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{‘git diff’ needs the corresponding branch}
\label{\detokenize{basics/101-121-siblings:ww-git-diff-calls}}

\sphinxAtStartPar
Please use the following command instead:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }diff\PYG{+w}{ }main..remotes/roommate/main
\end{sphinxVerbatim}

\sphinxAtStartPar
This is {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}}s syntax for specifying a comparison between two {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}}es.


\end{windowswit}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }diff\PYG{+w}{ }remotes/roommate/main
\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/code/nested\PYGZus{}repos.sh b/code/nested\PYGZus{}repos.sh}
\PYG{g+go}{deleted file mode 100644}
\PYG{g+go}{index f84c817..0000000}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} a/code/nested\PYGZus{}repos.sh}
\PYG{g+go}{+++ /dev/null}
\PYG{g+go}{@@ \PYGZhy{}1,59 +0,0 @@}
\PYG{g+go}{\PYGZhy{}\PYGZsh{}!/bin/bash}
\PYG{g+go}{\PYGZhy{}\PYGZsh{} This script was converted using cast2script from:}
\PYG{g+go}{\PYGZhy{}\PYGZsh{} docs/casts/seamless\PYGZus{}nested\PYGZus{}repos.sh}
\PYG{g+go}{\PYGZhy{}set \PYGZhy{}e \PYGZhy{}u}
\PYG{g+go}{\PYGZhy{}export GIT\PYGZus{}PAGER=cat}
\PYG{g+go}{\PYGZhy{}}
\PYG{g+go}{\PYGZhy{}\PYGZsh{} DataLad provides seamless management of nested Git repositories...}
\PYG{g+go}{\PYGZhy{}}
\PYG{g+go}{\PYGZhy{}\PYGZsh{} Let\PYGZsq{}s create a dataset}
\PYG{g+go}{\PYGZhy{}datalad create demo}
\PYG{g+go}{\PYGZhy{}cd demo}
\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/notes.txt b/notes.txt}
\PYG{g+go}{index 655be7d..ff02f68 100644}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} a/notes.txt}
\PYG{g+go}{+++ b/notes.txt}
\PYG{g+go}{@@ \PYGZhy{}59,3 +59,7 @@ The command \PYGZdq{}git annex whereis PATH\PYGZdq{} lists the repositories that have}
\PYG{g+go}{ the file content of an annexed file. When using \PYGZdq{}datalad get\PYGZdq{} to}
\PYG{g+go}{ retrieve file content, those repositories will be queried.}

\PYG{g+go}{+To update a shared dataset, run the command \PYGZdq{}datalad update \PYGZhy{}\PYGZhy{}how merge\PYGZdq{}.}
\PYG{g+go}{+This command will query its origin for changes, and integrate the}
\PYG{g+go}{+changes into the dataset.}
\PYG{g+go}{+}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s digress into what is shown here.
We are comparing the current state of your dataset against
the current state of your room mate’s dataset. Everything marked with
a \sphinxcode{\sphinxupquote{\sphinxhyphen{}}} is a change that your room mate has, but not you: This is the
script that he downloaded!

\sphinxAtStartPar
Everything that is marked with a \sphinxcode{\sphinxupquote{+}} is a change that you have,
but not your room mate: It is the additional note on \sphinxcode{\sphinxupquote{datalad update}}
you made in your own dataset in the previous section.

\sphinxAtStartPar
Cool! So now that you know what the changes are that your room mate
made, you can safely \sphinxcode{\sphinxupquote{datalad update \sphinxhyphen{}\sphinxhyphen{}how merge}} them to integrate
them into your dataset. In technical terms you will
“\sphinxstyleemphasis{merge the branch remotes/roommate/main into main}”.
But the details of this will be stated in a standalone section later.

\sphinxAtStartPar
Note that the fact that your room mate does not have the note
on \sphinxcode{\sphinxupquote{datalad update}} does not influence your note. It will not
get deleted by the merge. You do not set your dataset to the state
of your room mate’s dataset, but you incorporate all changes he made
\textendash{} which is only the addition of the script.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }update\PYG{+w}{ }\PYGZhy{}\PYGZhy{}how\PYG{+w}{ }merge\PYG{+w}{ }\PYGZhy{}s\PYG{+w}{ }roommate
\PYG{g+go}{merge(ok): . (dataset) [Merged roommate/main]}
\PYG{g+go}{update.annex\PYGZus{}merge(ok): . (dataset) [Merged annex branch]}
\PYG{g+go}{update(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The exciting question is now whether your room mate’s change is now
also part of your own dataset. Let’s list the contents of the \sphinxcode{\sphinxupquote{code/}}
directory and also peek into the history:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }code/
\PYG{g+go}{list\PYGZus{}titles.sh}
\PYG{g+go}{nested\PYGZus{}repos.sh}
\end{sphinxVerbatim}

\fvset{hllines={, 2, 4,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{6ae8e71 Merge remote\PYGZhy{}tracking branch \PYGZsq{}roommate/main\PYGZsq{}}
\PYG{g+go}{4bb5d39 add note about datalad update}
\PYG{g+go}{5b6e19a Include nesting demo from datalad website}
\PYG{g+go}{adb4b5d add note on git annex whereis}
\PYG{g+go}{1e73592 add note about cloning from paths and recursive datalad get}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Wohoo! Here it is: The script now also exists in your own dataset.
You can see the commit that your room mate made when he saved the script,
and you can also see a commit that records how you \sphinxcode{\sphinxupquote{merged}} your
room mate’s dataset changes into your own dataset. The commit message of this
latter commit for now might contain many words yet unknown to you if you
do not use Git, but a later section will get into the details of what
the meaning of “{\hyperref[\detokenize{glossary:term-merge}]{\sphinxtermref{\DUrole{xref,std,std-term}{merge}}}}”, “{\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}}”, “refs”
or “{\hyperref[\detokenize{glossary:term-main}]{\sphinxtermref{\DUrole{xref,std,std-term}{main}}}}” is.

\sphinxAtStartPar
For now, you are happy to have the changes your room mate made available.
This is how it should be! You helped him, and he helps you. Awesome!
There actually is a wonderful word for it: \sphinxstyleemphasis{Collaboration}.
Thus, without noticing, you have successfully collaborated for the first
time using DataLad datasets.

\sphinxAtStartPar
Create a note about this, and save it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }notes.txt
\PYG{g+go}{To update from a dataset with a shared history, you need to add this}
\PYG{g+go}{dataset as a sibling to your dataset. \PYGZdq{}Adding a sibling\PYGZdq{} means}
\PYG{g+go}{providing DataLad with info about the location of a dataset, and a}
\PYG{g+go}{name for it.}
\PYG{g+go}{Afterwards, a \PYGZdq{}datalad update \PYGZhy{}\PYGZhy{}how merge \PYGZhy{}s name\PYGZdq{} will integrate the}
\PYG{g+go}{changes made to the sibling into the dataset. A safe step in between}
\PYG{g+go}{is to do a \PYGZdq{}datalad update \PYGZhy{}s name\PYGZdq{} and checkout the changes with}
\PYG{g+go}{\PYGZdq{}git/datalad diff\PYGZdq{} to remotes/origin/main}

\PYG{g+go}{EOT}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Add note on adding siblings\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Summary}
\label{\detokenize{basics/101-120-summary:summary}}\label{\detokenize{basics/101-120-summary:summary-sharelocal}}\label{\detokenize{basics/101-120-summary::doc}}
\sphinxAtStartPar
Together with your room mate you have just discovered how
to share, update, and collaborate on a DataLad dataset on a shared file system.
Thus, you have glimpsed into the principles and advantages of
sharing a dataset with a simple example.
\begin{itemize}
\item {} 
\sphinxAtStartPar
To obtain a dataset, one can also use \sphinxcode{\sphinxupquote{datalad clone}} with a path.
Potential subdatasets will not be installed right away. As they are registered in
the superdataset, you can
\begin{itemize}
\item {} 
\sphinxAtStartPar
do \sphinxcode{\sphinxupquote{datalad get \sphinxhyphen{}n/\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}data}}

\item {} 
\sphinxAtStartPar
or specify the \sphinxcode{\sphinxupquote{\sphinxhyphen{}r}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}recursive}}: \sphinxcode{\sphinxupquote{datalad get \sphinxhyphen{}n \sphinxhyphen{}r \textless{}subds\textgreater{}}}

\end{itemize}

\sphinxAtStartPar
with a decent \sphinxcode{\sphinxupquote{\sphinxhyphen{}R/\sphinxhyphen{}\sphinxhyphen{}recursion\sphinxhyphen{}limit}} choice to install them afterwards.

\item {} 
\sphinxAtStartPar
The configuration of the original dataset determines which types
of files will have their content available right after the installation of
the dataset, and which types of files need to be retrieved via
\sphinxcode{\sphinxupquote{datalad get}}: Any file content stored in {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} will be available
right away, while all file content that is \sphinxcode{\sphinxupquote{annexed}} only has
small metadata about its availability attached to it. The original
\sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset used the \sphinxcode{\sphinxupquote{text2git}} configuration template
to store text files such as \sphinxcode{\sphinxupquote{notes.txt}} and \sphinxcode{\sphinxupquote{code/list\_titles.sh}}
in Git \textendash{} these files’ content is therefore available right after
installation.

\item {} 
\sphinxAtStartPar
Annexed content can be retrieved via \sphinxcode{\sphinxupquote{datalad get}} from the
file content sources.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{git annex whereis PATH}} will list all locations known to contain file
content for a particular file. It is a very
helpful command to find out where file content resides, and how many
locations with copies exist. {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} will try to retrieve file contents from those locations. If you want, you can describe locations with the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}description}} provided during a \sphinxcode{\sphinxupquote{datalad create}}.

\item {} 
\sphinxAtStartPar
A shared copy of a dataset includes the datasets history. If well made,
\sphinxcode{\sphinxupquote{datalad run}} commands can then easily be \sphinxcode{\sphinxupquote{rerun}}.

\item {} 
\sphinxAtStartPar
Because an installed dataset knows its origin \textendash{} the place it was
originally installed from \textendash{} it can be kept up\sphinxhyphen{}to\sphinxhyphen{}date with the
\sphinxcode{\sphinxupquote{datalad update}} command. This command will query the origin of the
dataset for updates, and a \sphinxcode{\sphinxupquote{datalad update \sphinxhyphen{}\sphinxhyphen{}how merge}} will integrate
these changes into the dataset copy.

\item {} 
\sphinxAtStartPar
Thus, using DataLad, data can be easily shared and kept up to date
with only two commands: \sphinxcode{\sphinxupquote{datalad clone}} and \sphinxcode{\sphinxupquote{datalad update}}.

\item {} 
\sphinxAtStartPar
By configuring a dataset as a {\hyperref[\detokenize{glossary:term-sibling}]{\sphinxtermref{\DUrole{xref,std,std-term}{sibling}}}}, collaboration becomes easy.

\item {} 
\sphinxAtStartPar
To avoid integrating conflicting modifications of a sibling dataset into your
own dataset, a \sphinxcode{\sphinxupquote{datalad update \sphinxhyphen{}s SIBLINGNAME}} will “\sphinxcode{\sphinxupquote{fetch}}” modifications
and store them on a different {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} of your dataset. The commands
\sphinxcode{\sphinxupquote{datalad diff}} and \sphinxcode{\sphinxupquote{git diff}} can subsequently help to find
out what changes have been made in the sibling.

\end{itemize}


\subsection{Now what can I do with that?}
\label{\detokenize{basics/101-120-summary:now-what-can-i-do-with-that}}
\sphinxAtStartPar
Most importantly, you have experienced the first way of sharing
and updating a dataset.
The example here may strike you as too simplistic, but in later parts of
the book you will see examples in which datasets are shared on the same
file system in surprisingly useful ways.

\sphinxAtStartPar
Simultaneously, you have observed dataset properties you already knew
(for example, how annexed files need to be retrieved via \sphinxcode{\sphinxupquote{datalad get}}),
but you have also seen novel aspects of a dataset \textendash{} for example, that
subdatasets are not automatically installed by default, how
\sphinxcode{\sphinxupquote{git annex whereis}} can help you find out where file content might be stored,
how useful commands that capture provenance about the origin or creation of files
(such as \sphinxcode{\sphinxupquote{datalad run}} or \sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}}) are,
or how a shared dataset can be updated to reflect changes that were made
to the original dataset.

\sphinxAtStartPar
Also, you have successfully demonstrated a large number of DataLad dataset
principles to your room mate: How content stored in Git is present right
away and how annexed content first needs to be retrieved, how easy a
\sphinxcode{\sphinxupquote{datalad rerun}} is if the original \sphinxcode{\sphinxupquote{datalad run}} command was well
specified, how a datasets history is shared and not only its data.

\sphinxAtStartPar
Lastly, with the configuration of a sibling, you have experienced one
way to collaborate in a dataset, and with \sphinxcode{\sphinxupquote{datalad update \sphinxhyphen{}\sphinxhyphen{}how merge}}
and \sphinxcode{\sphinxupquote{datalad update}}, you also glimpsed into more advances aspects
of Git, namely the concept of a branch.

\sphinxAtStartPar
Therefore, these last few sections have hopefully been a good review
of what you already knew, but also a big knowledge gain, and cause
joyful anticipation of collaboration in a real\sphinxhyphen{}world setting of one
of your own use cases.

\sphinxstepscope


\chapter{Tuning datasets to your needs}
\label{\detokenize{basics/basics-configuration:tuning-datasets-to-your-needs}}\label{\detokenize{basics/basics-configuration:chapter-config}}\label{\detokenize{basics/basics-configuration:id1}}\label{\detokenize{basics/basics-configuration::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{settings}.pdf}\hspace*{\fill}}

\sphinxstepscope

\index{configuration@\spxentry{configuration}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!configuration@\spxentry{configuration}}\index{configuration@\spxentry{configuration}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!configuration@\spxentry{configuration}}\ignorespaces 

\section{Local configuration}
\label{\detokenize{basics/101-122-config:local-configuration}}\label{\detokenize{basics/101-122-config:config}}\label{\detokenize{basics/101-122-config:index-0}}\label{\detokenize{basics/101-122-config::doc}}
\sphinxAtStartPar
Back in section {\hyperref[\detokenize{basics/101-114-txt2git:text2git}]{\sphinxcrossref{\DUrole{std,std-ref}{Data safety}}}} (\autopageref*{\detokenize{basics/101-114-txt2git:text2git}}), you already learned that there
are dataset configurations, and that these configurations can
be modified, for example, with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}c text2git}} option.
This option applies a configuration template to store text
files in {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} instead of {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}, and thereby
modifies the DataLad dataset’s default configuration to store
every file in git\sphinxhyphen{}annex.

\sphinxAtStartPar
The lecture today focuses entirely on the topic of configurations,
and aims to equip everyone with the basics to configure
their general and dataset specific setup to their needs.
This is not only a handy way to tune a dataset to one’s
wishes, but also helpful to understand potential differences in
command execution and file handling between two users,
computers, or datasets.

\sphinxAtStartPar
“First of all, when we talk about configurations, we have
to differentiate between different scopes of configuration,
and different tools the configuration belongs or applies to”,
our lecturer starts. “In DataLad datasets, different tools can
have a configuration: {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}}, {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}, and
DataLad itself. Because these tools are all
combined by DataLad to help you manage your data,
it is important to understand how the configuration of one
software is used by or influences a second tool, or the overall
dataset performance.”

\sphinxAtStartPar
“Oh crap, one of these theoretical lectures again” mourns a
student from the row behind you. Personally, you’d also
be much more excited
about any hands\sphinxhyphen{}on lecture filled with commands. But the
recent lecture about {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} and the {\hyperref[\detokenize{glossary:term-object-tree}]{\sphinxtermref{\DUrole{xref,std,std-term}{object\sphinxhyphen{}tree}}}}
was surprisingly captivating, so you are actually looking forward to today.
“Shht! I want to hear this!”, you shush him with a wink.

\sphinxAtStartPar
“We will start by looking into the very first configuration
you did, already before the course started: The \sphinxstyleemphasis{global}
Git configuration.” the lecturer says.

\index{config@\spxentry{config}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!config@\spxentry{config}}\ignorespaces 
\sphinxAtStartPar
At one point in time, you likely followed instructions such as
in {\hyperref[\detokenize{intro/installation:install}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation and configuration}}}} (\autopageref*{\detokenize{intro/installation:install}}) and configured your
\sphinxstyleemphasis{Git identity} with the commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}\PYGZhy{}global\PYG{+w}{ }\PYGZhy{}\PYGZhy{}add\PYG{+w}{ }user.name\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Elena Piscopia\PYGZdq{}}
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}\PYGZhy{}global\PYG{+w}{ }\PYGZhy{}\PYGZhy{}add\PYG{+w}{ }user.email\PYG{+w}{ }elena@example.net
\end{sphinxVerbatim}

\sphinxAtStartPar
“What the above commands do is very simple: They search for
a specific configuration file, and set the variables specified
in the command \textendash{} in this case user name and user email address
\textendash{} to the values provided with the command.” she explains.

\sphinxAtStartPar
“This general procedure, specifying a value for a configuration
variable in a configuration file, is how you can configure the
different tools to your needs. The configuration, therefore,
is really easy. Even if you are only used to ticking boxes
in the \sphinxcode{\sphinxupquote{settings}} tab of a software tool so far, it’s intuitive
to understand how a configuration file in principle works and also
how to use it. The only piece of information you will need
are the necessary files, or the command that writes to them, and
the available options for configuration, that’s it. And what’s
really cool is that all tools we’ll be looking at \textendash{} Git, git\sphinxhyphen{}annex,
and DataLad \textendash{} can be configured using the \sphinxcode{\sphinxupquote{git config}}
command%
\begin{footnote}[1]\sphinxAtStartFootnote
As an alternative to a \sphinxcode{\sphinxupquote{git config}} command, you could also run configuration
templates or procedures that apply predefined configurations or in some cases even
add the information to the configuration file by hand and save it using an editor of your choice. See {\hyperref[\detokenize{basics/101-124-procedures:procedures}]{\sphinxcrossref{\DUrole{std,std-ref}{Configurations to go}}}} (\autopageref*{\detokenize{basics/101-124-procedures:procedures}}) for more info.
%
\end{footnote}. Therefore, once you understand the syntax of this
command, you already know half of what’s relevant. The other half
is understanding what you are doing. Now then, let’s learn \sphinxstyleemphasis{how}
to configure settings, but also \sphinxstyleemphasis{understand} what we are doing
with these configurations.”

\sphinxAtStartPar
“This seems easy enough”, you think. Let’s see what types of
configurations there are.


\subsection{Git config files}
\label{\detokenize{basics/101-122-config:git-config-files}}
\sphinxAtStartPar
The user name and email configuration
is a \sphinxstyleemphasis{user\sphinxhyphen{}specific} configuration (called \sphinxstyleemphasis{global}
configuration by Git), and therefore applies to your user account.
Wherever on your computer \sphinxstyleemphasis{you} run a Git, git\sphinxhyphen{}annex, or DataLad
command, this global configuration will
associate the name and email address you supplied in
the \sphinxcode{\sphinxupquote{git config}} commands above with this action.
For example, whenever you
\sphinxcode{\sphinxupquote{datalad save}}, the information in this file is used for the
history entry about commit author and email.

\sphinxAtStartPar
Apart from \sphinxstyleemphasis{global} Git configurations, there are also \sphinxstyleemphasis{system\sphinxhyphen{}wide}%
\begin{footnote}[2]\sphinxAtStartFootnote
The third scope of a Git configuration are the system wide configurations.
These are stored (if they exist) in \sphinxcode{\sphinxupquote{/etc/gitconfig}} and contain settings that would
apply to every user on the computer you are using. These configurations
are not relevant for DataLad\sphinxhyphen{}101, and we will thus skip them. You can
read more about Git’s configurations and different files
\sphinxhref{https://git-scm.com/docs/git-config}{here}.
%
\end{footnote}
and \sphinxstyleemphasis{repository} configurations. Each of these configurations
resides in its own file. The global configuration is stored in a file called
\sphinxcode{\sphinxupquote{.gitconfig}} in your home directory. Among
your name and email address, this file can store general
per\sphinxhyphen{}user configurations, such as a default editor%
\begin{footnote}[3]\sphinxAtStartFootnote
If your default editor is {\hyperref[\detokenize{glossary:term-vim}]{\sphinxtermref{\DUrole{xref,std,std-term}{vim}}}} and you do not like this, now can be the time
to change it! Chose either of two options:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
Open up the file with an editor for your choice (e.g., \sphinxhref{https://www.howtogeek.com/42980/the-beginners-guide-to-nano-the-linux-command-line-text-editor}{nano}), and either paste the following configuration or edit it if it already exists:

\end{enumerate}

\sphinxSetupCodeBlockInFootnote
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{[core]}
\PYG{+w}{    }\PYG{n+na}{editor}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{nano}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Run the following command, but exchange \sphinxcode{\sphinxupquote{nano}} with an editor of your choice:

\end{enumerate}

\sphinxSetupCodeBlockInFootnote
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+na}{\PYGZdl{} git config \PYGZhy{}\PYGZhy{}global \PYGZhy{}\PYGZhy{}add core.editor \PYGZdq{}nano\PYGZdq{}}
\end{sphinxVerbatim}
%
\end{footnote}, or highlighting
options.

\sphinxAtStartPar
The \sphinxstyleemphasis{repository\sphinxhyphen{}specific} configurations apply to each individual
repository. Their scope is more limited than the \sphinxstyleemphasis{global}
configuration (namely to a single repository), but it can overrule global
configurations: The more specific the scope of a configuration file is, the more
important it is, and the variables in the more specific configuration
will take precedence over variables in less specific configuration files.
One could, for example, have {\hyperref[\detokenize{glossary:term-vim}]{\sphinxtermref{\DUrole{xref,std,std-term}{vim}}}} configured to be the default editor
on a global scope, but could overrule this by setting the editor to \sphinxcode{\sphinxupquote{nano}}
in a given repository. For this reason, the repository\sphinxhyphen{}specific configuration
does not reside in a file in your home directory, but in \sphinxcode{\sphinxupquote{.git/config}}
within every Git repository (and thus DataLad dataset).

\sphinxAtStartPar
Thus, there are three different scopes of Git configuration, and each is defined
in a \sphinxcode{\sphinxupquote{config}} file in a different location. The configurations will determine
how Git behaves. In principle, all of these files can configure
the same variables differently, but more specific scopes take precedence over broader
scopes. Conveniently, not only can DataLad and git\sphinxhyphen{}annex be configured with
the same command as Git, but in many cases they will also use exactly the same
files as Git for their own configurations.

\index{configuration file@\spxentry{configuration file}!.git/config@\spxentry{.git/config}|spxpagem}\ignorespaces 
\sphinxAtStartPar
Let’s find out how the repository\sphinxhyphen{}specific configuration file in the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}
superdataset looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }.git/config
\PYG{g+go}{[core]}
\PYG{g+go}{	repositoryformatversion = 0}
\PYG{g+go}{	filemode = true}
\PYG{g+go}{	bare = false}
\PYG{g+go}{	logallrefupdates = true}
\PYG{g+go}{[annex]}
\PYG{g+go}{	uuid = 46b169aa\PYGZhy{}bb91\PYGZhy{}42d6\PYGZhy{}be06\PYGZhy{}355d957fb4f7}
\PYG{g+go}{	version = 10}
\PYG{g+go}{[filter \PYGZdq{}annex\PYGZdq{}]}
\PYG{g+go}{	smudge = git\PYGZhy{}annex smudge \PYGZhy{}\PYGZhy{} \PYGZpc{}f}
\PYG{g+go}{	clean = git\PYGZhy{}annex smudge \PYGZhy{}\PYGZhy{}clean \PYGZhy{}\PYGZhy{} \PYGZpc{}f}
\PYG{g+go}{	process = git\PYGZhy{}annex filter\PYGZhy{}process}
\PYG{g+go}{[submodule \PYGZdq{}recordings/longnow\PYGZdq{}]}
\PYG{g+go}{	active = true}
\PYG{g+go}{	url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\PYG{g+go}{[remote \PYGZdq{}roommate\PYGZdq{}]}
\PYG{g+go}{	url = ../mock\PYGZus{}user/DataLad\PYGZhy{}101}
\PYG{g+go}{	fetch = +refs/heads/*:refs/remotes/roommate/*}
\PYG{g+go}{	annex\PYGZhy{}uuid = ✂UUID✂}
\PYG{g+go}{	annex\PYGZhy{}ignore = false}
\end{sphinxVerbatim}

\sphinxAtStartPar
This file consists of so called “sections” with the section names
in square brackets (e.g., \sphinxcode{\sphinxupquote{core}}). Occasionally, a section can have
subsections: This is indicated by subsection names in
quotation marks after the section name. For example, \sphinxcode{\sphinxupquote{roommate}} is a subsection
of the section \sphinxcode{\sphinxupquote{remote}}.
Within each section, \sphinxcode{\sphinxupquote{variable = value}} pairs specify configurations
for the given (sub)section.

\index{configure editor@\spxentry{configure editor}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!configure editor@\spxentry{configure editor}}\ignorespaces 
\sphinxAtStartPar
The first section is called \sphinxcode{\sphinxupquote{core}} \textendash{} as the name suggests,
this configures core Git functionality. There are
\sphinxhref{https://git-scm.com/docs/git-config\#Documentation/git-config.txt-corefileMode}{many more}
configurations than the ones in this config file, but
they are related to Git, and less related or important to the configuration of
a DataLad dataset. We will use this section to showcase the anatomy of the
\sphinxcode{\sphinxupquote{git config}} command. If, for example, you would want to specifically
configure {\hyperref[\detokenize{glossary:term-nano}]{\sphinxtermref{\DUrole{xref,std,std-term}{nano}}}} to be the default editor in this dataset, you
can do it like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}\PYGZhy{}local\PYG{+w}{ }\PYGZhy{}\PYGZhy{}add\PYG{+w}{ }core.editor\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}nano\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The command consists of the base command \sphinxcode{\sphinxupquote{git config}},
a specification of the scope of the configuration with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}local}}
flag, a \sphinxcode{\sphinxupquote{name}} specification consisting of section and key with the
notation \sphinxcode{\sphinxupquote{section.variable}} (here: \sphinxcode{\sphinxupquote{core.editor}}), and finally the value
specification \sphinxcode{\sphinxupquote{"nano"}}.

\sphinxAtStartPar
Let’s see what has changed:

\fvset{hllines={, 7,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }.git/config
\PYG{g+go}{[core]}
\PYG{g+go}{	repositoryformatversion = 0}
\PYG{g+go}{	filemode = true}
\PYG{g+go}{	bare = false}
\PYG{g+go}{	logallrefupdates = true}
\PYG{g+go}{	editor = nano}
\PYG{g+go}{[annex]}
\PYG{g+go}{	uuid = 46b169aa\PYGZhy{}bb91\PYGZhy{}42d6\PYGZhy{}be06\PYGZhy{}355d957fb4f7}
\PYG{g+go}{	version = 10}
\PYG{g+go}{[filter \PYGZdq{}annex\PYGZdq{}]}
\PYG{g+go}{	smudge = git\PYGZhy{}annex smudge \PYGZhy{}\PYGZhy{} \PYGZpc{}f}
\PYG{g+go}{	clean = git\PYGZhy{}annex smudge \PYGZhy{}\PYGZhy{}clean \PYGZhy{}\PYGZhy{} \PYGZpc{}f}
\PYG{g+go}{	process = git\PYGZhy{}annex filter\PYGZhy{}process}
\PYG{g+go}{[submodule \PYGZdq{}recordings/longnow\PYGZdq{}]}
\PYG{g+go}{	active = true}
\PYG{g+go}{	url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\PYG{g+go}{[remote \PYGZdq{}roommate\PYGZdq{}]}
\PYG{g+go}{	url = ../mock\PYGZus{}user/DataLad\PYGZhy{}101}
\PYG{g+go}{	fetch = +refs/heads/*:refs/remotes/roommate/*}
\PYG{g+go}{	annex\PYGZhy{}uuid = ✂UUID✂}
\PYG{g+go}{	annex\PYGZhy{}ignore = false}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
With this additional line in your repository’s Git configuration, \sphinxcode{\sphinxupquote{nano}} will
be used as a default editor regardless of the configuration in your global
or system\sphinxhyphen{}wide configuration. Note that the flag \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}local}} applies the
configuration to your repository’s \sphinxcode{\sphinxupquote{.git/config}} file, whereas \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}global}}
would apply it as a user specific configuration, and \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}system}} as a
system\sphinxhyphen{}wide configuration.
If you would want to change this existing line in your \sphinxcode{\sphinxupquote{.git/config}}
file, you would replace \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}add}} with \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}replace\sphinxhyphen{}all}} such as in:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}\PYGZhy{}local\PYG{+w}{ }\PYGZhy{}\PYGZhy{}replace\PYGZhy{}all\PYG{+w}{ }core.editor\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}vim\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
to configure {\hyperref[\detokenize{glossary:term-vim}]{\sphinxtermref{\DUrole{xref,std,std-term}{vim}}}} to be your default editor.
Note that while being a good toy example, it is not a common thing to
configure repository\sphinxhyphen{}specific editors.

\sphinxAtStartPar
This example demonstrated the structure of a \sphinxcode{\sphinxupquote{git config}}
command. By specifying the \sphinxcode{\sphinxupquote{name}} option with \sphinxcode{\sphinxupquote{section.variable}}
(or \sphinxcode{\sphinxupquote{section.subsection.variable}} if there is a subsection), and
a value, one can configure Git, git\sphinxhyphen{}annex, and DataLad.
\sphinxstyleemphasis{Most} of these configurations will be written to a \sphinxcode{\sphinxupquote{config}} file
of Git, depending on the scope (local, global, system\sphinxhyphen{}wide)
specified in the command. Should you happen to make a mistake,
it is typically simple to rectify things again. Check the
\textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-git-config}} {\hyperref[\detokenize{basics/101-122-config:fom-git-config}]{\sphinxcrossref{\DUrole{std,std-ref}{on \textquotesingle{}git config\textquotesingle{}}}}} (\autopageref*{\detokenize{basics/101-122-config:fom-git-config}}).

\index{unset configuration@\spxentry{unset configuration}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!unset configuration@\spxentry{unset configuration}}\ignorespaces \begin{findoutmore}[label={fom-git-config}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{If things go wrong during Git config}
\label{\detokenize{basics/101-122-config:fom-git-config}}

\sphinxAtStartPar
If something goes wrong during the \sphinxcode{\sphinxupquote{git config}} command,
for example, you end up having two keys of the same name because you
added a key instead of replacing an existing one, you can use the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}unset}} option to remove the line. Alternatively, you can also open
the config file in an editor and remove or change sections by hand.


\end{findoutmore}

\sphinxAtStartPar
The only information you need, therefore, is the name of a section and
variable to configure, and the value you want to specify. But in many cases
it is also useful to find out which configurations are already set in
which way and where. For this, the \sphinxcode{\sphinxupquote{git config \sphinxhyphen{}\sphinxhyphen{}list \sphinxhyphen{}\sphinxhyphen{}show\sphinxhyphen{}origin}}
is useful. It will display all configurations and their location:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}\PYGZhy{}list\PYG{+w}{ }\PYGZhy{}\PYGZhy{}show\PYGZhy{}origin
\PYG{g+go}{file:/home/bob/.gitconfig   user.name=Bob McBobface}
\PYG{g+go}{file:/home/bob/.gitconfig   user.email=bob@mcbobface.com}
\PYG{g+go}{file:.git/config    annex.uuid=1f83595e\PYGZhy{}bcba\PYGZhy{}4226\PYGZhy{}aa2c\PYGZhy{}6f0153eb3c54}
\PYG{g+go}{file:.git/config    annex.backends=MD5E}
\PYG{g+go}{file:.git/config    submodule.recordings/longnow.url=https://github.com/✂}
\PYG{g+go}{file:.git/config    submodule.recordings/longnow.active=true}
\PYG{g+go}{file:.git/config    remote.roommate.url=../mock\PYGZus{}user/onemoredir/DataLad\PYGZhy{}101}
\PYG{g+go}{file:.git/config    remote.roommate.annex\PYGZhy{}uuid=a5ae24de\PYGZhy{}1533\PYGZhy{}4b09\PYGZhy{}98b9\PYGZhy{}cd9ba6bf303c}
\PYG{g+go}{file:.git/config    submodule.longnow.url=https://github.com/✂}
\PYG{g+go}{file:.git/config    submodule.longnow.active=true}
\PYG{g+go}{...}
\end{sphinxVerbatim}

\sphinxAtStartPar
This example shows some configurations in the global \sphinxcode{\sphinxupquote{.gitconfig}}
file, and the configurations within \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101/.git/config}}.
The command is very handy to display all configurations at once to identify
configuration problems, find the right configuration file to make a change to,
or simply remind oneself of the existing configurations, and it is a useful
helper to keep in the back of your head.

\sphinxAtStartPar
At this point you may feel like many of these configurations or the configuration file
inside of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} do not appear to be
intuitively understandable enough to confidently apply changes to them,
or identify necessary changes. And indeed, most of the sections and variables
or values in there are irrelevant for understanding the book, your dataset,
or DataLad, and can just be left as they are. The previous section merely served
to de\sphinxhyphen{}mystify the \sphinxcode{\sphinxupquote{git config}} command and the configuration files.
Nevertheless, it can be helpful to get an overview on the meaning of the
remaining sections in that file, and the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-gitconfig}} {\hyperref[\detokenize{basics/101-122-config:fom-gitconfig}]{\sphinxcrossref{\DUrole{std,std-ref}{on the Git config file}}}} (\autopageref*{\detokenize{basics/101-122-config:fom-gitconfig}}) offers a glimpse at that.

\index{dataset configuration@\spxentry{dataset configuration}}\ignorespaces \begin{findoutmore}[label={fom-gitconfig}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Dissecting a Git config file further}
\label{\detokenize{basics/101-122-config:fom-gitconfig}}

\sphinxAtStartPar
Let’s walk through the Git config file of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}:
As mentioned above, git\sphinxhyphen{}annex will use the
{\hyperref[\detokenize{glossary:term-Git-config-file}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git config file}}}} for some of its configurations, such as the second section.
It lists the repository version and {\hyperref[\detokenize{glossary:term-annex-UUID}]{\sphinxtermref{\DUrole{xref,std,std-term}{annex UUID}}}}%
\begin{footnote}[4]\sphinxAtStartFootnote
A UUID is a universally unique identifier \textendash{} a 128\sphinxhyphen{}bit number
that unambiguously identifies information.
%
\end{footnote} (\sphinxcode{\sphinxupquote{git annex whereis}} displays information about where the
annexed content is with these UUIDs).

\sphinxAtStartPar
You may recognize the fourth part of the configuration, the subsection
\sphinxcode{\sphinxupquote{"recordings/longnow"}} in the section \sphinxcode{\sphinxupquote{submodule}}.
Clearly, this is a reference to the \sphinxcode{\sphinxupquote{longnow}} podcasts
we cloned as a subdataset. The name \sphinxstyleemphasis{submodule} is Git
terminology, and describes a Git repository inside of
another Git repository \textendash{} just like
the super\sphinxhyphen{} and subdataset principles you discovered in the
section {\hyperref[\detokenize{basics/101-106-nesting:nesting}]{\sphinxcrossref{\DUrole{std,std-ref}{Dataset nesting}}}} (\autopageref*{\detokenize{basics/101-106-nesting:nesting}}). When you clone a DataLad dataset
as a subdataset, it gets \sphinxstyleemphasis{registered} in this file.
For each subdataset, an individual submodule entry
will store the information about the subdataset’s
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}source}} or \sphinxstyleemphasis{origin} (the “url”).
Thus, every subdataset in your dataset
will be listed in this file.
If you want, go back to section {\hyperref[\detokenize{basics/101-105-install:installds}]{\sphinxcrossref{\DUrole{std,std-ref}{Install datasets}}}} (\autopageref*{\detokenize{basics/101-105-install:installds}}) to see that the
“url” is the same URL we cloned the longnow dataset from, and
go back to section {\hyperref[\detokenize{basics/101-116-sharelocal:sharelocal1}]{\sphinxcrossref{\DUrole{std,std-ref}{Looking without touching}}}} (\autopageref*{\detokenize{basics/101-116-sharelocal:sharelocal1}}) to remind yourself of
how cloning a dataset with subdatasets looked and felt like.

\sphinxAtStartPar
Another interesting part is the last section, “remote”.
Here we can find the {\hyperref[\detokenize{glossary:term-sibling}]{\sphinxtermref{\DUrole{xref,std,std-term}{sibling}}}} “roommate” we defined
in {\hyperref[\detokenize{basics/101-121-siblings:sibling}]{\sphinxcrossref{\DUrole{std,std-ref}{Networking}}}} (\autopageref*{\detokenize{basics/101-121-siblings:sibling}}). The term {\hyperref[\detokenize{glossary:term-remote}]{\sphinxtermref{\DUrole{xref,std,std-term}{remote}}}} is Git\sphinxhyphen{}terminology and is
used to describe other repositories or DataLad datasets that the
repository knows about.
This file, therefore, is where DataLad \sphinxstyleemphasis{registered} the sibling
with \sphinxcode{\sphinxupquote{datalad siblings add}}, and thanks to it you can
collaborate with your room mate.
The value to the \sphinxcode{\sphinxupquote{url}} variable is a \sphinxstyleemphasis{path}. If at any point
either your superdataset or the remote moves on your file system,
the association between the two datasets breaks \textendash{} this can be fixed by adjusting this
path, and a demonstration of this is in section {\hyperref[\detokenize{basics/101-136-filesystem:file-system}]{\sphinxcrossref{\DUrole{std,std-ref}{Dataset ops}}}} (\autopageref*{\detokenize{basics/101-136-filesystem:file-system}}).
\sphinxtitleref{fetch} contains a specification which parts of the repository are
updated \textendash{} in this case everything (all of the branches).
Lastly, the \sphinxcode{\sphinxupquote{annex\sphinxhyphen{}ignore = false}} configuration allows git\sphinxhyphen{}annex
to query the remote when it tries to retrieve data from annexed content.


\end{findoutmore}

\index{configuration@\spxentry{configuration}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!configuration@\spxentry{configuration}}\index{set configuration@\spxentry{set configuration}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!set configuration@\spxentry{set configuration}}\ignorespaces 

\subsection{The \sphinxstyleliteralintitle{\sphinxupquote{datalad configuration}} command}
\label{\detokenize{basics/101-122-config:the-datalad-configuration-command}}\label{\detokenize{basics/101-122-config:index-6}}
\sphinxAtStartPar
Although this section put a focus on the \sphinxcode{\sphinxupquote{git config}} command, it is important to mention that there also is a \sphinxcode{\sphinxupquote{datalad configuration}} command.
It is not identical to \sphinxcode{\sphinxupquote{git config}}, but while it lacks some feature of \sphinxcode{\sphinxupquote{git config}}, such as the ability to set system\sphinxhyphen{}wide configuration, it has additional features.
Beyond the \sphinxcode{\sphinxupquote{local}} and \sphinxcode{\sphinxupquote{global}} scopes, it also supports {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} specific configurations in the \sphinxcode{\sphinxupquote{.datalad/config}} file (further discussed in the next section), setting configurations recursively through dataset hierarchies, and multi\sphinxhyphen{}configuration queries (such as \sphinxcode{\sphinxupquote{datalad configuration get user.name user.email}}).
By default, \sphinxcode{\sphinxupquote{datalad configuration}} will \sphinxcode{\sphinxupquote{dump}} (list) the effective configuration including relevant \sphinxcode{\sphinxupquote{DATALAD\_*}} {\hyperref[\detokenize{glossary:term-environment-variable}]{\sphinxtermref{\DUrole{xref,std,std-term}{environment variable}}}}s, and also annotate the purpose of many common configuration items.
The subcommands \sphinxcode{\sphinxupquote{datalad configuration get}} or \sphinxcode{\sphinxupquote{datalad configuration set}} perform queries or set configurations.
You can find out more information on this command in the command documentation.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{.git/config}} versus other (configuration) files}
\label{\detokenize{basics/101-122-config:git-config-versus-other-configuration-files}}
\sphinxAtStartPar
One crucial aspect distinguishes the \sphinxcode{\sphinxupquote{.git/config}} file from many other files
in your dataset: Even though it is part of your dataset, it won’t be shared together
with the dataset. The reason for this is that this file is not version
controlled, as it lies within the \sphinxcode{\sphinxupquote{.git}} directory.
Repository\sphinxhyphen{}specific configurations within your \sphinxcode{\sphinxupquote{.git/config}}
file are thus not written to history. Any local configuration in \sphinxcode{\sphinxupquote{.git/config}}
applies to the dataset, but it does not \sphinxstyleemphasis{stick} to the dataset.
One can have the misconception that because the configurations were made \sphinxstyleemphasis{in}
the dataset, these configurations will also be shared together with the dataset.
\sphinxcode{\sphinxupquote{.git/config}}, however, behaves just as your global or system\sphinxhyphen{}wide configurations.
These configurations are in effect on a system, or for a user, or for a dataset,
but are not shared.
A \sphinxcode{\sphinxupquote{datalad clone}} command of someone’s dataset will not get you their
editor configuration, should they have included one in their config file.
Instead, upon a \sphinxcode{\sphinxupquote{datalad clone}}, a new config file will be created.

\sphinxAtStartPar
This means, however, that configurations that should “stick” to a dataset%
\begin{footnote}[5]\sphinxAtStartFootnote
Please note that not all configurations can be written to files other than \sphinxcode{\sphinxupquote{.git/config}}.
Some of the files introduced in the next section will not be queried by Git, and in principle, it is a good thing that one cannot share arbitrary configurations together with a dataset, as this could be a potential security threat.
In those cases where you need dataset clones to inherit certain non\sphinxhyphen{}sticky configurations, it is advised to write a custom procedure and distribute it together with the dataset.
The next two sections contain concrete usecases and tutorials.
%
\end{footnote}
need to be defined in different files \textendash{} files that are version controlled.
The next section will talk about them.

\sphinxstepscope

\index{dataset configuration@\spxentry{dataset configuration}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!dataset configuration@\spxentry{dataset configuration}}\ignorespaces 

\section{Shipping and overriding configuration}
\label{\detokenize{basics/101-123-config2:shipping-and-overriding-configuration}}\label{\detokenize{basics/101-123-config2:config2}}\label{\detokenize{basics/101-123-config2:index-0}}\label{\detokenize{basics/101-123-config2::doc}}
\sphinxAtStartPar
As the last section already suggest, within a Git repository,
\sphinxcode{\sphinxupquote{.git/config}} is not the only configuration file.
There are also \sphinxcode{\sphinxupquote{.gitmodules}} and \sphinxcode{\sphinxupquote{.gitattributes}}, and in DataLad datasets
there also is a \sphinxcode{\sphinxupquote{.datalad/config}} file.

\sphinxAtStartPar
All of these files store configurations, but have an important difference:
They are version controlled, and upon sharing a dataset these configurations
will be shared as well. An example for a shared configuration
is the one that the \sphinxcode{\sphinxupquote{text2git}} configuration template applied:
In the shared copy of your dataset from {\hyperref[\detokenize{basics/101-121-siblings:sibling}]{\sphinxcrossref{\DUrole{std,std-ref}{Networking}}}} (\autopageref*{\detokenize{basics/101-121-siblings:sibling}}), text files are also saved with Git,
and not git\sphinxhyphen{}annex. The configuration responsible
for this behavior is in a \sphinxcode{\sphinxupquote{.gitattributes}} file, and we’ll start this
section by looking into it.

\index{configuration file@\spxentry{configuration file}!.gitattributes@\spxentry{.gitattributes}|spxpagem}\ignorespaces 

\subsection{\sphinxstyleliteralintitle{\sphinxupquote{.gitattributes}}}
\label{\detokenize{basics/101-123-config2:gitattributes}}\label{\detokenize{basics/101-123-config2:index-1}}
\sphinxAtStartPar
This file lies right in the root of your superdataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }.gitattributes
\PYG{g+go}{* annex.backend=MD5E}
\PYG{g+go}{**/.git* annex.largefiles=nothing}
\PYG{g+go}{* annex.largefiles=((mimeencoding=binary)and(largerthan=0))}
\end{sphinxVerbatim}

\sphinxAtStartPar
This looks neither spectacular nor pretty. Also, it does not follow the \sphinxcode{\sphinxupquote{section\sphinxhyphen{}option\sphinxhyphen{}value}}
organization of the \sphinxcode{\sphinxupquote{.git/config}} file anymore. Instead, there are three lines,
and all of these seem to have something to do with the configuration of git\sphinxhyphen{}annex.
There even is one key word that you recognize: MD5E.
If you have read the {\hyperref[\detokenize{basics/101-115-symlinks:objecttree}]{\sphinxcrossref{\DUrole{std,std-ref}{Find\sphinxhyphen{}out\sphinxhyphen{}more on object trees}}}} (\autopageref*{\detokenize{basics/101-115-symlinks:objecttree}})
you will recognize it as a reference to the type of
key used by git\sphinxhyphen{}annex to identify and store file content in the object\sphinxhyphen{}tree.
The first row, \sphinxcode{\sphinxupquote{* annex.backend=MD5E}}, therefore translates to “The \sphinxcode{\sphinxupquote{MD5E}} git\sphinxhyphen{}annex backend should be used for any file”.
But what is the rest? We’ll start with the last row:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
*\PYG{+w}{ }annex.largefiles\PYG{o}{=}\PYG{o}{(}\PYG{o}{(}\PYG{n+nv}{mimeencoding}\PYG{o}{=}binary\PYG{o}{)}and\PYG{o}{(}\PYG{n+nv}{largerthan}\PYG{o}{=}\PYG{l+m}{0}\PYG{o}{)}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Uhhh, cryptic. The lecturer explains: “git\sphinxhyphen{}annex will \sphinxstyleemphasis{annex}, that is, \sphinxstyleemphasis{store in the object\sphinxhyphen{}tree},
anything it considers to be a “large file”. By default, anything
in your dataset would be a “large file”, that means anything would be annexed.
However, in section {\hyperref[\detokenize{basics/101-115-symlinks:symlink}]{\sphinxcrossref{\DUrole{std,std-ref}{Data integrity}}}} (\autopageref*{\detokenize{basics/101-115-symlinks:symlink}}) I already mentioned that exceptions to this
behavior can be defined based on
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
file size

\item {} 
\sphinxAtStartPar
and/or path/pattern, and thus for example file extensions,
or names, or file types (e.g., text files, as with the
\sphinxcode{\sphinxupquote{text2git}} configuration template).

\end{enumerate}

\sphinxAtStartPar
“In \sphinxcode{\sphinxupquote{.gitattributes}}, you can define what a large file and what is not
by simply telling git\sphinxhyphen{}annex by writing such rules.”

\sphinxAtStartPar
What you can see in this \sphinxcode{\sphinxupquote{.gitattributes}} file is a rule based on \sphinxstylestrong{file types}:
With \sphinxcode{\sphinxupquote{(mimeencoding=binary)}}%
\begin{footnote}[1]\sphinxAtStartFootnote
When opening any file on a UNIX system, the file does not need to have a file
extension (such as \sphinxcode{\sphinxupquote{.txt}}, \sphinxcode{\sphinxupquote{.pdf}}, \sphinxcode{\sphinxupquote{.jpg}}) for the operating system to know
how to open or use this file (in contrast to Windows, which does not know how to
open a file without an extension). To do this, Unix systems rely on a file’s
MIME type \textendash{} an information about a file’s content. A \sphinxcode{\sphinxupquote{.txt}} file, for example,
has MIME type \sphinxcode{\sphinxupquote{text/plain}} as does a bash script (\sphinxcode{\sphinxupquote{.sh}}), a Python
script has MIME type \sphinxcode{\sphinxupquote{text/x\sphinxhyphen{}python}}, a \sphinxcode{\sphinxupquote{.jpg}} file is \sphinxcode{\sphinxupquote{image/jpg}}, and
a \sphinxcode{\sphinxupquote{.pdf}} file has MIME type \sphinxcode{\sphinxupquote{application/pdf}}. You can find out the MIME type
of a file by running:

\sphinxSetupCodeBlockInFootnote
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }file\PYG{+w}{ }\PYGZhy{}\PYGZhy{}mime\PYGZhy{}type\PYG{+w}{ }path/to/file
\end{sphinxVerbatim}
%
\end{footnote}, the \sphinxcode{\sphinxupquote{text2git}} configuration template
configured git\sphinxhyphen{}annex to regard all files of type “binary” as a large file.
Thanks to this little line, your text files are not annexed, but stored
directly in Git.

\sphinxAtStartPar
The patterns \sphinxcode{\sphinxupquote{*}} and \sphinxcode{\sphinxupquote{**}} are so\sphinxhyphen{}called “wildcards” you might recognize from used in {\hyperref[\detokenize{glossary:term-globbing}]{\sphinxtermref{\DUrole{xref,std,std-term}{globbing}}}}.
In Git configuration files, an asterisk “*” matches anything except a slash.
The third row therefore
translates to “Do not annex anything that is a text file” for git\sphinxhyphen{}annex.
Two leading “\sphinxcode{\sphinxupquote{**}}” followed by a slash matches
\sphinxstyleemphasis{recursively} in all directories.
Therefore, the second row instructs git\sphinxhyphen{}annex to regard nothing starting with \sphinxcode{\sphinxupquote{.git}} as a “large file”, including contents inside of \sphinxcode{\sphinxupquote{.git}} directories.
This way, the \sphinxcode{\sphinxupquote{.git}} repositories are protected from being annexed.
If you had a single file (\sphinxcode{\sphinxupquote{myfile.pdf}}) you would not want annexed, specifying a rule such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
myfile.pdf\PYG{+w}{ }annex.largefiles\PYG{o}{=}nothing
\end{sphinxVerbatim}

\sphinxAtStartPar
will keep it stored in Git. To see an example of this, navigate into the longnow subdataset,
and view this dataset’s \sphinxcode{\sphinxupquote{.gitattributes}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }recordings/longnow/.gitattributes
\PYG{g+go}{* annex.backend=MD5E}
\PYG{g+go}{**/.git* annex.largefiles=nothing}
\PYG{g+go}{README.md annex.largefiles=nothing}
\end{sphinxVerbatim}

\sphinxAtStartPar
The relevant part is \sphinxcode{\sphinxupquote{README.md annex.largefiles=nothing}}.
This instructs git\sphinxhyphen{}annex to specifically not annex \sphinxcode{\sphinxupquote{README.md}}.

\sphinxAtStartPar
Lastly, if you wanted to configure a rule based on \sphinxstylestrong{size}, you could add a row such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
**\PYG{+w}{ }annex.largefiles\PYG{o}{(}\PYG{n+nv}{largerthan}\PYG{o}{=}20kb\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
to store only files exceeding 20KB in size in git\sphinxhyphen{}annex%
\begin{footnote}[2]\sphinxAtStartFootnote
Specifying annex.largefiles in your .gitattributes file will make the configuration
“portable” \textendash{} shared copies of your dataset will retain these configurations.
You could however also set largefiles rules in your \sphinxcode{\sphinxupquote{.git/config}} file. Rules
specified in there take precedence over rules in \sphinxcode{\sphinxupquote{.gitattributes}}. You can set
them using the \sphinxcode{\sphinxupquote{git config}} command:

\sphinxSetupCodeBlockInFootnote
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }annex.largefiles\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}largerthan=100kb and not (include=*.c or include=*.h)\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The above command annexes files larger than 100KB, and will never annex files with a
\sphinxcode{\sphinxupquote{.c}} or \sphinxcode{\sphinxupquote{.h}} extension.
%
\end{footnote}.

\sphinxAtStartPar
As you may have noticed, unlike \sphinxcode{\sphinxupquote{.git/config}} files,
there can be multiple \sphinxcode{\sphinxupquote{.gitattributes}} files within a dataset. So far, you have seen one
in the root of the superdataset, and in the root of the \sphinxcode{\sphinxupquote{longnow}} subdataset.
In principle, you can add one to every directory\sphinxhyphen{}level of your dataset.
For example, there is another \sphinxcode{\sphinxupquote{.gitattributes}} file within the
\sphinxcode{\sphinxupquote{.datalad}} directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }.datalad/.gitattributes
\PYG{g+go}{config annex.largefiles=nothing}
\end{sphinxVerbatim}

\sphinxAtStartPar
As with Git configuration files, more specific or lower\sphinxhyphen{}level configurations take precedence
over more general or higher\sphinxhyphen{}level configurations. Specifications in a subdirectory can
therefore overrule specifications made in the \sphinxcode{\sphinxupquote{.gitattributes}} file of the parent
directory.

\sphinxAtStartPar
In summary, the \sphinxcode{\sphinxupquote{.gitattributes}} files will give you the possibility to configure
what should be annexed and what should not be annexed up to individual file level.
This can be very handy, and allows you to tune your dataset to your custom needs.
For example, files you will often edit by hand could be stored in Git if they are
not too large to ease modifying them%
\begin{footnote}[3]\sphinxAtStartFootnote
Should you ever need to, this file is also where one would change the git\sphinxhyphen{}annex
backend in order to store new files with a new backend. Switching the backend of
\sphinxstyleemphasis{all} files (new as well as existing ones) requires the \sphinxcode{\sphinxupquote{git annex migrate}}
command
(see \sphinxhref{https://git-annex.branchable.com/git-annex-migrate}{the documentation} for
more information on this command).
%
\end{footnote}.
Once you know the basics of this type of configuration syntax, writing
your own rules is easy. For more tips on how configure git\sphinxhyphen{}annex’s content
management in \sphinxcode{\sphinxupquote{.gitattributes}}, take a look at \sphinxhref{https://git-annex.branchable.com/tips/largefiles}{the git\sphinxhyphen{}annex documentation}.
Later however you will see preconfigured DataLad \sphinxstyleemphasis{procedures} such as \sphinxcode{\sphinxupquote{text2git}} that
can apply useful configurations for you, just as \sphinxcode{\sphinxupquote{text2git}} added the last line
in the root \sphinxcode{\sphinxupquote{.gitattributes}} file.

\index{configuration file@\spxentry{configuration file}!.gitmodules@\spxentry{.gitmodules}|spxpagem}\ignorespaces 

\subsection{\sphinxstyleliteralintitle{\sphinxupquote{.gitmodules}}}
\label{\detokenize{basics/101-123-config2:gitmodules}}\label{\detokenize{basics/101-123-config2:index-2}}
\sphinxAtStartPar
On last configuration file that Git creates is the \sphinxcode{\sphinxupquote{.gitmodules}} file.
There is one right in the root of your dataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }.gitmodules
\PYG{g+go}{[submodule \PYGZdq{}recordings/longnow\PYGZdq{}]}
\PYG{g+go}{	path = recordings/longnow}
\PYG{g+go}{	url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\PYG{g+go}{	datalad\PYGZhy{}id = b3ca2718\PYGZhy{}8901\PYGZhy{}11e8\PYGZhy{}99aa\PYGZhy{}a0369f7c647e}
\PYG{g+go}{	datalad\PYGZhy{}url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\end{sphinxVerbatim}

\sphinxAtStartPar
Based on these contents, you might have already guessed what this file
stores. The \sphinxcode{\sphinxupquote{.gitmodules}} file is a configuration file that stores the mapping between
your own dataset and any subdatasets you have installed in it.
There will be an entry for each submodule (subdataset) in your dataset.
The name \sphinxstyleemphasis{submodule} is Git terminology, and describes a Git repository inside of
another Git repository, i.e., the super\sphinxhyphen{} and subdataset principles.
Upon sharing your dataset, the information about subdatasets and where to retrieve
them from is stored and shared with this file.
In addition to modifying it with the \sphinxcode{\sphinxupquote{git config}} command or by hand, the \sphinxcode{\sphinxupquote{datalad subdatasets}} command also has a \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}set\sphinxhyphen{}property NAME VALUE}} option that you can use to set subdataset properties.

\sphinxAtStartPar
Section {\hyperref[\detokenize{basics/101-116-sharelocal:sharelocal1}]{\sphinxcrossref{\DUrole{std,std-ref}{Looking without touching}}}} (\autopageref*{\detokenize{basics/101-116-sharelocal:sharelocal1}}) already mentioned one additional configuration option in a footnote: The \sphinxcode{\sphinxupquote{datalad\sphinxhyphen{}recursiveinstall}} key.
This key is defined on a per subdataset basis, and if set to “\sphinxcode{\sphinxupquote{skip}}”, the given subdataset will not be recursively installed unless it is explicitly specified as a path to \sphinxcode{\sphinxupquote{datalad get {[}\sphinxhyphen{}n/\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}data{]} \sphinxhyphen{}r}}.
If you are a maintainer of a superdataset with monstrous amounts of subdatasets, you can set this option and share it together with the dataset to prevent an accidental, large recursive installation in particularly deeply nested subdatasets.
Below is a minimally functional example on how to apply the configuration and how it works:

\sphinxAtStartPar
Let’s create a dataset hierarchy to work with (note that we concatenate multiple commands into a single line using bash’s “and” \sphinxcode{\sphinxupquote{\&\&}} operator):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} create a superdataset with two subdatasets}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }create\PYG{+w}{ }superds\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }datalad\PYG{+w}{ }\PYGZhy{}C\PYG{+w}{ }superds\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }subds1\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }datalad\PYG{+w}{ }\PYGZhy{}C\PYG{+w}{ }superds\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }subds2
\PYG{g+go}{create(ok): /tmp/superds (dataset)}
\PYG{g+go}{add(ok): subds1 (file)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{create(ok): subds1 (dataset)}
\PYG{g+go}{add(ok): subds2 (file)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{create(ok): subds2 (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next, we create subdatasets in the subdatasets:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} create two subdatasets in subds1}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }\PYGZhy{}C\PYG{+w}{ }superds/subds1\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }subsubds1\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }datalad\PYG{+w}{ }\PYGZhy{}C\PYG{+w}{ }superds/subds1\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }subsubds2
\PYG{g+go}{add(ok): subsubds1 (file)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{create(ok): subsubds1 (dataset)}
\PYG{g+go}{add(ok): subsubds2 (file)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{create(ok): subsubds2 (dataset)}

\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} create two subdatasets in subds2}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }\PYGZhy{}C\PYG{+w}{ }superds/subds2\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }subsubds1\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }datalad\PYG{+w}{ }\PYGZhy{}C\PYG{+w}{ }superds/subds2\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }subsubds2
\PYG{g+go}{add(ok): subsubds1 (file)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{create(ok): subsubds1 (dataset)}
\PYG{g+go}{add(ok): subsubds2 (file)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{create(ok): subsubds2 (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here is the directory structure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }tree
\PYG{g+go}{.}
\PYG{g+go}{├── subds1}
\PYG{g+go}{│   ├── subsubds1}
\PYG{g+go}{│   └── subsubds2}
\PYG{g+go}{└── subds2}
\PYG{g+go}{    ├── subsubds1}
\PYG{g+go}{    └── subsubds2}

\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} save in the superdataset}
\PYG{g+go}{datalad save \PYGZhy{}m \PYGZdq{}add a few sub and subsub datasets\PYGZdq{}}
\PYG{g+go}{add(ok): subds1 (file)}
\PYG{g+go}{add(ok): subds2 (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now, we can apply the \sphinxcode{\sphinxupquote{datalad\sphinxhyphen{}recursiveinstall}} configuration to skip recursive installations for \sphinxcode{\sphinxupquote{subds1}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}f\PYG{+w}{ }.gitmodules\PYG{+w}{ }\PYGZhy{}\PYGZhy{}add\PYG{+w}{ }submodule.subds1.datalad\PYGZhy{}recursiveinstall\PYG{+w}{ }skip

\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} save this configuration}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}prevent recursion into subds1, unless explicitly given as path\PYGZdq{}}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If the dataset is cloned, and someone runs a recursive \sphinxcode{\sphinxupquote{datalad get}}, the subdatasets of \sphinxcode{\sphinxupquote{subds1}} will not be installed, the subdatasets of \sphinxcode{\sphinxupquote{subds2}}, however, will be.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} clone the dataset somewhere else}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }datalad\PYG{+w}{ }clone\PYG{+w}{ }superds\PYG{+w}{ }clone\PYGZus{}of\PYGZus{}superds
\PYG{g+go}{[INFO   ] Cloning superds into \PYGZsq{}/tmp/clone\PYGZus{}of\PYGZus{}superds\PYGZsq{}}
\PYG{g+go}{install(ok): /tmp/clone\PYGZus{}of\PYGZus{}superds (dataset)}

\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} recursively get all contents (without data)}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }clone\PYGZus{}of\PYGZus{}superds\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }datalad\PYG{+w}{ }get\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }.
\PYG{g+go}{get(ok): /tmp/clone\PYGZus{}of\PYGZus{}superds/subds2 (dataset)}
\PYG{g+go}{get(ok): /tmp/clone\PYGZus{}of\PYGZus{}superds/subds2/subsubds1 (dataset)}
\PYG{g+go}{get(ok): /tmp/clone\PYGZus{}of\PYGZus{}superds/subds2/subsubds2 (dataset)}

\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} only subsubds of subds2 are installed, not of subds1:}
\PYG{g+gp}{\PYGZdl{} }tree
\PYG{g+go}{.}
\PYG{g+go}{├── subds1}
\PYG{g+go}{└── subds2}
\PYG{g+go}{    ├── subsubds1}
\PYG{g+go}{    └── subsubds2}

\PYG{g+go}{4 directories, 0 files}
\end{sphinxVerbatim}

\sphinxAtStartPar
Nevertheless, if \sphinxcode{\sphinxupquote{subds1}} is provided with an explicit path, its subdataset \sphinxcode{\sphinxupquote{subsubds}} will be cloned, essentially overriding the configuration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{}  }datalad\PYG{+w}{ }get\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }subds1\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }tree
\PYG{g+go}{install(ok): /tmp/clone\PYGZus{}of\PYGZus{}superds/subds1 (dataset) [Installed subdataset in order to get /tmp/clone\PYGZus{}of\PYGZus{}superds/subds1]}
\PYG{g+go}{.}
\PYG{g+go}{├── subds1}
\PYG{g+go}{│   ├── subsubds1}
\PYG{g+go}{│   └── subsubds2}
\PYG{g+go}{└── subds2}
\PYG{g+go}{    ├── subsubds1}
\PYG{g+go}{    └── subsubds2}

\PYG{g+go}{6 directories, 0 files}
\end{sphinxVerbatim}

\index{configuration file@\spxentry{configuration file}!.datalad/config@\spxentry{.datalad/config}|spxpagem}\ignorespaces 

\subsection{\sphinxstyleliteralintitle{\sphinxupquote{.datalad/config}}}
\label{\detokenize{basics/101-123-config2:datalad-config}}\label{\detokenize{basics/101-123-config2:index-3}}
\sphinxAtStartPar
DataLad adds a repository\sphinxhyphen{}specific configuration file as well.
It can be found in the \sphinxcode{\sphinxupquote{.datalad}} directory, and just like \sphinxcode{\sphinxupquote{.gitattributes}}
and \sphinxcode{\sphinxupquote{.gitmodules}} it is version controlled and is thus shared together with
the dataset. One can configure
\sphinxhref{https://docs.datalad.org/en/latest/generated/datalad.config.html}{many options},
but currently, our \sphinxcode{\sphinxupquote{.datalad/config}} file only stores a {\hyperref[\detokenize{glossary:term-dataset-ID}]{\sphinxtermref{\DUrole{xref,std,std-term}{dataset ID}}}}.
This ID serves to identify a dataset as a unit, across its entire history and flavors.
In a geeky way, this is your dataset’s social security number: It will only exist
one time on this planet.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }.datalad/config
\PYG{g+go}{[datalad \PYGZdq{}dataset\PYGZdq{}]}
\PYG{g+go}{	id = e3e70682\PYGZhy{}c209\PYGZhy{}4cac\PYGZhy{}629f\PYGZhy{}6fbed82c07cd}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note, though, that local configurations within a Git configuration file
will take precedence over configurations that can be distributed with a dataset.
Otherwise, dataset updates with \sphinxcode{\sphinxupquote{datalad update}} (or, for Git\sphinxhyphen{}users,
\sphinxcode{\sphinxupquote{git pull}}) could suddenly and unintentionally alter local DataLad
behavior that was specifically configured.
Also, {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} and {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} will not query this file for configurations, so please store only sticky options that are specific to DataLad (i.e., under the \sphinxcode{\sphinxupquote{datalad.*}} namespace) in it.

\index{modify configuration@\spxentry{modify configuration}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!modify configuration@\spxentry{modify configuration}}\ignorespaces 

\subsection{Writing to configuration files other than \sphinxstyleliteralintitle{\sphinxupquote{.git/config}}}
\label{\detokenize{basics/101-123-config2:writing-to-configuration-files-other-than-git-config}}\label{\detokenize{basics/101-123-config2:index-4}}
\sphinxAtStartPar
“Didn’t you say that knowing the \sphinxcode{\sphinxupquote{git config}} command is already
half of what I need to know?” you ask. “Now there are three other configuration
files, and I do not know with which command I can write into these files.”

\sphinxAtStartPar
“Excellent question”, you hear in return, “but in reality, you \sphinxstylestrong{do} know:
it’s also the \sphinxcode{\sphinxupquote{git config}} command. The only part of it you need to
adjust is the \sphinxcode{\sphinxupquote{\sphinxhyphen{}f}}, \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}file}} parameter. By default, the command writes to
a Git config file. But it can write to a different file if you specify it
appropriately. For example,
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{git config \sphinxhyphen{}\sphinxhyphen{}file=.gitmodules \sphinxhyphen{}\sphinxhyphen{}replace\sphinxhyphen{}all submodule."name".url "new URL"}}
\end{quote}

\sphinxAtStartPar
will update your submodule’s URL. Keep in mind though that you would need
to commit this change, as \sphinxcode{\sphinxupquote{.gitmodules}} is version controlled”.

\sphinxAtStartPar
Let’s try this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}\PYGZhy{}file\PYG{o}{=}.gitmodules\PYG{+w}{ }\PYGZhy{}\PYGZhy{}replace\PYGZhy{}all\PYG{+w}{ }submodule.\PYG{l+s+s2}{\PYGZdq{}recordings/longnow\PYGZdq{}}.url\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}git@github.com:datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This command will replace the submodule’s https URL with an SSH URL.
The latter is often used if someone has an \sphinxstyleemphasis{SSH key pair} and added the
public key to their GitHub account (you can read more about this
\sphinxhref{https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories}{here}).
We will revert this change shortly, but use it to show the difference between
a \sphinxcode{\sphinxupquote{git config}} on a \sphinxcode{\sphinxupquote{.git/config}} file and on a version controlled file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{ modified: .gitmodules (file)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }diff
\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/.gitmodules b/.gitmodules}
\PYG{g+go}{index 9bc9ee9..11273e1 100644}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} a/.gitmodules}
\PYG{g+go}{+++ b/.gitmodules}
\PYG{g+go}{@@ \PYGZhy{}1,5 +1,5 @@}
\PYG{g+go}{ [submodule \PYGZdq{}recordings/longnow\PYGZdq{}]}
\PYG{g+go}{ 	path = recordings/longnow}
\PYG{g+go}{\PYGZhy{}	url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\PYG{g+go}{+	url = git@github.com:datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\PYG{g+go}{ 	datalad\PYGZhy{}id = b3ca2718\PYGZhy{}8901\PYGZhy{}11e8\PYGZhy{}99aa\PYGZhy{}a0369f7c647e}
\PYG{g+go}{ 	datalad\PYGZhy{}url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\end{sphinxVerbatim}

\sphinxAtStartPar
As these two commands show, the \sphinxcode{\sphinxupquote{.gitmodules}} file is modified. The https URL
has been deleted (note the \sphinxcode{\sphinxupquote{\sphinxhyphen{}}}), and a SSH URL has been added. To keep these
changes, we would need to \sphinxcode{\sphinxupquote{datalad save}} them. However, as we want to stay with
https URLs, we will just \sphinxstyleemphasis{checkout} this change \textendash{} using a Git tool to undo an
unstaged modification.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }checkout\PYG{+w}{ }.gitmodules
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{Updated 1 path from the index}
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note, though, that the \sphinxcode{\sphinxupquote{.gitattributes}} file cannot be modified with a \sphinxcode{\sphinxupquote{git config}}
command. This is due to its different format that does not comply to the
\sphinxcode{\sphinxupquote{section.variable.value}} structure of all other configuration files. This file, therefore,
has to be edited by hand, with an editor of your choice.

\index{environment variable@\spxentry{environment variable}|spxpagem}\ignorespaces 

\subsection{Environment variables}
\label{\detokenize{basics/101-123-config2:environment-variables}}\label{\detokenize{basics/101-123-config2:envvars}}\label{\detokenize{basics/101-123-config2:index-5}}
\sphinxAtStartPar
An {\hyperref[\detokenize{glossary:term-environment-variable}]{\sphinxtermref{\DUrole{xref,std,std-term}{environment variable}}}} is a variable set up in your shell
that affects the way the shell or certain software works \textendash{} for example,
the environment variables \sphinxcode{\sphinxupquote{HOME}}, \sphinxcode{\sphinxupquote{PWD}}, or \sphinxcode{\sphinxupquote{PATH}}.
Configuration options that determine the behavior of Git, git\sphinxhyphen{}annex, and
DataLad that could be defined in a configuration file can also be set (or overridden)
by the associated environment variables of these configuration options.
Many configuration items have associated environment variables.
If this environment variable is set, it takes precedence over options set in
configuration files, thus providing both an alternative way to define configurations
as well as an override mechanism. For example, the \sphinxcode{\sphinxupquote{user.name}}
configuration of Git can be overridden by its associated environment variable,
\sphinxcode{\sphinxupquote{GIT\_AUTHOR\_NAME}}. Likewise, one can define the environment variable instead
of setting the \sphinxcode{\sphinxupquote{user.name}} configuration in a configuration file.

\index{configuration item@\spxentry{configuration item}!datalad.log.level@\spxentry{datalad.log.level}}\ignorespaces 
\sphinxAtStartPar
Git, git\sphinxhyphen{}annex, and DataLad have more environment variables than anyone would want to
remember. \sphinxhref{https://git-scm.com/book/en/v2/Git-Internals-Environment-Variables}{The ProGit book}
has a good overview on Git’s most useful available environment variables for a start.
All of DataLad’s configuration options can be translated to their
associated environment variables. Any environment variable with a name that starts with \sphinxcode{\sphinxupquote{DATALAD\_}}
will be available as the corresponding \sphinxcode{\sphinxupquote{datalad.}} configuration variable,
replacing any \sphinxcode{\sphinxupquote{\_\_}} (two underscores) with a hyphen, then any \sphinxcode{\sphinxupquote{\_}} (single underscore)
with a dot, and finally converting all letters to lower case. The \sphinxcode{\sphinxupquote{datalad.log.level}}
configuration option thus is the environment variable \sphinxcode{\sphinxupquote{DATALAD\_LOG\_LEVEL}}.
If you are new to the concept of environment variables, check out the
\textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-envvar}} {\hyperref[\detokenize{basics/101-123-config2:fom-envvar}]{\sphinxcrossref{\DUrole{std,std-ref}{on them}}}} (\autopageref*{\detokenize{basics/101-123-config2:fom-envvar}}).

\index{operating system concept@\spxentry{operating system concept}!environment variable@\spxentry{environment variable}}\ignorespaces \begin{findoutmore}[label={fom-envvar}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Some more general information on environment variables}
\label{\detokenize{basics/101-123-config2:fom-envvar}}

\sphinxAtStartPar
Names of environment variables are often all\sphinxhyphen{}uppercase, but they need not be.
While the \sphinxcode{\sphinxupquote{\$}} is not part of
the name of the environment variable, it is necessary to \sphinxstyleemphasis{refer} to the environment
variable: To reference the value of the environment variable \sphinxcode{\sphinxupquote{HOME}}, for example, you would
need to use \sphinxcode{\sphinxupquote{echo \$HOME}} and not \sphinxcode{\sphinxupquote{echo HOME}}. However, environment variables are
set without a leading \sphinxcode{\sphinxupquote{\$}}. There are several ways to set an environment variable
(note that there are no spaces before and after the equals sign!), leading to different
levels of availability of the variable:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{THEANSWER=42 \textless{}command\textgreater{}}} makes the variable \sphinxcode{\sphinxupquote{THEANSWER}} available for the process in \sphinxcode{\sphinxupquote{\textless{}command\textgreater{}}}.
For example, \sphinxcode{\sphinxupquote{DATALAD\_LOG\_LEVEL=debug datalad get \textless{}file\textgreater{}}} will execute the \sphinxcode{\sphinxupquote{datalad get}}
command (and only this one) with the log level set to “debug”.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{export THEANSWER=42}} makes the variable \sphinxcode{\sphinxupquote{THEANSWER}} available for other processes in the
same session, but it will not be available to other shells.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{echo \textquotesingle{}export THEANSWER=42\textquotesingle{} \textgreater{}\textgreater{} \textasciitilde{}/.bashrc}} will write the variable definition in the
\sphinxcode{\sphinxupquote{.bashrc}} file and thus available to all future shells of the user (i.e., this will make
the variable permanent for the user)

\end{itemize}

\sphinxAtStartPar
To list all of the configured environment variables, type \sphinxcode{\sphinxupquote{env}} into your terminal.


\end{findoutmore}


\subsection{Summary}
\label{\detokenize{basics/101-123-config2:summary}}
\sphinxAtStartPar
This has been an intense lecture, you have to admit. One definite
take\sphinxhyphen{}away from it has been that you now know a second reason why the hidden
\sphinxcode{\sphinxupquote{.git}} and \sphinxcode{\sphinxupquote{.datalad}} directory contents and also the contents of \sphinxcode{\sphinxupquote{.gitmodules}} and
\sphinxcode{\sphinxupquote{.gitattributes}} should not be carelessly tampered with \textendash{} they contain all of
the repository’s configurations.

\sphinxAtStartPar
But you now also know how to modify these configurations with enough
care and background knowledge such that nothing should go wrong once you
want to work with and change them. You can use the \sphinxcode{\sphinxupquote{git config}} command
for Git configuration files on different scopes, and even the \sphinxcode{\sphinxupquote{.gitmodules}} or \sphinxcode{\sphinxupquote{datalad/config}}
files. Of course you do not yet know all of the available configuration options. However,
you already know some core Git configurations such as name, email, and editor. Even more
important, you know how to configure git\sphinxhyphen{}annex’s content management based on \sphinxcode{\sphinxupquote{largefile}}
rules, and you understand the  variables within \sphinxcode{\sphinxupquote{.gitmodules}} or the sections
in \sphinxcode{\sphinxupquote{.git/config}}. Slowly, you realize with pride,
you are more and more becoming a DataLad power\sphinxhyphen{}user.

\sphinxAtStartPar
Write a note about configurations in datasets into \sphinxcode{\sphinxupquote{notes.txt}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }notes.txt
\PYG{g+go}{Configurations for datasets exist on different levels (systemwide,}
\PYG{g+go}{global, and local), and in different types of files (not version}
\PYG{g+go}{controlled (git)config files, or version controlled .datalad/config,}
\PYG{g+go}{.gitattributes, or gitmodules files), or environment variables.}
\PYG{g+go}{With the exception of .gitattributes, all configuration files share a}
\PYG{g+go}{common structure, and can be modified with the git config command, but}
\PYG{g+go}{also with an editor by hand.}

\PYG{g+go}{Depending on whether a configuration file is version controlled or}
\PYG{g+go}{not, the configurations will be shared together with the dataset.}
\PYG{g+go}{More specific configurations and not\PYGZhy{}shared configurations will always}
\PYG{g+go}{take precedence over more global or hared configurations, and}
\PYG{g+go}{environment variables take precedence over configurations in files.}

\PYG{g+go}{The git config \PYGZhy{}\PYGZhy{}list \PYGZhy{}\PYGZhy{}show\PYGZhy{}origin command is a useful tool to give}
\PYG{g+go}{an overview over existing configurations. Particularly important may}
\PYG{g+go}{be the .gitattributes file, in which one can set rules for git\PYGZhy{}annex}
\PYG{g+go}{about which files should be version\PYGZhy{}controlled with Git instead of}
\PYG{g+go}{being annexed.}

\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add note on configurations and git config\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxstepscope

\index{procedures@\spxentry{procedures}|spxpagem}\index{run\sphinxhyphen{}procedures@\spxentry{run\sphinxhyphen{}procedures}}\index{standardized configuration@\spxentry{standardized configuration}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!standardized configuration@\spxentry{standardized configuration}}\ignorespaces 

\section{Configurations to go}
\label{\detokenize{basics/101-124-procedures:configurations-to-go}}\label{\detokenize{basics/101-124-procedures:procedures}}\label{\detokenize{basics/101-124-procedures:index-0}}\label{\detokenize{basics/101-124-procedures::doc}}
\sphinxAtStartPar
The past two sections should have given you a comprehensive
overview on the different configuration options the tools
Git, git\sphinxhyphen{}annex, and DataLad provide. They not only
showed you a way to configure everything you may need to
configure, but also gave explanations about what the
configuration options actually mean.

\sphinxAtStartPar
But figuring out which configurations are useful and how
to apply them are also not the easiest tasks. Therefore,
some clever people decided to assist with
these tasks, and created pre\sphinxhyphen{}configured \sphinxstyleemphasis{procedures}
that process datasets in a particular way.
These procedures can be shipped within DataLad or its extensions,
lie on a system, or can be shared together with datasets.

\sphinxAtStartPar
One of such procedures is the \sphinxcode{\sphinxupquote{text2git}} configuration.
In order to learn about procedures in general, let’s demystify
what the \sphinxcode{\sphinxupquote{text2git}} procedure exactly is: It is
nothing more than a simple script that
\begin{itemize}
\item {} 
\sphinxAtStartPar
writes the relevant \sphinxcode{\sphinxupquote{annex\_largefiles}} configuration,  i.e., “Do not put anything that is a text file in the annex”) to the \sphinxcode{\sphinxupquote{.gitattributes}} file of a dataset, and

\item {} 
\sphinxAtStartPar
saves this modification with the commit message “Instruct annex to add text files to Git”.

\end{itemize}

\sphinxAtStartPar
This particular procedure lives in a script called
\sphinxcode{\sphinxupquote{cfg\_text2git}} in the sourcecode of DataLad. The amount of code
in this script is not large, and the relevant lines of code
are highlighted:

\fvset{hllines={, 12, 16, 17,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{k+kn}{import} \PYG{n+nn}{sys}
 \PYG{k+kn}{import} \PYG{n+nn}{os}\PYG{n+nn}{.}\PYG{n+nn}{path} \PYG{k}{as} \PYG{n+nn}{op}

 \PYG{k+kn}{from} \PYG{n+nn}{datalad}\PYG{n+nn}{.}\PYG{n+nn}{distribution}\PYG{n+nn}{.}\PYG{n+nn}{dataset} \PYG{k+kn}{import} \PYG{n}{require\PYGZus{}dataset}

 \PYG{n}{ds} \PYG{o}{=} \PYG{n}{require\PYGZus{}dataset}\PYG{p}{(}
     \PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
     \PYG{n}{check\PYGZus{}installed}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
     \PYG{n}{purpose}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{configuration}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

 \PYG{c+c1}{\PYGZsh{} the relevant configuration:}
 \PYG{n}{annex\PYGZus{}largefiles} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{((mimeencoding=binary)and(largerthan=0))}\PYG{l+s+s1}{\PYGZsq{}}
 \PYG{n}{attrs} \PYG{o}{=} \PYG{n}{ds}\PYG{o}{.}\PYG{n}{repo}\PYG{o}{.}\PYG{n}{get\PYGZus{}gitattributes}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
 \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{attrs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}
         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{annex.largefiles}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{k+kc}{None}\PYG{p}{)} \PYG{o}{==} \PYG{n}{annex\PYGZus{}largefiles}\PYG{p}{:}
     \PYG{n}{ds}\PYG{o}{.}\PYG{n}{repo}\PYG{o}{.}\PYG{n}{set\PYGZus{}gitattributes}\PYG{p}{(}\PYG{p}{[}
         \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{annex.largefiles}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{annex\PYGZus{}largefiles}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

 \PYG{n}{git\PYGZus{}attributes\PYGZus{}file} \PYG{o}{=} \PYG{n}{op}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{ds}\PYG{o}{.}\PYG{n}{path}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.gitattributes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
 \PYG{n}{ds}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}
     \PYG{n}{git\PYGZus{}attributes\PYGZus{}file}\PYG{p}{,}
     \PYG{n}{message}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Instruct annex to add text files to Git}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
 \PYG{p}{)}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Just like \sphinxcode{\sphinxupquote{cfg\_text2git}}, all DataLad procedures are
executables (such as a script, or compiled code).
In principle, they can be written in any language, and perform
any task inside of a dataset.
The \sphinxcode{\sphinxupquote{text2git}} configuration, for example, applies a configuration for how
git\sphinxhyphen{}annex treats different file types. Other procedures do not
only modify \sphinxcode{\sphinxupquote{.gitattributes}}, but can also populate a dataset
with particular content, or automate routine tasks such as
synchronizing dataset content with certain siblings.
What makes them a particularly versatile and flexible tool is
that anyone can write their own procedures.
If a workflow is a standard in a team and needs to be applied often, turning it into
a script can save time and effort.
To learn how to do this, read the tutorial on writing own procedures in an upcoming section.
By pointing DataLad to the location the procedures reside in they can be applied, and by
including them in a dataset they can even be shared.
And even if the script is simple, it is very handy to have preconfigured
procedures that can be run in a single command line call. In the
case of \sphinxcode{\sphinxupquote{text2git}}, all text files in a dataset will be stored
in Git \textendash{} this is a useful configuration that is applicable to a
wide range of datasets. It is a shortcut that
spares naive users the necessity to learn about the \sphinxcode{\sphinxupquote{.gitattributes}}
file when setting up a dataset.

\index{run\sphinxhyphen{}procedure@\spxentry{run\sphinxhyphen{}procedure}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!run\sphinxhyphen{}procedure@\spxentry{run\sphinxhyphen{}procedure}}\index{discover dataset procedures@\spxentry{discover dataset procedures}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!discover dataset procedures@\spxentry{discover dataset procedures}}\index{discover@\spxentry{discover}!dataset procedure@\spxentry{dataset procedure}}\index{dataset procedure@\spxentry{dataset procedure}!discover@\spxentry{discover}}\ignorespaces 
\sphinxAtStartPar
To find out available procedures, the command
\sphinxcode{\sphinxupquote{datalad run\sphinxhyphen{}procedure \sphinxhyphen{}\sphinxhyphen{}discover}} is helpful.
This command will make DataLad search the default location for
procedures in a dataset, the source code of DataLad or
installed DataLad extensions, and the default locations for
procedures on the system for available procedures:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYGZhy{}procedure\PYG{+w}{ }\PYGZhy{}\PYGZhy{}discover
\PYG{g+go}{cfg\PYGZus{}metadatatypes (VIRTUALENV/lib/python3.8/site\PYGZhy{}packages/datalad\PYGZus{}deprecated/resources/procedures/cfg\PYGZus{}metadatatypes.py) [python\PYGZus{}script]}
\PYG{g+go}{cfg\PYGZus{}noannex (VIRTUALENV/lib/python3.8/site\PYGZhy{}packages/datalad/resources/procedures/cfg\PYGZus{}noannex.py) [python\PYGZus{}script]}
\PYG{g+go}{cfg\PYGZus{}text2git (VIRTUALENV/lib/python3.8/site\PYGZhy{}packages/datalad/resources/procedures/cfg\PYGZus{}text2git.py) [python\PYGZus{}script]}
\PYG{g+go}{cfg\PYGZus{}yoda (VIRTUALENV/lib/python3.8/site\PYGZhy{}packages/datalad/resources/procedures/cfg\PYGZus{}yoda.py) [python\PYGZus{}script]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output shows that four procedures available in this particular dataset and the system it exists on:
\sphinxcode{\sphinxupquote{cfg\_metadatatypes}}, \sphinxcode{\sphinxupquote{cfg\_text2git}}, \sphinxcode{\sphinxupquote{cfg\_yoda}}, and \sphinxcode{\sphinxupquote{cfg\_noannex}}.
It also lists where they are stored \textendash{} in this case,
they are all part of the source code of DataLad%
\begin{footnote}[1]\sphinxAtStartFootnote
In theory, because procedures can exist on different levels, and
because anyone can create (and thus name) their own procedures, there
can be name conflicts. The order of precedence in such cases is:
user\sphinxhyphen{}level, system\sphinxhyphen{}level, dataset, DataLad extension, DataLad, i.e.,
local procedures take precedence over those coming from “outside” via
datasets or DataLad extensions.
If procedures in a higher\sphinxhyphen{}level dataset and a subdataset have the same
name, the procedure closer to the dataset \sphinxcode{\sphinxupquote{run\sphinxhyphen{}procedure}} is
operating on takes precedence.
%
\end{footnote}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cfg\_noannex}} configures a dataset to not have an annex at all.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cfg\_yoda}} configures a dataset according to the yoda
principles \textendash{} the section {\hyperref[\detokenize{basics/101-127-yoda:yoda}]{\sphinxcrossref{\DUrole{std,std-ref}{YODA: Best practices for data analyses in a dataset}}}} (\autopageref*{\detokenize{basics/101-127-yoda:yoda}}) talks about this in detail.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cfg\_text2git}} configures text files to be stored in Git.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cfg\_metadatatypes}} lets users configure additional metadata
types.

\end{itemize}

\index{run dataset procedure@\spxentry{run dataset procedure}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!run dataset procedure@\spxentry{run dataset procedure}}\index{run@\spxentry{run}!dataset procedure@\spxentry{dataset procedure}}\index{dataset procedure@\spxentry{dataset procedure}!run@\spxentry{run}}\ignorespaces 

\subsection{Applying procedures}
\label{\detokenize{basics/101-124-procedures:applying-procedures}}\label{\detokenize{basics/101-124-procedures:index-2}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad run\sphinxhyphen{}procedure}} not only \sphinxstyleemphasis{discovers}
but also \sphinxstyleemphasis{executes} procedures. If given the name of
a procedure, this command will apply the procedure to
the current dataset, or the dataset that is specified
with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}d/\sphinxhyphen{}\sphinxhyphen{}dataset}} flag:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
datalad\PYG{+w}{ }run\PYGZhy{}procedure\PYG{+w}{ }\PYG{o}{[}\PYGZhy{}d\PYG{+w}{ }\PYGZlt{}PATH\PYGZgt{}\PYG{o}{]}\PYG{+w}{ }cfg\PYGZus{}text2git
\end{sphinxVerbatim}

\index{run dataset procedure on dataset creation@\spxentry{run dataset procedure on dataset creation}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!run dataset procedure on dataset creation@\spxentry{run dataset procedure on dataset creation}}\index{run on dataset creation@\spxentry{run on dataset creation}!dataset procedure@\spxentry{dataset procedure}}\index{dataset procedure@\spxentry{dataset procedure}!run on dataset creation@\spxentry{run on dataset creation}}\ignorespaces 
\sphinxAtStartPar
The typical workflow is to create a dataset and apply
a procedure afterwards.
However, some procedures shipped with DataLad or its extensions with a
\sphinxcode{\sphinxupquote{cfg\_}} prefix can also be applied right at the creation of a dataset
with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}c/\sphinxhyphen{}\sphinxhyphen{}cfg\sphinxhyphen{}proc \textless{}name\textgreater{}}} option in a \sphinxcode{\sphinxupquote{datalad create}}
command. This is a peculiarity of these procedures because, by convention,
all of these procedures are written to not require arguments.
The command structure looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }text2git\PYG{+w}{ }DataLad\PYGZhy{}101
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the \sphinxcode{\sphinxupquote{cfg\_}} prefix of the procedures is omitted in these
calls to keep it extra simple and short. The
available procedures in this example (\sphinxcode{\sphinxupquote{cfg\_yoda}}, \sphinxcode{\sphinxupquote{cfg\_text2git}})
could thus be applied within a \sphinxcode{\sphinxupquote{datalad create}} as
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad create \sphinxhyphen{}c yoda \textless{}DSname\textgreater{}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad create \sphinxhyphen{}c text2git \textless{}DSname\textgreater{}}}

\end{itemize}

\index{dataset procedure@\spxentry{dataset procedure}!apply more than one configuration@\spxentry{apply more than one configuration}}\ignorespaces 
\sphinxAtStartPar
You can also apply multiple configuration procedures at once. However,
the need to be compatible and complement each other. DataLad does not
guarantee that per\sphinxhyphen{}se. This is how it could look:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }yoda\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }text2git
\end{sphinxVerbatim}

\sphinxAtStartPar
And lastly, procedures can also be applied to subdatasets. See the
\textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-subds-procedures}} {\hyperref[\detokenize{basics/101-124-procedures:fom-subds-procedures}]{\sphinxcrossref{\DUrole{std,std-ref}{on this topic}}}} (\autopageref*{\detokenize{basics/101-124-procedures:fom-subds-procedures}}) for details.

\index{dataset procedure@\spxentry{dataset procedure}!apply to subdatasets@\spxentry{apply to subdatasets}}\ignorespaces \begin{findoutmore}[label={fom-subds-procedures}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Applying procedures in subdatasets}
\label{\detokenize{basics/101-124-procedures:fom-subds-procedures}}

\sphinxAtStartPar
Procedures can be applied in datasets on any level in the dataset hierarchy, i.e.,
also in subdatasets. Note, though, that a subdataset will show up as being
\sphinxcode{\sphinxupquote{modified}} in \sphinxcode{\sphinxupquote{datalad status}} \sphinxstyleemphasis{in the superdataset}
after applying a procedure.
This is expected, and it would also be the case with any other modification
(saved or not) in the subdataset, as the version of the subdataset that is tracked
in the superdataset simply changed. A \sphinxcode{\sphinxupquote{datalad save}} in the superdataset
will make sure that the version of the subdataset gets updated in the superdataset.
The section {\hyperref[\detokenize{basics/101-132-advancednesting:nesting2}]{\sphinxcrossref{\DUrole{std,std-ref}{Turtles all the way down}}}} (\autopageref*{\detokenize{basics/101-132-advancednesting:nesting2}}) will elaborate on this general principle later in this
book.


\end{findoutmore}

\sphinxAtStartPar
As a general note, it can be useful to apply procedures
early in the life of a dataset. Procedures such
as \sphinxcode{\sphinxupquote{cfg\_yoda}}, explained in detail in section {\hyperref[\detokenize{basics/101-127-yoda:yoda}]{\sphinxcrossref{\DUrole{std,std-ref}{YODA: Best practices for data analyses in a dataset}}}} (\autopageref*{\detokenize{basics/101-127-yoda:yoda}}),
create files, change \sphinxcode{\sphinxupquote{.gitattributes}}, or apply other configurations.
If many other (possibly complex) configurations are
already in place, or if files of the same name as the ones created by
a procedure are already in existence, this can lead to unexpected
problems or failures, especially for naive users. Applying \sphinxcode{\sphinxupquote{cfg\_text2git}}
to a default dataset in which one has saved many text files already
(as per default added to the annex) will not place the existing, saved
files into Git \textendash{} only those text files created \sphinxstyleemphasis{after} the configuration
was applied.

\index{configuration item@\spxentry{configuration item}!datalad.locations.system\sphinxhyphen{}procedures@\spxentry{datalad.locations.system\sphinxhyphen{}procedures}}\index{configuration item@\spxentry{configuration item}!datalad.locations.user\sphinxhyphen{}procedures@\spxentry{datalad.locations.user\sphinxhyphen{}procedures}}\index{configuration item@\spxentry{configuration item}!datalad.locations.dataset\sphinxhyphen{}procedures@\spxentry{datalad.locations.dataset\sphinxhyphen{}procedures}}\index{configuration item@\spxentry{configuration item}!datalad.procedures.\textless{}name\textgreater{}.call\sphinxhyphen{}format@\spxentry{datalad.procedures.\textless{}name\textgreater{}.call\sphinxhyphen{}format}}\index{configuration item@\spxentry{configuration item}!datalad.procedures.\textless{}name\textgreater{}.help@\spxentry{datalad.procedures.\textless{}name\textgreater{}.help}}\index{datasets procedures@\spxentry{datasets procedures}!write your own@\spxentry{write your own}}\ignorespaces 

\subsection{Write your own procedures}
\label{\detokenize{basics/101-124-procedures:write-your-own-procedures}}\label{\detokenize{basics/101-124-procedures:index-6}}
\sphinxAtStartPar
Procedures can come with DataLad or its extensions, but anyone can
write their own ones in addition, and deploy them on individual machines,
or ship them within DataLad datasets. This allows to
automate routine configurations or tasks in a dataset, or share configurations that would otherwise not “stick” to the dataset.
Here are some general rules for creating a custom procedure:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A procedure can be any executable. Executables must have the
appropriate permissions and, in the case of a script,
must contain an appropriate {\hyperref[\detokenize{glossary:term-shebang}]{\sphinxtermref{\DUrole{xref,std,std-term}{shebang}}}}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
If a procedure is not executable, but its filename ends with
\sphinxcode{\sphinxupquote{.sh}}, it is automatically executed via {\hyperref[\detokenize{glossary:term-bash}]{\sphinxtermref{\DUrole{xref,std,std-term}{bash}}}}.

\end{itemize}

\item {} 
\sphinxAtStartPar
Procedures can implement any argument handling, but must be capable
of taking at least one positional argument (the absolute path to the
dataset they shall operate on).

\item {} 
\sphinxAtStartPar
Custom procedures rely heavily on configurations in \sphinxcode{\sphinxupquote{.datalad/config}}
(or the associated environment variables). Within \sphinxcode{\sphinxupquote{.datalad/config}},
each procedure should get an individual entry that contains at least
a short “help” description on what the procedure does. Below is a minimal
\sphinxcode{\sphinxupquote{.datalad/config}} entry for a custom procedure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{[datalad \PYGZdq{}procedures.\PYGZlt{}NAME\PYGZgt{}\PYGZdq{}]}
\PYG{+w}{   }\PYG{n+na}{help}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{This is a string to describe what the procedure does}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
By default, on GNU/Linux systems, DataLad will search for system\sphinxhyphen{}wide procedures
(i.e., procedures on the \sphinxstyleemphasis{system} level) in \sphinxcode{\sphinxupquote{/etc/xdg/datalad/procedures}},
for user procedures (i.e., procedures on the \sphinxstyleemphasis{global} level) in \sphinxcode{\sphinxupquote{\textasciitilde{}/.config/datalad/procedures}},
and for dataset procedures (i.e., the \sphinxstyleemphasis{local} level%
\begin{footnote}[2]\sphinxAtStartFootnote
Note that we simplify the level of procedures that exist within a dataset
by calling them \sphinxstyleemphasis{local}. Even though they apply to a dataset just as \sphinxstyleemphasis{local}
Git configurations, unlike Git’s \sphinxstyleemphasis{local} configurations in \sphinxcode{\sphinxupquote{.git/config}},
the procedures and procedure configurations in \sphinxcode{\sphinxupquote{.datalad/config}} are committed
and can be shared together with a dataset. The procedure level \sphinxstyleemphasis{local} therefore
does not exactly corresponds to the \sphinxstyleemphasis{local} scope in the sense that Git uses it.
%
\end{footnote}) in \sphinxcode{\sphinxupquote{.datalad/procedures}}
relative to a dataset root.
Note that \sphinxcode{\sphinxupquote{.datalad/procedures}} does not exist by default, and the \sphinxcode{\sphinxupquote{procedures}}
directory needs to be created first.

\item {} 
\sphinxAtStartPar
Alternatively to the default locations, DataLad can be pointed to the location of a procedure with a configuration in \sphinxcode{\sphinxupquote{.datalad/config}} (or with the help of the associated {\hyperref[\detokenize{glossary:term-environment-variable}]{\sphinxtermref{\DUrole{xref,std,std-term}{environment variable}}}}s).
The appropriate configuration keys for \sphinxcode{\sphinxupquote{.datalad/config}} are either \sphinxcode{\sphinxupquote{datalad.locations.system\sphinxhyphen{}procedures}} (for changing the \sphinxstyleemphasis{system} default), \sphinxcode{\sphinxupquote{datalad.locations.user\sphinxhyphen{}procedures}} (for changing the \sphinxstyleemphasis{global} default), or \sphinxcode{\sphinxupquote{datalad.locations.dataset\sphinxhyphen{}procedures}} (for changing the \sphinxstyleemphasis{local} default).
An example \sphinxcode{\sphinxupquote{.datalad/config}} entry for the local scope is shown below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{[datalad \PYGZdq{}locations\PYGZdq{}]}
\PYG{+w}{        }\PYG{n+na}{dataset\PYGZhy{}procedures}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{relative/path/from/dataset\PYGZhy{}root}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
By default, DataLad will call a procedure with a standard template defined by a format string:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{interpreter} \PYG{p}{\PYGZob{}}\PYG{n}{script}\PYG{p}{\PYGZcb{}} \PYG{p}{\PYGZob{}}\PYG{n}{ds}\PYG{p}{\PYGZcb{}} \PYG{p}{\PYGZob{}}\PYG{n}{arguments}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

\end{itemize}

\sphinxAtStartPar
where arguments can be any additional command line arguments a script (procedure) takes or requires.
This default format string can be customized within \sphinxcode{\sphinxupquote{.datalad/config}} in \sphinxcode{\sphinxupquote{datalad.procedures.\textless{}NAME\textgreater{}.call\sphinxhyphen{}format}}.
An example \sphinxcode{\sphinxupquote{.datalad/config}} entry with a changed call format string is shown below.
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{[datalad \PYGZdq{}procedures.\PYGZlt{}NAME\PYGZgt{}\PYGZdq{}]}
\PYG{+w}{   }\PYG{n+na}{help}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{This is a string to describe what the procedure does}
\PYG{+w}{   }\PYG{n+na}{call\PYGZhy{}format}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{python \PYGZob{}script\PYGZcb{} \PYGZob{}ds\PYGZcb{} \PYGZob{}somearg1\PYGZcb{} \PYGZob{}somearg2\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
By convention, procedures should leave a dataset in a clean state.

\end{itemize}

\sphinxAtStartPar
Therefore, in order to create a custom procedure, an executable script
in the appropriate location is fine. Placing a script \sphinxcode{\sphinxupquote{myprocedure}}
into \sphinxcode{\sphinxupquote{.datalad/procedures}} will allow running
\sphinxcode{\sphinxupquote{datalad run\sphinxhyphen{}procedure myprocedure}} in your dataset, and because
it is part of the dataset it will also allow distributing the procedure.
Below is a toy\sphinxhyphen{}example for a custom procedure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }create\PYG{+w}{ }somedataset\PYG{p}{;}\PYG{+w}{ }\PYG{n+nb}{cd}\PYG{+w}{ }somedataset
\PYG{g+go}{create(ok): /home/me/procs/somedataset (dataset)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mkdir\PYG{+w}{ }.datalad/procedures
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYG{+w}{ }.datalad/procedures/example.py
\PYG{g+go}{\PYGZdq{}\PYGZdq{}\PYGZdq{}A simple procedure to create a file \PYGZsq{}example\PYGZsq{} and store}
\PYG{g+go}{it in Git, and a file \PYGZsq{}example2\PYGZsq{} and annex it. The contents}
\PYG{g+go}{of \PYGZsq{}example\PYGZsq{} must be defined with a positional argument.\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{g+go}{import sys}
\PYG{g+go}{import os.path as op}
\PYG{g+go}{from datalad.distribution.dataset import require\PYGZus{}dataset}
\PYG{g+go}{from datalad.utils import create\PYGZus{}tree}

\PYG{g+go}{ds = require\PYGZus{}dataset(}
\PYG{g+go}{    sys.argv[1],}
\PYG{g+go}{    check\PYGZus{}installed=True,}
\PYG{g+go}{    purpose=\PYGZsq{}showcase an example procedure\PYGZsq{})}

\PYG{g+gp}{\PYGZsh{} }this\PYG{+w}{ }is\PYG{+w}{ }the\PYG{+w}{ }content\PYG{+w}{ }\PYG{k}{for}\PYG{+w}{ }file\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}example\PYGZdq{}}
\PYG{g+go}{content = \PYGZdq{}\PYGZdq{}\PYGZdq{}\PYGZbs{}}
\PYG{g+go}{This file was created by a custom procedure! Neat, huh?}
\PYG{g+go}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{g+gp}{\PYGZsh{} }create\PYG{+w}{ }a\PYG{+w}{ }directory\PYG{+w}{ }structure\PYG{+w}{ }template.\PYG{+w}{ }Write
\PYG{g+go}{tmpl = \PYGZob{}}
\PYG{g+go}{    \PYGZsq{}somedir\PYGZsq{}: \PYGZob{}}
\PYG{g+go}{        \PYGZsq{}example\PYGZsq{}: content,}
\PYG{g+go}{    \PYGZcb{},}
\PYG{g+go}{    \PYGZsq{}example2\PYGZsq{}: sys.argv[2] if sys.argv[2] else \PYGZdq{}got no input\PYGZdq{}}
\PYG{g+go}{\PYGZcb{}}

\PYG{g+gp}{\PYGZsh{} }actually\PYG{+w}{ }create\PYG{+w}{ }the\PYG{+w}{ }structure\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }the\PYG{+w}{ }dataset
\PYG{g+go}{create\PYGZus{}tree(ds.path, tmpl)}

\PYG{g+gp}{\PYGZsh{} }rule\PYG{+w}{ }to\PYG{+w}{ }store\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}example\PYGZsq{}}\PYG{+w}{ }Git
\PYG{g+go}{ds.repo.set\PYGZus{}gitattributes([(\PYGZsq{}example\PYGZsq{}, \PYGZob{}\PYGZsq{}annex.largefiles\PYGZsq{}: \PYGZsq{}nothing\PYGZsq{}\PYGZcb{})])}

\PYG{g+gp}{\PYGZsh{} }save\PYG{+w}{ }the\PYG{+w}{ }dataset\PYG{+w}{ }modifications
\PYG{g+go}{ds.save(message=\PYGZdq{}Apply custom procedure\PYGZdq{})}

\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add custom procedure\PYGZdq{}}
\PYG{g+go}{add(ok): .datalad/procedures/example.py (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
At this point, the dataset contains the custom procedure \sphinxcode{\sphinxupquote{example}}.
This is how it can be executed and what it does:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYGZhy{}procedure\PYG{+w}{ }example\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}this text will be in the file \PYGZsq{}example2\PYGZsq{}\PYGZdq{}}
\PYG{g+go}{[INFO] Running procedure example}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{add(ok): example2 (file)}
\PYG{g+go}{add(ok): somedir/example (file)}
\PYG{g+go}{add(ok): .gitattributes (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{run(ok): /home/me/procs/somedataset (dataset) [VIRTUALENV/bin/python /home/m...]}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} the directory structure has been created}
\PYG{g+gp}{\PYGZdl{} }tree
\PYG{g+go}{.}
\PYG{g+go}{├── example2 \PYGZhy{}\PYGZgt{} .git/annex/objects/G6/zw/✂/MD5E\PYGZhy{}s40\PYGZhy{}\PYGZhy{}2ed1bce0✂MD5}
\PYG{g+go}{└── somedir}
\PYG{g+go}{    └── example}

\PYG{g+go}{1 directory, 2 files}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} lets check out the contents in the files}
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }example2\PYG{+w}{  }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }cat\PYG{+w}{ }somedir/example
\PYG{g+go}{this text will be in the file \PYGZsq{}example2\PYGZsq{}}
\PYG{g+go}{This file was created by a custom procedure! Neat, huh?}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}f\PYG{+w}{ }.datalad/config\PYG{+w}{ }datalad.procedures.example.help\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}A toy example\PYGZdq{}}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add help description\PYGZdq{}}
\PYG{g+go}{add(ok): .datalad/config (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
To find out more about a given procedure, you can ask for help:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYGZhy{}procedure\PYG{+w}{ }\PYGZhy{}\PYGZhy{}help\PYGZhy{}proc\PYG{+w}{ }example
\PYG{g+go}{example (.datalad/procedures/example.py)}
\PYG{g+go}{A toy example}
\end{sphinxVerbatim}


\subsection{Conclusions}
\label{\detokenize{basics/101-124-procedures:conclusions}}
\sphinxAtStartPar
Summing up, DataLad’s \sphinxcode{\sphinxupquote{datalad run\sphinxhyphen{}procedure}} command is a handy tool
with useful existing procedures but much flexibility for your own
DIY procedure scripts. With the information of the last three sections
you should be able to write and understand necessary configurations,
but you can also rely on existing, preconfigured templates in the
form of procedures, and even write and distribute your own.

\sphinxAtStartPar
Therefore, envision procedures as
helper\sphinxhyphen{}tools that can minimize technical complexities
in a dataset \textendash{} users can concentrate on the actual task while
the dataset is set\sphinxhyphen{}up, structured, processed, or configured automatically
with the help of a procedure.
Especially in the case of trainees and new users, applying procedures
instead of doing relevant routines “by hand” can help to ease
working with the dataset. Other than by users, procedures can also be triggered to automatically
run after any command execution if a command results matches a specific
requirement.

\sphinxAtStartPar
Finally, make a note about running procedures inside of \sphinxcode{\sphinxupquote{notes.txt}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }notes.txt
\PYG{g+go}{It can be useful to use pre\PYGZhy{}configured procedures that can apply}
\PYG{g+go}{configurations, create files or file hierarchies, or perform arbitrary}
\PYG{g+go}{tasks in datasets. They can be shipped with DataLad, its extensions,}
\PYG{g+go}{or datasets, and you can even write your own procedures and distribute}
\PYG{g+go}{them.}
\PYG{g+go}{The \PYGZdq{}datalad run\PYGZhy{}procedure\PYGZdq{} command is used to apply such a procedure}
\PYG{g+go}{to a dataset. Procedures shipped with DataLad or its extensions}
\PYG{g+go}{starting with a \PYGZdq{}cfg\PYGZdq{} prefix can also be applied at the creation of a}
\PYG{g+go}{dataset with \PYGZdq{}datalad create \PYGZhy{}c \PYGZlt{}PROC\PYGZhy{}NAME\PYGZgt{} \PYGZlt{}PATH\PYGZgt{}\PYGZdq{} (omitting the}
\PYG{g+go}{\PYGZdq{}cfg\PYGZdq{} prefix).}

\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add note on DataLad\PYGZsq{}s procedures\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Summary}
\label{\detokenize{basics/101-125-summary:summary}}\label{\detokenize{basics/101-125-summary:summary-config}}\label{\detokenize{basics/101-125-summary::doc}}
\sphinxAtStartPar
This has been a substantial amount of information regarding various configuration
types, methods, and files. After this lecture, you have greatly broadened
your horizon about configurations of datasets:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Configurations exist at different scopes and for different tools. Each
of such configuration scopes exists in an individual file, on a \sphinxstyleemphasis{system\sphinxhyphen{}wide},
\sphinxstyleemphasis{global} (user\sphinxhyphen{}specific) or \sphinxstyleemphasis{local} (repository specific) level. In addition
to Git’s \sphinxstyleemphasis{local} scope in \sphinxcode{\sphinxupquote{.git/config}}, DataLad introduces its own configurations within
\sphinxcode{\sphinxupquote{.datalad/config}} that apply to a specific dataset, but are committed and
therefore distributed. More specialized scopes take precedence over more global scopes.

\item {} 
\sphinxAtStartPar
Almost all configurations can be set with the \sphinxcode{\sphinxupquote{git config}} command.
Its structure looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}\PYGZhy{}local/\PYGZhy{}\PYGZhy{}global/\PYGZhy{}\PYGZhy{}system\PYG{+w}{ }\PYGZhy{}\PYGZhy{}add/remove\PYGZhy{}all/\PYGZhy{}\PYGZhy{}list\PYG{+w}{ }section.\PYG{o}{[}subsection.\PYG{o}{]}variable\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}value\PYGZdq{}}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.git/config}} configuration file is not version controlled, other
configuration files (\sphinxcode{\sphinxupquote{.gitmodules}}, \sphinxcode{\sphinxupquote{.gitattributes}}, \sphinxcode{\sphinxupquote{.datalad/config}})
however are, and can be shared together with the dataset. Non\sphinxhyphen{}shared configurations
will take precedence over shared configurations in a dataset clone.

\item {} 
\sphinxAtStartPar
Other tools than Git can be configured with the \sphinxcode{\sphinxupquote{git config}} command
as well. If configurations needs to be written to a file other than a
\sphinxcode{\sphinxupquote{.git(/)config}} file, supply a path to this file with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}f/\sphinxhyphen{}\sphinxhyphen{}file}} flag
in a \sphinxcode{\sphinxupquote{git config}} command.

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.gitattributes}} file is the only configuration file the \sphinxcode{\sphinxupquote{git config}}
command cannot write to, because it has a different layout. However, run\sphinxhyphen{}procedures or
the user can write simple rules into it that determine which files are annexed
and which are stored in Git.

\item {} 
\sphinxAtStartPar
DataLad’s \sphinxcode{\sphinxupquote{run\sphinxhyphen{}procedure}}s offer an easy and fast alternative to DIY
configurations, structuring, or processing of the dataset, and offer means to share or ship configurations together with a dataset.
They can be applied already at creation of a dataset with \sphinxcode{\sphinxupquote{datalad create \sphinxhyphen{}c \textless{}procedure\textgreater{}}},
or executed later with a \sphinxcode{\sphinxupquote{datalad run\sphinxhyphen{}procedure}} command.

\end{itemize}


\subsection{Now what can I do with it?}
\label{\detokenize{basics/101-125-summary:now-what-can-i-do-with-it}}
\sphinxAtStartPar
Configurations are not a closed book for you anymore. What will probably be
especially helpful is your new knowledge about \sphinxcode{\sphinxupquote{.gitattributes}} and
DataLad’s \sphinxcode{\sphinxupquote{run\sphinxhyphen{}procedure}} command that allow you to configure the behavior
of git\sphinxhyphen{}annex in your dataset.

\sphinxstepscope


\chapter{You will find only what you bring in}
\label{\detokenize{basics/basics-yoda:you-will-find-only-what-you-bring-in}}\label{\detokenize{basics/basics-yoda:chapter-yoda}}\label{\detokenize{basics/basics-yoda::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{yoda}.pdf}\hspace*{\fill}}
\begin{quote}

\sphinxAtStartPar
Each choice, the branch of a tree is: What looked like a decision, is after only a pattern of growth.

\begin{flushright}
---Yoda
\end{flushright}
\end{quote}

\sphinxstepscope


\section{A data analysis project with DataLad}
\label{\detokenize{basics/101-126-intro:a-data-analysis-project-with-datalad}}\label{\detokenize{basics/101-126-intro:intromidterm}}\label{\detokenize{basics/101-126-intro::doc}}
\sphinxAtStartPar
Time flies and the semester rapidly approaches the midterms.
In DataLad\sphinxhyphen{}101, students are not given an exam \textendash{} instead, they are
asked to complete and submit a data analysis project with DataLad.

\sphinxAtStartPar
The lecturer hands out the requirements: The project…
\begin{itemize}
\item {} 
\sphinxAtStartPar
needs to be a data analysis project

\item {} 
\sphinxAtStartPar
is to be prepared in the form of a DataLad dataset

\item {} 
\sphinxAtStartPar
should incorporate DataLad whenever possible (data retrieval, publication,
script execution, general version control) and

\item {} 
\sphinxAtStartPar
needs to comply to the YODA principles

\end{itemize}

\sphinxAtStartPar
Luckily, the midterms are only in a couple of weeks, and a lot of the
requirements of the project will be taught in the upcoming sessions.
Therefore, there’s little you can do to prepare for the midterm
than to be extra attentive on the next lectures on the YODA
principles and DataLad’s Python API.

\sphinxstepscope

\index{YODA principles@\spxentry{YODA principles}|spxpagem}\index{data organization@\spxentry{data organization}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!data organization@\spxentry{data organization}}\index{project management@\spxentry{project management}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!project management@\spxentry{project management}}\ignorespaces 

\section{YODA: Best practices for data analyses in a dataset}
\label{\detokenize{basics/101-127-yoda:yoda-best-practices-for-data-analyses-in-a-dataset}}\label{\detokenize{basics/101-127-yoda:yoda}}\label{\detokenize{basics/101-127-yoda:id1}}\label{\detokenize{basics/101-127-yoda:index-0}}\label{\detokenize{basics/101-127-yoda::doc}}
\sphinxAtStartPar
The last requirement for the midterm projects reads “needs to comply to the
YODA principles”.
“What are the YODA principles?” you ask, as you have never heard of this
before.
“The topic of today’s lecture: Organizational principles of data
analyses in DataLad datasets. This lecture will show you the basic
principles behind creating, sharing, and publishing reproducible,
understandable, and open data analysis projects with DataLad.”, you
hear in return.


\subsection{The starting point…}
\label{\detokenize{basics/101-127-yoda:the-starting-point}}
\sphinxAtStartPar
Data analyses projects are very common, both in science and industry.
But it can be very difficult to produce a reproducible, let alone
\sphinxstyleemphasis{comprehensible} data analysis project.
Many data analysis projects do not start out with
a stringent organization, or fail to keep the structural organization of a
directory intact as the project develops. Often, this can be due to a lack of
version\sphinxhyphen{}control. In these cases, a project will quickly end up
with many
\sphinxhref{https://phdcomics.com/comics/archive.php?comicid=1531}{almost\sphinxhyphen{}identical scripts suffixed with “\_version\_xyz”},
or a chaotic results structure split between various directories with names
such as \sphinxcode{\sphinxupquote{results/}}, \sphinxcode{\sphinxupquote{results\_August19/}}, \sphinxcode{\sphinxupquote{results\_revision/}} and
\sphinxcode{\sphinxupquote{now\_with\_nicer\_plots/}}. Something like this is a very
common shape a data science project may take after a while:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{├── code/}
\PYG{g+go}{│   ├── code\PYGZus{}final/}
\PYG{g+go}{│   │   ├── final\PYGZus{}2/}
\PYG{g+go}{│   │   │   ├── main\PYGZus{}script\PYGZus{}fixed.py}
\PYG{g+go}{│   │   │   └── takethisscriptformostthingsnow.py}
\PYG{g+go}{│   │   ├── main\PYGZus{}script.py}
\PYG{g+go}{│   │   ├── utils\PYGZus{}new.py}
\PYG{g+go}{│   │   ├── utils\PYGZus{}2.py}
\PYG{g+go}{│   │   └── main\PYGZus{}analysis\PYGZus{}newparameters.py}
\PYG{g+go}{│   └── main\PYGZus{}script\PYGZus{}DONTUSE.py}
\PYG{g+go}{├── data/}
\PYG{g+go}{│   ├── data\PYGZus{}updated/}
\PYG{g+go}{│   │   └── dataset1/}
\PYG{g+go}{│   │       └── datafile\PYGZus{}a}
\PYG{g+go}{│   ├── dataset1/}
\PYG{g+go}{│   │    └── datafile\PYGZus{}a}
\PYG{g+go}{│   ├── outputs/}
\PYG{g+go}{│   │   ├── figures/}
\PYG{g+go}{│   │   │   ├── figures\PYGZus{}new.py}
\PYG{g+go}{│   │   │   └── figures\PYGZus{}final\PYGZus{}forreal.py}
\PYG{g+go}{│   │   ├── important\PYGZus{}results/}
\PYG{g+go}{│   │   ├── random\PYGZus{}results\PYGZus{}file.tsv}
\PYG{g+go}{│   │   ├── results\PYGZus{}for\PYGZus{}paper/}
\PYG{g+go}{│   │   ├── results\PYGZus{}for\PYGZus{}paper\PYGZus{}revised/}
\PYG{g+go}{│   │   └── results\PYGZus{}new\PYGZus{}data/}
\PYG{g+go}{│   ├── random\PYGZus{}results\PYGZus{}file.tsv}
\PYG{g+go}{│   ├── random\PYGZus{}results\PYGZus{}file\PYGZus{}v2.tsv}
\PYG{g+go}{...}
\end{sphinxVerbatim}

\sphinxAtStartPar
All data analysis endeavors in directories like this \sphinxstyleemphasis{can} work, for a while,
if there is a person who knows the project well, and works on it all the time.
But it inevitably will get messy once anyone tries to collaborate on a project
like this, or simply goes on a two\sphinxhyphen{}week vacation and forgets whether
the function in \sphinxcode{\sphinxupquote{main\_analysis\_newparameters.py}} or the one in
\sphinxcode{\sphinxupquote{takethisscriptformostthingsnow.py}} was the one that created a particular figure.

\sphinxAtStartPar
But even if a project has an intuitive structure, and \sphinxstyleemphasis{is} version
controlled, in many cases an analysis script will stop working, or maybe worse,
will produce different results, because the software and tools used to
conduct the analysis in the first place got an update. This update may have
come with software changes that made functions stop working, or work differently
than before.
In the same vein, recomputing an analysis project on a different machine than
the one the analysis was developed on can fail if the necessary
software in the required versions is not installed or available on this new machine.
The analysis might depend on software that runs on a Linux machine, but the project
was shared with a Windows user. The environment during analysis development used
Python 2, but the new system has only Python 3 installed. Or one of the dependent
libraries needs to be in version X, but is installed as version Y.

\sphinxAtStartPar
The YODA principles are a clear set of organizational standards for
datasets used for data analysis projects that aim to overcome issues like the
ones outlined above. The name stands for
“YODAs Organigram on Data Analysis”%
\begin{footnote}[1]\sphinxAtStartFootnote
“Why does the acronym contain itself?” you ask confused.
“That’s because it’s a \sphinxhref{https://en.wikipedia.org/wiki/Recursive\_acronym}{recursive acronym},
where the first letter stands recursively for the whole acronym.” you get in response.
“This is a reference to the recursiveness within a DataLad dataset \textendash{} all principles
apply recursively to all the subdatasets a dataset has.”
“And what does all of this have to do with Yoda?” you ask mildly amused.
“Oh, well. That’s just because the DataLad team is full of geeks.”
%
\end{footnote}. The principles outlined
in YODA set simple rules for directory names and structures, best\sphinxhyphen{}practices for
version\sphinxhyphen{}controlling dataset elements and analyses, facilitate
usage of tools to improve the reproducibility and accountability
of data analysis projects, and make collaboration easier.
They are summarized in three basic principles, that translate to both
dataset structures and best practices regarding the analysis:
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{basics/101-127-yoda:p1}]{\sphinxcrossref{\DUrole{std,std-ref}{P1: One thing, one dataset}}}} (\autopageref*{\detokenize{basics/101-127-yoda:p1}})

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{basics/101-127-yoda:p2}]{\sphinxcrossref{\DUrole{std,std-ref}{P2: Record where you got it from, and where it is now}}}} (\autopageref*{\detokenize{basics/101-127-yoda:p2}})

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{basics/101-127-yoda:p3}]{\sphinxcrossref{\DUrole{std,std-ref}{P3: Record what you did to it, and with what}}}} (\autopageref*{\detokenize{basics/101-127-yoda:p3}})

\end{itemize}

\sphinxAtStartPar
As you will see, complying to these principles is easy if you
use DataLad. Let’s go through them one by one.


\subsection{P1: One thing, one dataset}
\label{\detokenize{basics/101-127-yoda:p1-one-thing-one-dataset}}\label{\detokenize{basics/101-127-yoda:p1}}
\sphinxAtStartPar
Whenever a particular collection of files could be useful in more
than one context, make them a standalone, modular component.
In the broadest sense, this means to structure your study elements (data, code,
computational environments, results, …) in dedicated directories. For example:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Store \sphinxstylestrong{input data} for an analysis in a dedicated \sphinxcode{\sphinxupquote{inputs/}} directory.
Keep different formats or processing\sphinxhyphen{}stages of your input data as individual,
modular components:  Do not mix raw data, data that is already structured
following community guidelines of the given field, or preprocessed data, but create
one data component for each of them. And if your analysis
relies on two or more data collections, these collections should each be an
individual component, not combined into one.

\item {} 
\sphinxAtStartPar
Store scripts or \sphinxstylestrong{code} used for the analysis of data in a dedicated \sphinxcode{\sphinxupquote{code/}}
directory, outside of the data component of the dataset.

\item {} 
\sphinxAtStartPar
Collect \sphinxstylestrong{results} of an analysis in a dedicated place, outside of the \sphinxcode{\sphinxupquote{inputs/}} directory, and
leave the input data of an analysis untouched by your computations.

\item {} 
\sphinxAtStartPar
Include a place for complete \sphinxstylestrong{execution environments}, such as
\sphinxhref{https://singularity.lbl.gov}{singularity images} or
\sphinxhref{https://www.docker.com/get-started}{docker containers}%
\begin{footnote}[2]\sphinxAtStartFootnote
If you want to learn more about Docker and Singularity, or general information
about containerized computational environments for reproducible data science,
check out \sphinxhref{https://the-turing-way.netlify.app/reproducible-research/renv/renv-containers.html}{this section}
in the wonderful book \sphinxhref{https://the-turing-way.netlify.app}{The Turing Way},
a comprehensive guide to reproducible data science, or read about it in
section {\hyperref[\detokenize{basics/101-133-containersrun:containersrun}]{\sphinxcrossref{\DUrole{std,std-ref}{Computational reproducibility with software containers}}}} (\autopageref*{\detokenize{basics/101-133-containersrun:containersrun}}).
%
\end{footnote}, in
the form of an \sphinxcode{\sphinxupquote{envs/}} directory, if relevant for your analysis.

\item {} 
\sphinxAtStartPar
And if you conduct multiple different analyses, create a dedicated
project for each analysis, instead of conflating them.

\end{itemize}

\sphinxAtStartPar
This, for example, would be a directory structure from the root of a
superdataset of a very comprehensive data analysis project complying to the YODA principles:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{├── ci/                         \PYGZsh{} continuous integration configuration}
\PYG{g+go}{│   └── .travis.yml}
\PYG{g+go}{├── code/                       \PYGZsh{} your code}
\PYG{g+go}{│   ├── tests/                  \PYGZsh{} unit tests to test your code}
\PYG{g+go}{│   │   └── test\PYGZus{}myscript.py}
\PYG{g+go}{│   └── myscript.py}
\PYG{g+go}{├── docs                        \PYGZsh{} documentation about the project}
\PYG{g+go}{│   ├── build/}
\PYG{g+go}{│   └── source/}
\PYG{g+go}{├── envs                        \PYGZsh{} computational environments}
\PYG{g+go}{│   └── Singularity}
\PYG{g+go}{├── inputs/                     \PYGZsh{} dedicated inputs/, will not be changed by an analysis}
\PYG{g+go}{│   └─── data/}
\PYG{g+go}{│       ├── dataset1/           \PYGZsh{} one stand\PYGZhy{}alone data component}
\PYG{g+go}{│       │   └── datafile\PYGZus{}a}
\PYG{g+go}{│       └── dataset2/}
\PYG{g+go}{│           └── datafile\PYGZus{}a}
\PYG{g+go}{├── important\PYGZus{}results/          \PYGZsh{} outputs away from the input data}
\PYG{g+go}{│   └── figures/}
\PYG{g+go}{├── CHANGELOG.md                \PYGZsh{} notes for fellow humans about your project}
\PYG{g+go}{├── HOWTO.md}
\PYG{g+go}{└── README.md}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can get a few non\sphinxhyphen{}DataLad related advice for structuring your directories in the
\textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-yodaproject}} {\hyperref[\detokenize{basics/101-127-yoda:fom-yodaproject}]{\sphinxcrossref{\DUrole{std,std-ref}{on best practices for analysis organization}}}} (\autopageref*{\detokenize{basics/101-127-yoda:fom-yodaproject}}).

\index{recommendation@\spxentry{recommendation}!dataset content organization@\spxentry{dataset content organization}}\index{dataset content organization@\spxentry{dataset content organization}!recommendation@\spxentry{recommendation}}\ignorespaces \begin{findoutmore}[label={fom-yodaproject}, before title={\thetcbcounter\ }, float, floatplacement=tbp, check odd page=true]{More best practices for organizing contents in directories}
\label{\detokenize{basics/101-127-yoda:fom-yodaproject}}

\sphinxAtStartPar
The exemplary YODA directory structure is very comprehensive, and displays many best\sphinxhyphen{}practices for
reproducible data science. For example,
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Within \sphinxcode{\sphinxupquote{code/}}, it is best practice to add \sphinxstylestrong{tests} for the code.
These tests can be run to check whether the code still works.

\item {} 
\sphinxAtStartPar
It is even better to further use automated computing such as
\sphinxhref{https://en.wikipedia.org/wiki/Continuous\_integration}{continuous integration (CI) systems},
to test the functionality of your functions and scripts automatically.
If relevant, the setup for continuous integration frameworks (such as
\sphinxhref{https://www.appveyor.com}{Appveyor}) lives outside of \sphinxcode{\sphinxupquote{code/}},
in a dedicated \sphinxcode{\sphinxupquote{ci/}} directory.

\item {} 
\sphinxAtStartPar
Include \sphinxstylestrong{documents for fellow humans}: Notes in a README.md or a HOWTO.md,
or even proper documentation (for example, using  in a dedicated \sphinxcode{\sphinxupquote{docs/}} directory.
Within these documents, include all relevant metadata for your analysis. If you are
conducting a scientific study, this might be authorship, funding,
change log, etc.

\end{enumerate}

\sphinxAtStartPar
If writing tests for analysis scripts or using continuous integration
is a new idea for you, but you want to learn more, check out
\sphinxhref{https://the-turing-way.netlify.app/reproducible-research/testing}{this chapter on testing}.


\end{findoutmore}

\sphinxAtStartPar
There are many advantages to this modular way of organizing contents.
Having input data as independent components that are not altered (only
consumed) by an analysis does not conflate the data for
an analysis with the results or the code, thus assisting understanding
the project for anyone unfamiliar with it.
But more than just structure, this organization aids modular reuse or
publication of the individual components, for example data. In a
YODA\sphinxhyphen{}compliant dataset, any processing stage of a data component can
be reused in a new project or published and shared. The same is true
for a whole analysis dataset. At one point you might also write a
scientific paper about your analysis in a paper project, and the
whole analysis project can easily become a modular component in a paper
project, to make sharing paper, code, data, and results easy.

\begin{figure}[tbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{dataset_modules}.pdf}
\caption{Data are modular components that can be re\sphinxhyphen{}used easily.}\label{\detokenize{basics/101-127-yoda:dataset-modules}}\end{figure}

\sphinxAtStartPar
The directory tree above and \hyperref[\detokenize{basics/101-127-yoda:dataset-modules}]{Fig.\@ \ref{\detokenize{basics/101-127-yoda:dataset-modules}}} highlight different aspects
of this principle. The directory tree illustrates the structure of
the individual pieces on the file system from the point of view of
a single top\sphinxhyphen{}level dataset with a particular purpose. For example, it
could be an analysis dataset created by a statistician for a scientific
project, and it could be shared between collaborators or
with others during development of the project. In this
superdataset, code is created that operates on input data to
compute outputs, and the code and outputs are captured,
version\sphinxhyphen{}controlled, and linked to the input data. Each input data in turn
is a (potentially nested) subdataset, but this is not visible
in the directory hierarchy.
\hyperref[\detokenize{basics/101-127-yoda:dataset-modules}]{Fig.\@ \ref{\detokenize{basics/101-127-yoda:dataset-modules}}}, in comparison, emphasizes a process view on a project and
the nested structure of input subdataset:
You can see how the preprocessed data that serves as an input for
the analysis datasets evolves from raw data to
standardized data organization to its preprocessed state. Within
the \sphinxcode{\sphinxupquote{data/}} directory of the file system hierarchy displayed
above one would find data datasets with their previous version as
a subdataset, and this is repeated recursively until one reaches
the raw data as it was originally collected at one point. A finished
analysis project in turn can be used as a component (subdataset) in
a paper project, such that the paper is a fully reproducible research
object that shares code, analysis results, and data, as well as the
history of all of these components.

\sphinxAtStartPar
Principle 1, therefore, encourages to structure data analysis
projects in a clear and modular fashion that makes use of nested
DataLad datasets, yielding comprehensible structures and reusable
components. Having each component version\sphinxhyphen{}controlled \textendash{}
regardless of size \textendash{}  will aid keeping directories clean and
organized, instead of piling up different versions of code, data,
or results.


\subsection{P2: Record where you got it from, and where it is now}
\label{\detokenize{basics/101-127-yoda:p2-record-where-you-got-it-from-and-where-it-is-now}}\label{\detokenize{basics/101-127-yoda:p2}}
\sphinxAtStartPar
It is good to have data, but it is even better if you and anyone you
collaborate or share the project or its components with can find
out where the data came from, or how it
is dependent on or linked to other data. Therefore, this principle
aims to attach this information, the data’s {\hyperref[\detokenize{glossary:term-provenance}]{\sphinxtermref{\DUrole{xref,std,std-term}{provenance}}}}, to the components of
your data analysis project.

\sphinxAtStartPar
Luckily, this is a no\sphinxhyphen{}brainer with DataLad, because the core data structure
of DataLad, the dataset, and many of the DataLad commands already covered
up to now fulfill this principle.

\sphinxAtStartPar
If data components of a project are DataLad datasets, they can
be included in an analysis superdataset as subdatasets. Thanks to
\sphinxcode{\sphinxupquote{datalad clone}}, information on the source of these subdatasets
is stored in the history of the analysis superdataset, and they can even be
updated from those sources if the original data dataset gets extended or changed.
If you are including a file, for example, code from GitHub,
the \sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}} command, introduced in section {\hyperref[\detokenize{basics/101-102-populate:populate}]{\sphinxcrossref{\DUrole{std,std-ref}{Populate a dataset}}}} (\autopageref*{\detokenize{basics/101-102-populate:populate}}),
will record the source of it safely in the dataset’s history. And if you add anything to your dataset,
from simple incremental coding progress in your analysis scripts up to
files that a colleague sent you via email, a plain \sphinxcode{\sphinxupquote{datalad save}}
with a helpful commit message goes a very long way to fulfill this principle
on its own already.

\sphinxAtStartPar
One core aspect of this principle is \sphinxstyleemphasis{linking} between reusable data
resource units (i.e., DataLad subdatasets containing pure data). You will
be happy to hear that this is achieved by simply installing datasets
as subdatasets, as \hyperref[\detokenize{basics/101-127-yoda:fig-subds}]{Fig.\@ \ref{\detokenize{basics/101-127-yoda:fig-subds}}} shows.
This part of this principle will therefore be absolutely obvious to you
because you already know how to install and nest datasets within datasets.
“I might just overcome my impostor syndrome if I experience such advanced
reproducible analysis concepts as being obvious”, you think with a grin.

\begin{figure}[tbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{data_origin}.pdf}
\caption{Schematic illustration of two standalone data datasets installed as subdatasets
into an analysis project.}\label{\detokenize{basics/101-127-yoda:id6}}\label{\detokenize{basics/101-127-yoda:fig-subds}}\end{figure}

\sphinxAtStartPar
But more than linking datasets in a superdataset, linkage also needs to
be established between components of your dataset. Scripts inside of
your \sphinxcode{\sphinxupquote{code/}} directory should point to data not as {\hyperref[\detokenize{glossary:term-absolute-path}]{\sphinxtermref{\DUrole{xref,std,std-term}{absolute path}}}}s
that would only work on your system, but instead as {\hyperref[\detokenize{glossary:term-relative-path}]{\sphinxtermref{\DUrole{xref,std,std-term}{relative path}}}}s
that will work in any shared copy of your dataset. The next section
demonstrates a YODA data analysis project and will show concrete examples of this.

\sphinxAtStartPar
Lastly, this principle also includes \sphinxstyleemphasis{moving}, \sphinxstyleemphasis{sharing}, and \sphinxstyleemphasis{publishing} your
datasets or its components.
It is usually costly to collect data, and economically unfeasible%
\begin{footnote}[3]\sphinxAtStartFootnote
Substitute unfeasible with \sphinxstyleemphasis{wasteful}, \sphinxstyleemphasis{impractical}, or simply \sphinxstyleemphasis{stupid} if preferred.
%
\end{footnote} to keep
it locked in a drawer (or similarly out of reach behind complexities of
data retrieval or difficulties in understanding the data structure).
But conducting several projects on the same dataset yourself, sharing it with
collaborators, or publishing it is easy if the project is a DataLad dataset
that can be installed and retrieved on demand, and is kept clean from
everything that is not part of the data according to principle 1.
Conducting transparent open science is easier if you can link code, data,
and results within a dataset, and share everything together. In conjunction
with principle 1, this means that you can distribute your analysis projects
(or parts of it) in a comprehensible form, exemplified in \hyperref[\detokenize{basics/101-127-yoda:fig-yodads}]{Fig.\@ \ref{\detokenize{basics/101-127-yoda:fig-yodads}}}.

\begin{figure}[tbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{decentralized_publishing}.pdf}
\caption{In a dataset that complies to the YODA principles, modular components
(data, analysis results, papers) can be shared or published easily.}\label{\detokenize{basics/101-127-yoda:id7}}\label{\detokenize{basics/101-127-yoda:fig-yodads}}\end{figure}

\sphinxAtStartPar
Principle 2, therefore, facilitates transparent linkage of datasets and their
components to other components, their original sources, or shared copies.
With the DataLad tools you learned to master up to this point,
you have all the necessary skills to comply to it already.


\subsection{P3: Record what you did to it, and with what}
\label{\detokenize{basics/101-127-yoda:p3-record-what-you-did-to-it-and-with-what}}\label{\detokenize{basics/101-127-yoda:p3}}
\sphinxAtStartPar
This last principle is about capturing \sphinxstyleemphasis{how exactly the content of
every file came to be} that was not obtained from elsewhere. For example,
this relates to results generated from inputs by scripts or commands.
The section {\hyperref[\detokenize{basics/101-108-run:run}]{\sphinxcrossref{\DUrole{std,std-ref}{Keeping track}}}} (\autopageref*{\detokenize{basics/101-108-run:run}}) already outlined the problem of associating
a result with an input and a script. It can be difficult to link a
figure from your data analysis project with an input data file or a
script, even if you created this figure yourself.
The \sphinxcode{\sphinxupquote{datalad run}} command however mitigates these difficulties,
and captures the provenance of any output generated with a
\sphinxcode{\sphinxupquote{datalad run}} call in the history of the dataset. Thus, by using
\sphinxcode{\sphinxupquote{datalad run}} in analysis projects, your dataset knows
which result was generated when, by which author, from which inputs,
and by means of which command.

\sphinxAtStartPar
With another DataLad command one can even go one step further:
The command \sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}run}} \sphinxhyphen{} it will be introduced in
section {\hyperref[\detokenize{basics/101-133-containersrun:containersrun}]{\sphinxcrossref{\DUrole{std,std-ref}{Computational reproducibility with software containers}}}} (\autopageref*{\detokenize{basics/101-133-containersrun:containersrun}}) \sphinxhyphen{} performs a command execution within
a configured containerized environment. Thus, not only inputs,
outputs, command, time, and author, but also the \sphinxstyleemphasis{software environment}
are captured as provenance of a dataset component such as a results file,
and, importantly, can be shared together with the dataset in the
form of a software container.

\sphinxAtStartPar
Tip: Make use of \sphinxcode{\sphinxupquote{datalad run}}’s \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dry\sphinxhyphen{}run}} option to craft your run\sphinxhyphen{}command, as outlined in {\hyperref[\detokenize{basics/101-110-run2:dryrun}]{\sphinxcrossref{\DUrole{std,std-ref}{Dry\sphinxhyphen{}running your run call}}}} (\autopageref*{\detokenize{basics/101-110-run2:dryrun}})!

\sphinxAtStartPar
With this last principle, your dataset collects and stores provenance
of all the contents you created in the wake of your analysis project.
This established trust in your results, and enables others to understand
where files derive from.


\subsection{The YODA procedure}
\label{\detokenize{basics/101-127-yoda:the-yoda-procedure}}\label{\detokenize{basics/101-127-yoda:yodaproc}}
\sphinxAtStartPar
There is one tool that can make starting a yoda\sphinxhyphen{}compliant data analysis
easier: DataLad’s \sphinxcode{\sphinxupquote{yoda}} procedure. Just as the \sphinxcode{\sphinxupquote{text2git}} procedure
from section {\hyperref[\detokenize{basics/101-101-create:createds}]{\sphinxcrossref{\DUrole{std,std-ref}{Create a dataset}}}} (\autopageref*{\detokenize{basics/101-101-create:createds}}), the \sphinxcode{\sphinxupquote{yoda}} procedure can be included in a
\sphinxcode{\sphinxupquote{datalad create}} command and will apply useful configurations
to your dataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }yoda\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}my\PYGZus{}analysis\PYGZdq{}}

\PYG{g+go}{[INFO   ] Creating a new annex repo at /home/me/repos/testing/my\PYGZus{}analysis}
\PYG{g+go}{create(ok): /home/me/repos/testing/my\PYGZus{}analysis (dataset)}
\PYG{g+go}{[INFO   ] Running procedure cfg\PYGZus{}yoda}
\PYG{g+go}{[INFO   ] == Command start (output follows) =====}
\PYG{g+go}{[INFO   ] == Command exit (modification check follows) =====}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s take a look at what configurations and changes come with this procedure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }tree\PYG{+w}{ }\PYGZhy{}a

\PYG{g+go}{.}
\PYG{g+go}{├── .gitattributes}
\PYG{g+go}{├── CHANGELOG.md}
\PYG{g+go}{├── code}
\PYG{g+go}{│   ├── .gitattributes}
\PYG{g+go}{│   └── README.md}
\PYG{g+go}{└── README.md}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s take a closer look into the \sphinxcode{\sphinxupquote{.gitattributes}} files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }less\PYG{+w}{ }.gitattributes

\PYG{g+go}{**/.git* annex.largefiles=nothing}
\PYG{g+go}{CHANGELOG.md annex.largefiles=nothing}
\PYG{g+go}{README.md annex.largefiles=nothing}

\PYG{g+gp}{\PYGZdl{} }less\PYG{+w}{ }code/.gitattributes

\PYG{g+go}{* annex.largefiles=nothing}
\end{sphinxVerbatim}

\sphinxAtStartPar
Summarizing these two glimpses into the dataset, this configuration has
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
included a code directory in your dataset

\item {} 
\sphinxAtStartPar
included three files for human consumption (\sphinxcode{\sphinxupquote{README.md}}, \sphinxcode{\sphinxupquote{CHANGELOG.md}})

\item {} 
\sphinxAtStartPar
configured everything in the \sphinxcode{\sphinxupquote{code/}} directory to be tracked by Git, not git\sphinxhyphen{}annex%
\begin{footnote}[4]\sphinxAtStartFootnote
To re\sphinxhyphen{}read how \sphinxcode{\sphinxupquote{.gitattributes}} work, go back to section {\hyperref[\detokenize{basics/101-122-config:config}]{\sphinxcrossref{\DUrole{std,std-ref}{Local configuration}}}} (\autopageref*{\detokenize{basics/101-122-config:config}}), and to remind yourself
about how this worked for the \sphinxcode{\sphinxupquote{text2git}} configuration, go back to section {\hyperref[\detokenize{basics/101-114-txt2git:text2git}]{\sphinxcrossref{\DUrole{std,std-ref}{Data safety}}}} (\autopageref*{\detokenize{basics/101-114-txt2git:text2git}}).
%
\end{footnote}

\item {} 
\sphinxAtStartPar
and configured \sphinxcode{\sphinxupquote{README.md}} and \sphinxcode{\sphinxupquote{CHANGELOG.md}} in the root of the dataset to be
tracked by Git.

\end{enumerate}

\sphinxAtStartPar
Your next data analysis project can thus get a head start with useful configurations
and the start of a comprehensible directory structure by applying the \sphinxcode{\sphinxupquote{yoda}} procedure.


\subsection{Sources}
\label{\detokenize{basics/101-127-yoda:sources}}
\sphinxAtStartPar
This section is based on a comprehensive
\sphinxhref{https://f1000research.com/posters/7-1965}{poster} and publicly
available \sphinxhref{https://github.com/myyoda/talk-principles}{slides} about the
YODA principles.

\sphinxstepscope

\index{data analysis@\spxentry{data analysis}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!data analysis@\spxentry{data analysis}}\ignorespaces 

\section{YODA\sphinxhyphen{}compliant data analysis projects}
\label{\detokenize{basics/101-130-yodaproject:yoda-compliant-data-analysis-projects}}\label{\detokenize{basics/101-130-yodaproject:yoda-project}}\label{\detokenize{basics/101-130-yodaproject:index-0}}\label{\detokenize{basics/101-130-yodaproject::doc}}
\sphinxAtStartPar
Now that you know about the YODA principles, it is time to start working on
\sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}’s midterm project. Because the midterm project guidelines
require a YODA\sphinxhyphen{}compliant data analysis project, you will not only have theoretical
knowledge about the YODA principles, but also gain practical experience.

\sphinxAtStartPar
In principle, you can prepare YODA\sphinxhyphen{}compliant data analyses in any programming
language of your choice. But because you are already familiar with
the \sphinxhref{https://www.python.org}{Python} programming language, you decide
to script your analysis in Python. Delighted, you find out that there is even
a Python API for DataLad’s functionality that you can read about in {\hyperref[\detokenize{basics/101-130-yodaproject:fom-pythonapi}]{\sphinxcrossref{\DUrole{std,std-ref}{a Find\sphinxhyphen{}out\sphinxhyphen{}more on DataLad in Python}}}} (\autopageref*{\detokenize{basics/101-130-yodaproject:fom-pythonapi}}).

\index{use DataLad API@\spxentry{use DataLad API}!with Python@\spxentry{with Python}}\index{with Python@\spxentry{with Python}!use DataLad API@\spxentry{use DataLad API}}\ignorespaces \phantomsection\label{\detokenize{basics/101-130-yodaproject:pythonapi}}\begin{findoutmore}[label={fom-pythonapi}, before title={\thetcbcounter\ }, float, check odd page=true]{DataLad’s Python API}
\label{\detokenize{basics/101-130-yodaproject:fom-pythonapi}}
\phantomsection\label{\detokenize{basics/101-130-yodaproject:python}}
\sphinxAtStartPar
Whatever you can do with DataLad from the command line, you can also do it with
DataLad’s Python API.
Thus, DataLad’s functionality can also be used within interactive Python sessions
or Python scripts.
All of DataLad’s user\sphinxhyphen{}oriented commands are exposed via \sphinxcode{\sphinxupquote{datalad.api}}.
Thus, any command can be imported as a stand\sphinxhyphen{}alone command like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{datalad}\PYG{n+nn}{.}\PYG{n+nn}{api} \PYG{k+kn}{import} \PYG{o}{\PYGZlt{}}\PYG{n}{COMMAND}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Alternatively, to import all commands, one can use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{datalad}\PYG{n+nn}{.}\PYG{n+nn}{api} \PYG{k}{as} \PYG{n+nn}{dl}
\end{sphinxVerbatim}

\sphinxAtStartPar
and subsequently access commands as \sphinxcode{\sphinxupquote{dl.get()}}, \sphinxcode{\sphinxupquote{dl.clone()}}, and so forth.

\sphinxAtStartPar
The \sphinxhref{https://docs.datalad.org/en/latest/modref.html}{developer documentation}
of DataLad lists an overview of all commands, but naming is congruent to the
command line interface. The only functionality that is not available at the
command line is \sphinxcode{\sphinxupquote{datalad.api.Dataset}}, DataLad’s core Python data type.
Just like any other command, it can be imported like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{datalad}\PYG{n+nn}{.}\PYG{n+nn}{api} \PYG{k+kn}{import} \PYG{n}{Dataset}
\end{sphinxVerbatim}

\sphinxAtStartPar
or like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{datalad}\PYG{n+nn}{.}\PYG{n+nn}{api} \PYG{k}{as} \PYG{n+nn}{dl}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dl}\PYG{o}{.}\PYG{n}{Dataset}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{Dataset}} is a \sphinxhref{https://docs.python.org/3/tutorial/classes.html}{class}
that represents a DataLad dataset. In addition to the
stand\sphinxhyphen{}alone commands, all of DataLad’s functionality is also available via
\sphinxhref{https://docs.python.org/3/tutorial/classes.html\#method-objects}{methods}
of this class. Thus, these are two equally valid ways to create a new
dataset with DataLad in Python:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{datalad}\PYG{n+nn}{.}\PYG{n+nn}{api} \PYG{k+kn}{import} \PYG{n}{create}\PYG{p}{,} \PYG{n}{Dataset}
\PYG{g+go}{\PYGZsh{} create as a stand\PYGZhy{}alone command}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{create}\PYG{p}{(}\PYG{n}{path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scratch/test}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{[INFO   ] Creating a new annex repo at /.../scratch/test}
\PYG{g+go}{Out[3]: \PYGZlt{}Dataset path=/home/me/scratch/test\PYGZgt{}}
\PYG{g+go}{\PYGZsh{} create as a dataset method}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ds} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scratch/test}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ds}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[INFO   ] Creating a new annex repo at /.../scratch/test}
\PYG{g+go}{Out[3]: \PYGZlt{}Dataset path=/home/me/scratch/test\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
As shown above, the only required parameter for a Dataset is the \sphinxcode{\sphinxupquote{path}} to
its location, and this location may or may not exist yet.

\sphinxAtStartPar
Stand\sphinxhyphen{}alone functions have a \sphinxcode{\sphinxupquote{dataset=}} argument, corresponding to the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}d/\sphinxhyphen{}\sphinxhyphen{}dataset}} option in their command\sphinxhyphen{}line equivalent. You can specify
the \sphinxcode{\sphinxupquote{dataset=}} argument with a path (string) to your dataset (such as
\sphinxcode{\sphinxupquote{dataset=\textquotesingle{}.\textquotesingle{}}} for the current directory, or \sphinxcode{\sphinxupquote{dataset=\textquotesingle{}path/to/ds\textquotesingle{}}} to
another location). Alternatively, you can pass a \sphinxcode{\sphinxupquote{Dataset}} instance to it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{datalad}\PYG{n+nn}{.}\PYG{n+nn}{api} \PYG{k+kn}{import} \PYG{n}{save}\PYG{p}{,} \PYG{n}{Dataset}
\PYG{g+go}{\PYGZsh{} use save with dataset specified as a path}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{save}\PYG{p}{(}\PYG{n}{dataset}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{path/to/dataset/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsh{} use save with dataset specified as a dataset instance}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ds} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{path/to/dataset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{save}\PYG{p}{(}\PYG{n}{dataset}\PYG{o}{=}\PYG{n}{ds}\PYG{p}{,} \PYG{n}{message}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{saving all modifications}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsh{} use save as a dataset method (no dataset argument)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ds}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{message}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{saving all modifications}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Use cases for DataLad’s Python API}

\sphinxAtStartPar
Using the command line or the Python API of DataLad are both valid ways to accomplish the same results.
Depending on your workflows, using the Python API can help to automate dataset operations, provides an alternative
to the command line, or could be useful for scripting reproducible data analyses.
One unique advantage of the Python API is the \sphinxcode{\sphinxupquote{Dataset}}:
As the Python API does not suffer from the startup time cost of the command line,
there is the potential for substantial speed\sphinxhyphen{}up when doing many calls to the API,
and using a persistent Dataset object instance.
You will also notice that the output of Python commands can be more verbose as the result records returned by each command do not get filtered by command\sphinxhyphen{}specific result renderers.
Thus, the outcome of \sphinxcode{\sphinxupquote{dl.status(\textquotesingle{}myfile\textquotesingle{})}} matches that of \sphinxcode{\sphinxupquote{datalad status}} only when \sphinxcode{\sphinxupquote{\sphinxhyphen{}f}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output\sphinxhyphen{}format}} is set to \sphinxcode{\sphinxupquote{json}} or \sphinxcode{\sphinxupquote{json\_pp}}, as illustrated below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{datalad}\PYG{n+nn}{.}\PYG{n+nn}{api} \PYG{k}{as} \PYG{n+nn}{dl}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dl}\PYG{o}{.}\PYG{n}{status}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{myfile}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZob{}\PYGZsq{}type\PYGZsq{}: \PYGZsq{}file\PYGZsq{},}
\PYG{g+go}{\PYGZsq{}gitshasum\PYGZsq{}: \PYGZsq{}915983d6576b56792b4647bf0d9fa04d83ce948d\PYGZsq{},}
\PYG{g+go}{\PYGZsq{}bytesize\PYGZsq{}: 85,}
\PYG{g+go}{\PYGZsq{}prev\PYGZus{}gitshasum\PYGZsq{}: \PYGZsq{}915983d6576b56792b4647bf0d9fa04d83ce948d\PYGZsq{},}
\PYG{g+go}{\PYGZsq{}state\PYGZsq{}: \PYGZsq{}clean\PYGZsq{},}
\PYG{g+go}{\PYGZsq{}path\PYGZsq{}: \PYGZsq{}/home/me/my\PYGZhy{}ds/myfile\PYGZsq{},}
\PYG{g+go}{\PYGZsq{}parentds\PYGZsq{}: \PYGZsq{}/home/me/my\PYGZhy{}ds\PYGZsq{},}
\PYG{g+go}{\PYGZsq{}status\PYGZsq{}: \PYGZsq{}ok\PYGZsq{},}
\PYG{g+go}{\PYGZsq{}refds\PYGZsq{}: \PYGZsq{}/home/me/my\PYGZhy{}ds\PYGZsq{},}
\PYG{g+go}{\PYGZsq{}action\PYGZsq{}: \PYGZsq{}status\PYGZsq{}\PYGZcb{}]}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }\PYGZhy{}f\PYG{+w}{ }json\PYGZus{}pp\PYG{+w}{ }status\PYG{+w}{ }myfile
\PYG{g+go}{ \PYGZob{}\PYGZdq{}action\PYGZdq{}: \PYGZdq{}status\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}bytesize\PYGZdq{}: 85,}
\PYG{g+go}{  \PYGZdq{}gitshasum\PYGZdq{}: \PYGZdq{}915983d6576b56792b4647bf0d9fa04d83ce948d\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}parentds\PYGZdq{}: \PYGZdq{}/home/me/my\PYGZhy{}ds\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}path\PYGZdq{}: \PYGZdq{}/home/me/my\PYGZhy{}ds/myfile\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}prev\PYGZus{}gitshasum\PYGZdq{}: \PYGZdq{}915983d6576b56792b4647bf0d9fa04d83ce948d\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}refds\PYGZdq{}: \PYGZdq{}/home/me/my\PYGZhy{}ds/\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}state\PYGZdq{}: \PYGZdq{}clean\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}status\PYGZdq{}: \PYGZdq{}ok\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}type\PYGZdq{}: \PYGZdq{}file\PYGZdq{}\PYGZcb{}}
\end{sphinxVerbatim}


\end{findoutmore}

\index{use DataLad API@\spxentry{use DataLad API}!with Matlab@\spxentry{with Matlab}}\index{with Matlab@\spxentry{with Matlab}!use DataLad API@\spxentry{use DataLad API}}\index{use DataLad API@\spxentry{use DataLad API}!with R@\spxentry{with R}}\index{with R@\spxentry{with R}!use DataLad API@\spxentry{use DataLad API}}\ignorespaces \begin{importantnote}[label={index-2}, before title={\thetcbcounter\ }, check odd page=true]{Use DataLad in languages other than Python}
\label{\detokenize{basics/101-130-yodaproject:index-2}}

\sphinxAtStartPar
While there is a dedicated API for Python, DataLad’s functions can of course
also be used with other programming languages, such as Matlab, or R, via standard
system calls.

\sphinxAtStartPar
Even if you do not know or like Python, you can just copy\sphinxhyphen{}paste the code
and follow along \textendash{} the high\sphinxhyphen{}level YODA principles demonstrated in this
section generalize across programming languages.


\end{importantnote}

\sphinxAtStartPar
For your midterm project submission, you decide to create a data analysis on the
\sphinxhref{https://en.wikipedia.org/wiki/Iris\_flower\_data\_set}{iris flower data set}.
It is a multivariate dataset on 50 samples of each of three species of Iris
flowers (\sphinxstyleemphasis{Setosa}, \sphinxstyleemphasis{Versicolor}, or \sphinxstyleemphasis{Virginica}), with four variables: the length and width of the sepals and petals
of the flowers in centimeters. It is often used in introductory data science
courses for statistical classification techniques in machine learning, and
widely available \textendash{} a perfect dataset for your midterm project!

\index{reproducible paper@\spxentry{reproducible paper}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!reproducible paper@\spxentry{reproducible paper}}\ignorespaces \begin{importantnote}[label={index-3}, before title={\thetcbcounter\ }, check odd page=true]{Turn data analysis into dynamically generated documents}
\label{\detokenize{basics/101-130-yodaproject:index-3}}

\sphinxAtStartPar
Beyond the contents of this section, we have transformed the example analysis also into a template to write a reproducible paper.
If you are interested in checking that out, please head over to \sphinxhref{https://github.com/datalad-handbook/repro-paper-sketch}{github.com/datalad\sphinxhyphen{}handbook/repro\sphinxhyphen{}paper\sphinxhyphen{}sketch/}.


\end{importantnote}


\subsection{Raw data as a modular, independent entity}
\label{\detokenize{basics/101-130-yodaproject:raw-data-as-a-modular-independent-entity}}
\sphinxAtStartPar
The first YODA principle stressed the importance of modularity in a data analysis
project: Every component that could be used in more than one context should be
an independent component.

\sphinxAtStartPar
The first aspect this applies to is the input data of your dataset: There can
be thousands of ways to analyze it, and it is therefore immensely helpful to
have a pristine raw iris dataset that does not get modified, but serves as
input for these analysis.
As such, the iris data should become a standalone DataLad dataset.
For the purpose of this analysis, the online\sphinxhyphen{}handbook provides an \sphinxcode{\sphinxupquote{iris\_data}}
dataset at \sphinxurl{https://github.com/datalad-handbook/iris\_data}.
You can either use this provided input dataset, or check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-iris}} {\hyperref[\detokenize{basics/101-130-yodaproject:fom-iris}]{\sphinxcrossref{\DUrole{std,std-ref}{on how to create an independent dataset from scratch}}}} (\autopageref*{\detokenize{basics/101-130-yodaproject:fom-iris}}).

\index{create and publish dataset as dependency@\spxentry{create and publish dataset as dependency}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!create and publish dataset as dependency@\spxentry{create and publish dataset as dependency}}\ignorespaces \begin{findoutmore}[label={fom-iris}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Creating an independent input dataset}
\label{\detokenize{basics/101-130-yodaproject:fom-iris}}

\sphinxAtStartPar
If you acquire your own data for a data analysis, you will have
to turn it into a DataLad dataset in order to install it as a subdataset.
Any directory with data that exists on
your computer can be turned into a dataset with \sphinxcode{\sphinxupquote{datalad create \sphinxhyphen{}\sphinxhyphen{}force}}
and a subsequent \sphinxcode{\sphinxupquote{datalad save \sphinxhyphen{}m "add data" .}} to first create a dataset inside of
an existing, non\sphinxhyphen{}empty directory, and subsequently save all of its contents into
the history of the newly created dataset.

\sphinxAtStartPar
To create the \sphinxcode{\sphinxupquote{iris\_data}} dataset at \sphinxurl{https://github.com/datalad-handbook/iris\_data}
we first created a DataLad dataset…

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} make sure to move outside of DataLad\PYGZhy{}101!}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }create\PYG{+w}{ }iris\PYGZus{}data
\PYG{g+go}{create(ok): /home/me/dl\PYGZhy{}101/iris\PYGZus{}data (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
and subsequently got the data from a publicly available
\sphinxhref{https://gist.github.com/netj/8836201}{GitHub Gist}, a code snippet, or other short standalone information with a
\sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}} command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }iris\PYGZus{}data
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }download\PYGZhy{}url\PYG{+w}{ }https://gist.githubusercontent.com/netj/8836201/raw/6f9306ad21398ea43cba4f7d537619d0e07d5ae3/iris.csv
\PYG{g+go}{download\PYGZus{}url(ok): /home/me/dl\PYGZhy{}101/iris\PYGZus{}data/iris.csv (file)}
\PYG{g+go}{add(ok): iris.csv (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, we \sphinxstyleemphasis{published} the dataset  to {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}.

\sphinxAtStartPar
With this setup, the iris dataset (a single comma\sphinxhyphen{}separated (\sphinxcode{\sphinxupquote{.csv}})
file) is downloaded, and, importantly, the dataset recorded \sphinxstyleemphasis{where} it
was obtained from thanks to \sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}}, thus complying
to the second YODA principle.
This way, upon installation of the dataset, DataLad knows where to
obtain the file content from. You can \sphinxcode{\sphinxupquote{datalad clone}} the iris
dataset and find out with a \sphinxcode{\sphinxupquote{git annex whereis iris.csv}} command.


\end{findoutmore}

\sphinxAtStartPar
“Nice, with this input dataset I have sufficient provenance capture for my
input dataset, and I can install it as a modular component”, you think as you
mentally tick off YODA principle number 1 and 2. “But before I can install it,
I need an analysis superdataset first.”


\subsection{Building an analysis dataset}
\label{\detokenize{basics/101-130-yodaproject:building-an-analysis-dataset}}
\sphinxAtStartPar
There is an independent raw dataset as input data, but there is no place
for your analysis to live, yet. Therefore, you start your midterm project
by creating an analysis dataset. As this project is part of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}},
you do it as a subdataset of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}.
Remember to specify the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dataset}} option of \sphinxcode{\sphinxupquote{datalad create}}
to link it as a subdataset!

\sphinxAtStartPar
You naturally want your dataset to follow the YODA principles, and, as a start,
you use the \sphinxcode{\sphinxupquote{cfg\_yoda}} procedure to help you structure the dataset%
\begin{footnote}[1]\sphinxAtStartFootnote
Note that you could have applied the YODA procedure not only right at
creation of the dataset with \sphinxcode{\sphinxupquote{\sphinxhyphen{}c yoda}}, but also after creation
with the \sphinxcode{\sphinxupquote{datalad run\sphinxhyphen{}procedure}} command:

\sphinxSetupCodeBlockInFootnote
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYGZhy{}procedure\PYG{+w}{ }cfg\PYGZus{}yoda
\end{sphinxVerbatim}

\sphinxAtStartPar
Both ways of applying the YODA procedure will lead to the same
outcome.
%
\end{footnote}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} inside of DataLad\PYGZhy{}101}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }create\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }yoda\PYG{+w}{ }\PYGZhy{}\PYGZhy{}dataset\PYG{+w}{ }.\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+go}{[INFO] Running procedure cfg\PYGZus{}yoda}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{run(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/midterm\PYGZus{}project (dataset) [VIRTUALENV/bin/python /home/a...]}
\PYG{g+go}{add(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{create(ok): midterm\PYGZus{}project (dataset)}
\end{sphinxVerbatim}

\index{subdatasets@\spxentry{subdatasets}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!subdatasets@\spxentry{subdatasets}}\index{list subdatasets@\spxentry{list subdatasets}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!list subdatasets@\spxentry{list subdatasets}}\ignorespaces 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{datalad subdatasets}} command can report on which subdatasets exist for
\sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}. This helps you verify that the command succeeded and the
dataset was indeed linked as a subdataset to \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }subdatasets
\PYG{g+go}{subdataset(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{subdataset(ok): recordings/longnow (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Not only the \sphinxcode{\sphinxupquote{longnow}} subdataset, but also the newly created
\sphinxcode{\sphinxupquote{midterm\_project}} subdataset are displayed \textendash{} wonderful!

\sphinxAtStartPar
But back to the midterm project now. So far, you have created a pre\sphinxhyphen{}structured
analysis dataset. As a next step, you take care of installing and linking the
raw dataset for your analysis adequately to your \sphinxcode{\sphinxupquote{midterm\_project}} dataset
by installing it as a subdataset. Make sure to install it as a subdataset of
\sphinxcode{\sphinxupquote{midterm\_project}}, and not \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} we are in midterm\PYGZus{}project, thus \PYGZhy{}d . points to the root of it.}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }clone\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }https://github.com/datalad\PYGZhy{}handbook/iris\PYGZus{}data.git\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }input/
\PYG{g+go}{[INFO] Remote origin not usable by git\PYGZhy{}annex; setting annex\PYGZhy{}ignore}
\PYG{g+go}{install(ok): input (dataset)}
\PYG{g+go}{add(ok): input (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that we did not keep its original name, \sphinxcode{\sphinxupquote{iris\_data}}, but rather provided
a path with a new name, \sphinxcode{\sphinxupquote{input}}, because this much more intuitively comprehensible.

\sphinxAtStartPar
After the input dataset is installed, the directory structure of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}
looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\PYG{g+gp}{\PYGZdl{} }tree\PYG{+w}{ }\PYGZhy{}d
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+go}{.}
\PYG{g+go}{├── books}
\PYG{g+go}{├── code}
\PYG{g+go}{├── midterm\PYGZus{}project}
\PYG{g+go}{│   ├── code}
\PYG{g+go}{│   └── input}
\PYG{g+go}{└── recordings}
\PYG{g+go}{    └── longnow}
\PYG{g+go}{        ├── Long\PYGZus{}Now\PYGZus{}\PYGZus{}Conversations\PYGZus{}at\PYGZus{}The\PYGZus{}Interval}
\PYG{g+go}{        └── Long\PYGZus{}Now\PYGZus{}\PYGZus{}Seminars\PYGZus{}About\PYGZus{}Long\PYGZus{}term\PYGZus{}Thinking}

\PYG{g+go}{9 directories}
\end{sphinxVerbatim}

\sphinxAtStartPar
Importantly, all of the subdatasets are linked to the higher\sphinxhyphen{}level datasets,
and despite being inside of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}, your \sphinxcode{\sphinxupquote{midterm\_project}} is an independent
dataset, as is its \sphinxcode{\sphinxupquote{input/}} subdataset. An overview is shown in \hyperref[\detokenize{basics/101-130-yodaproject:fig-linkeddl101}]{Fig.\@ \ref{\detokenize{basics/101-130-yodaproject:fig-linkeddl101}}}.

\begin{figure}[tbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{virtual_dstree_dl101_midterm}.pdf}
\caption{Overview of (linked) datasets in DataLad\sphinxhyphen{}101.}\label{\detokenize{basics/101-130-yodaproject:id8}}\label{\detokenize{basics/101-130-yodaproject:fig-linkeddl101}}\end{figure}


\subsection{YODA\sphinxhyphen{}compliant analysis scripts}
\label{\detokenize{basics/101-130-yodaproject:yoda-compliant-analysis-scripts}}
\sphinxAtStartPar
Now that you have an \sphinxcode{\sphinxupquote{input/}} directory with data, and a \sphinxcode{\sphinxupquote{code/}} directory
(created by the YODA procedure) for your scripts, it is time to work on the script
for your analysis. Within \sphinxcode{\sphinxupquote{midterm\_project}}, the \sphinxcode{\sphinxupquote{code/}} directory is where
you want to place your scripts.

\sphinxAtStartPar
But first, you plan your research question. You decide to do a
classification analysis with a k\sphinxhyphen{}nearest neighbors algorithm%
\begin{footnote}[2]\sphinxAtStartFootnote
The choice of analysis method
in this book is rather arbitrary, and understanding the k\sphinxhyphen{}nearest
neighbor algorithm is by no means required for this section.
%
\end{footnote}. The iris
dataset works well for such questions. Based on the features of the flowers
(sepal and petal width and length) you will try to predict what type of
flower (\sphinxstyleemphasis{Setosa}, \sphinxstyleemphasis{Versicolor}, or \sphinxstyleemphasis{Virginica}) a particular flower in the
dataset is. You settle on two objectives for your analysis:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Explore and plot the relationship between variables in the dataset and save
the resulting graphic as a first result.

\item {} 
\sphinxAtStartPar
Perform a k\sphinxhyphen{}nearest neighbor classification on a subset of the dataset to
predict class membership (flower type) of samples in a left\sphinxhyphen{}out test set.
Your final result should be a statistical summary of this prediction.

\end{enumerate}

\sphinxAtStartPar
To compute the analysis you create the following Python script inside of \sphinxcode{\sphinxupquote{code/}}:

\fvset{hllines={, 11, 12, 13, 23, 43,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYG{+w}{ }code/script.py

\PYG{g+go}{import argparse}
\PYG{g+go}{import pandas as pd}
\PYG{g+go}{import seaborn as sns}
\PYG{g+go}{from sklearn import model\PYGZus{}selection}
\PYG{g+go}{from sklearn.neighbors import KNeighborsClassifier}
\PYG{g+go}{from sklearn.metrics import classification\PYGZus{}report}

\PYG{g+go}{parser = argparse.ArgumentParser(description=\PYGZdq{}Analyze iris data\PYGZdq{})}
\PYG{g+go}{parser.add\PYGZus{}argument(\PYGZsq{}data\PYGZsq{}, help=\PYGZdq{}Input data (CSV) to process\PYGZdq{})}
\PYG{g+go}{parser.add\PYGZus{}argument(\PYGZsq{}output\PYGZus{}figure\PYGZsq{}, help=\PYGZdq{}Output figure path\PYGZdq{})}
\PYG{g+go}{parser.add\PYGZus{}argument(\PYGZsq{}output\PYGZus{}report\PYGZsq{}, help=\PYGZdq{}Output report path\PYGZdq{})}
\PYG{g+go}{args = parser.parse\PYGZus{}args()}

\PYG{g+gp}{\PYGZsh{} }prepare\PYG{+w}{ }the\PYG{+w}{ }data\PYG{+w}{ }as\PYG{+w}{ }a\PYG{+w}{ }pandas\PYG{+w}{ }dataframe
\PYG{g+go}{df = pd.read\PYGZus{}csv(args.data)}
\PYG{g+go}{attributes = [\PYGZdq{}sepal\PYGZus{}length\PYGZdq{}, \PYGZdq{}sepal\PYGZus{}width\PYGZdq{}, \PYGZdq{}petal\PYGZus{}length\PYGZdq{},\PYGZdq{}petal\PYGZus{}width\PYGZdq{}, \PYGZdq{}class\PYGZdq{}]}
\PYG{g+go}{df.columns = attributes}

\PYG{g+gp}{\PYGZsh{} }create\PYG{+w}{ }a\PYG{+w}{ }pairplot\PYG{+w}{ }to\PYG{+w}{ }plot\PYG{+w}{ }pairwise\PYG{+w}{ }relationships\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }the\PYG{+w}{ }dataset
\PYG{g+go}{plot = sns.pairplot(df, hue=\PYGZsq{}class\PYGZsq{}, palette=\PYGZsq{}muted\PYGZsq{})}
\PYG{g+go}{plot.savefig(args.output\PYGZus{}figure)}

\PYG{g+gp}{\PYGZsh{} }perform\PYG{+w}{ }a\PYG{+w}{ }K\PYGZhy{}nearest\PYGZhy{}neighbours\PYG{+w}{ }classification\PYG{+w}{ }with\PYG{+w}{ }scikit\PYGZhy{}learn
\PYG{g+gp}{\PYGZsh{} }Step\PYG{+w}{ }\PYG{l+m}{1}:\PYG{+w}{ }split\PYG{+w}{ }data\PYG{+w}{ }\PYG{k}{in}\PYG{+w}{ }\PYG{n+nb}{test}\PYG{+w}{ }and\PYG{+w}{ }training\PYG{+w}{ }dataset\PYG{+w}{ }\PYG{o}{(}\PYG{l+m}{20}:80\PYG{o}{)}
\PYG{g+go}{array = df.values}
\PYG{g+go}{X = array[:,0:4]}
\PYG{g+go}{Y = array[:,4]}
\PYG{g+go}{test\PYGZus{}size = 0.20}
\PYG{g+go}{seed = 7}
\PYG{g+go}{X\PYGZus{}train, X\PYGZus{}test, Y\PYGZus{}train, Y\PYGZus{}test = model\PYGZus{}selection.train\PYGZus{}test\PYGZus{}split(}
\PYG{g+go}{    X, Y,}
\PYG{g+go}{    test\PYGZus{}size=test\PYGZus{}size,}
\PYG{g+go}{    random\PYGZus{}state=seed)}
\PYG{g+gp}{\PYGZsh{} }Step\PYG{+w}{ }\PYG{l+m}{2}:\PYG{+w}{ }Fit\PYG{+w}{ }the\PYG{+w}{ }model\PYG{+w}{ }and\PYG{+w}{ }make\PYG{+w}{ }predictions\PYG{+w}{ }on\PYG{+w}{ }the\PYG{+w}{ }\PYG{n+nb}{test}\PYG{+w}{ }dataset
\PYG{g+go}{knn = KNeighborsClassifier()}
\PYG{g+go}{knn.fit(X\PYGZus{}train, Y\PYGZus{}train)}
\PYG{g+go}{predictions = knn.predict(X\PYGZus{}test)}

\PYG{g+gp}{\PYGZsh{} }Step\PYG{+w}{ }\PYG{l+m}{3}:\PYG{+w}{ }Save\PYG{+w}{ }the\PYG{+w}{ }classification\PYG{+w}{ }report
\PYG{g+go}{report = classification\PYGZus{}report(Y\PYGZus{}test, predictions, output\PYGZus{}dict=True)}
\PYG{g+go}{df\PYGZus{}report = pd.DataFrame(report).transpose().to\PYGZus{}csv(args.output\PYGZus{}report)}

\PYG{g+go}{EOT}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
This script will
\begin{itemize}
\item {} 
\sphinxAtStartPar
take three positional arguments: The input data, a path to save a figure under, and path to save the final prediction report under. By including these input and output specifications in a \sphinxcode{\sphinxupquote{datalad run}} command when we run the analysis, we can ensure that input data is retrieved prior to the script execution, and that as much actionable provenance as possible is recorded%
\begin{footnote}[5]\sphinxAtStartFootnote
Alternatively, if you were to use DataLad’s Python API, you could import and expose it as \sphinxcode{\sphinxupquote{dl.\textless{}COMMAND\textgreater{}}} and \sphinxcode{\sphinxupquote{dl.get()}} the relevant files. This however, would not record them as provenance in the dataset’s history.
%
\end{footnote}.

\item {} 
\sphinxAtStartPar
read in the data, perform the analysis, and save the resulting figure and \sphinxcode{\sphinxupquote{.csv}} prediction report into the root of \sphinxcode{\sphinxupquote{midterm\_project/}}. Note how this helps to fulfil YODA principle 1 on modularity:
Results are stored outside of the pristine input subdataset.

\end{itemize}

\sphinxAtStartPar
A short help text explains how the script shall be used:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }python\PYG{+w}{ }code/script.py\PYG{+w}{ }\PYGZhy{}h
\PYG{g+go}{usage: script.py [\PYGZhy{}h] data output\PYGZus{}figure output\PYGZus{}report}

\PYG{g+go}{Analyze iris data}

\PYG{g+go}{positional arguments:}
\PYG{g+go}{   data           Input data (CSV) to process}
\PYG{g+go}{   output\PYGZus{}figure  Output figure path}
\PYG{g+go}{   output\PYGZus{}report  Output report path}

\PYG{g+go}{optional arguments:}
\PYG{g+go}{\PYGZhy{}h, \PYGZhy{}\PYGZhy{}help     show this help message and exit}
\end{sphinxVerbatim}

\sphinxAtStartPar
The script execution would thus be \sphinxcode{\sphinxupquote{python3 code/script.py \textless{}path\sphinxhyphen{}to\sphinxhyphen{}input\textgreater{} \textless{}path\sphinxhyphen{}to\sphinxhyphen{}figure\sphinxhyphen{}output\textgreater{} \textless{}path\sphinxhyphen{}to\sphinxhyphen{}report\sphinxhyphen{}output\textgreater{}}}.
When parametrizing the input and output path parameters, we just need make sure that all paths  are \sphinxstyleemphasis{relative}, such that the \sphinxcode{\sphinxupquote{midterm\_project}} analysis is completely self\sphinxhyphen{}contained within the dataset, contributing to fulfill the second YODA principle.

\sphinxAtStartPar
Let’s run a quick \sphinxcode{\sphinxupquote{datalad status}}…

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: code/script.py (file)}
\end{sphinxVerbatim}

\index{tag dataset version@\spxentry{tag dataset version}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!tag dataset version@\spxentry{tag dataset version}}\ignorespaces 
\sphinxAtStartPar
… and save the script to the subdataset’s history. As the script completes your
analysis setup, we \sphinxstyleemphasis{tag} the state of the dataset to refer to it easily at a later
point with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}version\sphinxhyphen{}tag}} option of \sphinxcode{\sphinxupquote{datalad save}}. Check the
\textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-what-is-a-tag}} {\hyperref[\detokenize{basics/101-130-yodaproject:fom-what-is-a-tag}]{\sphinxcrossref{\DUrole{std,std-ref}{on tags}}}} (\autopageref*{\detokenize{basics/101-130-yodaproject:fom-what-is-a-tag}}) for details.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add script for kNN classification and plotting\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}version\PYGZhy{}tag\PYG{+w}{ }ready4analysis\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }code/script.py
\PYG{g+go}{add(ok): code/script.py (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\index{tag@\spxentry{tag}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!tag@\spxentry{tag}}\index{show@\spxentry{show}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!show@\spxentry{show}}\index{rerun command@\spxentry{rerun command}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!rerun command@\spxentry{rerun command}}\ignorespaces \begin{findoutmore}[label={fom-what-is-a-tag}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{What is a tag?}
\label{\detokenize{basics/101-130-yodaproject:fom-what-is-a-tag}}

\sphinxAtStartPar
{\hyperref[\detokenize{glossary:term-tag}]{\sphinxtermref{\DUrole{xref,std,std-term}{tag}}}}s are markers that you can attach to commits in your dataset history.
They can have any name, and can help you and others to identify certain commits
or dataset states in the history of a dataset. Let’s take a look at how the tag
you just created looks like in your history with \sphinxcode{\sphinxupquote{git show}}.
Note how we can use a tag just as easily as a commit {\hyperref[\detokenize{glossary:term-shasum}]{\sphinxtermref{\DUrole{xref,std,std-term}{shasum}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }show\PYG{+w}{ }ready4analysis
\PYG{g+go}{commit ca0c7477✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    add script for kNN classification and plotting}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/code/script.py b/code/script.py}
\PYG{g+go}{new file mode 100644}
\PYG{g+go}{index 0000000..c7a6ea9}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/code/script.py}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1,43 @@}
\end{sphinxVerbatim}

\sphinxAtStartPar
This tag thus identifies the version state of the dataset in which this script
was added.
Later we can use this tag to identify the point in time at which
the analysis setup was ready \textendash{} much more intuitive than a 40\sphinxhyphen{}character shasum!
This is handy in the context of a \sphinxcode{\sphinxupquote{datalad rerun}}, for example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }rerun\PYG{+w}{ }\PYGZhy{}\PYGZhy{}since\PYG{+w}{ }ready4analysis
\end{sphinxVerbatim}

\sphinxAtStartPar
would rerun any \sphinxcode{\sphinxupquote{datalad run}} command in the history performed between tagging
and the current dataset state.


\end{findoutmore}

\sphinxAtStartPar
Finally, with your directory structure being modular and intuitive,
the input data installed, the script ready, and the dataset status clean,
you can wrap the execution of the script in a \sphinxcode{\sphinxupquote{datalad run}} command. Note that
simply executing the script would work as well \textendash{} thanks to DataLad’s Python API.
But using \sphinxcode{\sphinxupquote{datalad run}} will capture full provenance, and will make
re\sphinxhyphen{}execution with \sphinxcode{\sphinxupquote{datalad rerun}} easy.
In case you run into trouble, check the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-python-not-3}} {\hyperref[\detokenize{basics/101-130-yodaproject:ww-python-not-3}]{\sphinxcrossref{\DUrole{std,std-ref}{on different Python command names}}}} (\autopageref*{\detokenize{basics/101-130-yodaproject:ww-python-not-3}}).
\begin{importantnote}[before title={\thetcbcounter\ }, check odd page=true]{Additional software requirements: pandas, seaborn, sklearn}

\sphinxAtStartPar
Note that you need to have the following Python packages installed to run the
analysis%
\begin{footnote}[3]\sphinxAtStartFootnote
It is recommended (but optional) to create a
\sphinxhref{https://docs.python.org/3/tutorial/venv.html}{virtual environment} and
install the required Python packages inside of it:

\sphinxSetupCodeBlockInFootnote
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} create and enter a new virtual environment (optional)}
\PYG{g+gp}{\PYGZdl{} }virtualenv\PYG{+w}{ }\PYGZhy{}\PYGZhy{}python\PYG{o}{=}python3\PYG{+w}{ }\PYGZti{}/env/handbook
\PYG{g+gp}{\PYGZdl{} }.\PYG{+w}{ }\PYGZti{}/env/handbook/bin/activate
\end{sphinxVerbatim}

\sphinxSetupCodeBlockInFootnote
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} install the Python packages from PyPi via pip}
\PYG{g+gp}{\PYGZdl{} }pip\PYG{+w}{ }install\PYG{+w}{ }seaborn\PYG{+w}{ }pandas\PYG{+w}{ }sklearn
\end{sphinxVerbatim}
%
\end{footnote}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://pandas.pydata.org}{pandas}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://seaborn.pydata.org}{seaborn}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://scikit-learn.org}{sklearn}

\end{itemize}

\sphinxAtStartPar
The packages can be installed via {\hyperref[\detokenize{glossary:term-pip}]{\sphinxtermref{\DUrole{xref,std,std-term}{pip}}}}.
However, if you do not want to install any
Python packages, do not execute the remaining code examples in this section
\textendash{} an upcoming section on \sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}run}} will allow you to
perform the analysis without changing your Python software\sphinxhyphen{}setup.


\end{importantnote}

\index{python instead of python3@\spxentry{python instead of python3}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!python instead of python3@\spxentry{python instead of python3}}\ignorespaces \begin{windowswit}[label={ww-python-not-3}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{You may need to use ‘python’, not ‘python3’}
\label{\detokenize{basics/101-130-yodaproject:ww-python-not-3}}

\sphinxAtStartPar
If executing the code below returns an exit code of 9009, there may be no \sphinxcode{\sphinxupquote{python3}} \textendash{} instead, it is called just \sphinxcode{\sphinxupquote{python}}.
Please run the following instead (adjusted for line breaks, you should be able to copy\sphinxhyphen{}paste this as a whole):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{} datalad run \PYGZhy{}m \PYGZdq{}analyze iris data with classification analysis\PYGZdq{} \PYGZca{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}input \PYGZdq{}input/iris.csv\PYGZdq{} \PYGZca{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}output \PYGZdq{}pairwise\PYGZus{}relationships.png\PYGZdq{} \PYGZca{}}
\PYG{g+go}{ \PYGZhy{}\PYGZhy{}output \PYGZdq{}prediction\PYGZus{}report.csv\PYGZdq{} \PYGZca{}}
\PYG{g+go}{ \PYGZdq{}python code/script.py \PYGZob{}inputs\PYGZcb{} \PYGZob{}outputs\PYGZcb{}\PYGZdq{}}
\end{sphinxVerbatim}


\end{windowswit}

\index{run command with provenance capture@\spxentry{run command with provenance capture}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!run command with provenance capture@\spxentry{run command with provenance capture}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-130-yodaproject:index-9}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}analyze iris data with classification analysis\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}input/iris.csv\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}pairwise\PYGZus{}relationships.png\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}prediction\PYGZus{}report.csv\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYG{l+s+s2}{\PYGZdq{}python3 code/script.py \PYGZob{}inputs\PYGZcb{} \PYGZob{}outputs\PYGZcb{}\PYGZdq{}}
\PYG{g+go}{get(ok): input/iris.csv (file) [from web...]}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{run(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/midterm\PYGZus{}project (dataset) [python3 code/script.py input/iris.csv pa...]}
\PYG{g+go}{add(ok): pairwise\PYGZus{}relationships.png (file)}
\PYG{g+go}{add(ok): prediction\PYGZus{}report.csv (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
As the successful command summary indicates, your analysis seems to work! Two
files were created and saved to the dataset: \sphinxcode{\sphinxupquote{pairwise\_relationships.png}}
and \sphinxcode{\sphinxupquote{prediction\_report.csv}}. If you want, take a look and interpret
your analysis. But what excites you even more than a successful data science
project on first try is that you achieved complete provenance capture:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Every single file in this dataset is associated with an author and a time
stamp for each modification thanks to \sphinxcode{\sphinxupquote{datalad save}}.

\item {} 
\sphinxAtStartPar
The raw dataset knows where the data came from thanks to \sphinxcode{\sphinxupquote{datalad clone}}
and \sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}}.

\item {} 
\sphinxAtStartPar
The subdataset is linked to the superdataset thanks to
\sphinxcode{\sphinxupquote{datalad clone \sphinxhyphen{}d}}.

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{datalad run}} command took care of linking the outputs of your
analysis with the script and the input data it was generated from, fulfilling
the third YODA principle.

\end{itemize}

\sphinxAtStartPar
Let’s take a look at the history of the \sphinxcode{\sphinxupquote{midterm\_project}} analysis
dataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{9aadac7 [DATALAD RUNCMD] analyze iris data with classification analysis}
\PYG{g+go}{ca0c747 add script for kNN classification and plotting}
\PYG{g+go}{4f945ed [DATALAD] Added subdataset}
\PYG{g+go}{18f4a98 Apply YODA dataset setup}
\PYG{g+go}{bf231d5 [DATALAD] new dataset}
\end{sphinxVerbatim}

\sphinxAtStartPar
“Wow, this is so clean and intuitive!” you congratulate yourself. “And I think
this was and will be the fastest I have ever completed a midterm project!”
But what is still missing is a human readable description of your dataset.
The YODA procedure kindly placed a \sphinxcode{\sphinxupquote{README.md}} file into the root of your
dataset that you can use for this%
\begin{footnote}[4]\sphinxAtStartFootnote
All \sphinxcode{\sphinxupquote{README.md}} files the YODA procedure created are
version controlled by Git, not git\sphinxhyphen{}annex, thanks to the
configurations that YODA supplied. This makes it easy to change the
\sphinxcode{\sphinxupquote{README.md}} file. The previous section detailed how the YODA procedure
configured your dataset. If you want to re\sphinxhyphen{}read the full chapter on
configurations and run\sphinxhyphen{}procedures, start with section {\hyperref[\detokenize{basics/101-122-config:config}]{\sphinxcrossref{\DUrole{std,std-ref}{Local configuration}}}} (\autopageref*{\detokenize{basics/101-122-config:config}}).
%
\end{footnote}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} with the \PYGZgt{}| redirection we are replacing existing contents in the file}
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYG{l+s}{\PYGZlt{}\PYGZlt{} EOT \PYGZgt{}| RE}ADME.md

\PYG{g+gp}{\PYGZsh{} }Midterm\PYG{+w}{ }YODA\PYG{+w}{ }Data\PYG{+w}{ }Analysis\PYG{+w}{ }Project

\PYG{g+gp}{\PYGZsh{}}\PYG{c+c1}{\PYGZsh{} Dataset structure}

\PYG{g+go}{\PYGZhy{} All inputs (i.e. building blocks from other sources) are located in input/.}
\PYG{g+go}{\PYGZhy{} All custom code is located in code/.}
\PYG{g+go}{\PYGZhy{} All results (i.e., generated files) are located in the root of the dataset:}
\PYG{g+go}{  \PYGZhy{} \PYGZdq{}prediction\PYGZus{}report.csv\PYGZdq{} contains the main classification metrics.}
\PYG{g+go}{  \PYGZhy{} \PYGZdq{}output/pairwise\PYGZus{}relationships.png\PYGZdq{} is a plot of the relations between features.}

\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{ modified: README.md (file)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Provide project description\PYGZdq{}}\PYG{+w}{ }README.md
\PYG{g+go}{add(ok): README.md (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that one feature of the YODA procedure was that it configured certain files
(for example, everything inside of \sphinxcode{\sphinxupquote{code/}}, and the \sphinxcode{\sphinxupquote{README.md}} file in the
root of the dataset) to be saved in Git instead of git\sphinxhyphen{}annex. This was the
reason why the \sphinxcode{\sphinxupquote{README.md}} in the root of the dataset was easily modifiable.
See the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-save-to-git}} {\hyperref[\detokenize{basics/101-130-yodaproject:fom-save-to-git}]{\sphinxcrossref{\DUrole{std,std-ref}{on an alternative approach}}}} (\autopageref*{\detokenize{basics/101-130-yodaproject:fom-save-to-git}}) that can achieve the same result.

\index{save@\spxentry{save}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!save@\spxentry{save}}\index{save file content directly in Git (no annex)@\spxentry{save file content directly in Git}\spxextra{no annex}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!save file content directly in Git (no annex)@\spxentry{save file content directly in Git}\spxextra{no annex}}\ignorespaces \begin{findoutmore}[label={fom-save-to-git}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Saving contents to Git regardless of configuration}
\label{\detokenize{basics/101-130-yodaproject:fom-save-to-git}}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{yoda}} procedure in \sphinxcode{\sphinxupquote{midterm\_project}} applied a different configuration
within \sphinxcode{\sphinxupquote{.gitattributes}} than the \sphinxcode{\sphinxupquote{text2git}} procedure did in \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}.
Within \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}, any text file is automatically stored in {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}}.
This is not true in \sphinxcode{\sphinxupquote{midterm\_project}}: Only the existing \sphinxcode{\sphinxupquote{README.md}} files and
anything within \sphinxcode{\sphinxupquote{code/}} are stored \textendash{} everything else will be annexed.
That means that if you create any other file, even text files, inside of
\sphinxcode{\sphinxupquote{midterm\_project}} (but not in \sphinxcode{\sphinxupquote{code/}}), it will be managed by {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}
and content\sphinxhyphen{}locked after a \sphinxcode{\sphinxupquote{datalad save}} \textendash{} an inconvenience if it
would be a file that is small enough to be handled by Git.

\sphinxAtStartPar
Luckily, there is a handy shortcut to saving files in Git that does not
require you to edit configurations in \sphinxcode{\sphinxupquote{.gitattributes}}: The \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}to\sphinxhyphen{}git}}
option for \sphinxcode{\sphinxupquote{datalad save}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add sometextfile.txt\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}to\PYGZhy{}git\PYG{+w}{ }sometextfile.txt
\end{sphinxVerbatim}


\end{findoutmore}

\sphinxAtStartPar
After adding this short description to your \sphinxcode{\sphinxupquote{README.md}}, your dataset now also
contains sufficient human\sphinxhyphen{}readable information to ensure that others can understand
everything you did easily.
The only thing left to do is to hand in your assignment. According to the
syllabus, this should be done via {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}. Check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-github}} {\hyperref[\detokenize{basics/101-130-yodaproject:fom-github}]{\sphinxcrossref{\DUrole{std,std-ref}{on this platform}}}} (\autopageref*{\detokenize{basics/101-130-yodaproject:fom-github}}), if you are not familiar with it yet.

\index{dataset hosting@\spxentry{dataset hosting}!GitHub@\spxentry{GitHub}}\ignorespaces \begin{findoutmore}[label={fom-github}, before title={\thetcbcounter\ }, float, floatplacement=p, check odd page=true]{What is GitHub?}
\label{\detokenize{basics/101-130-yodaproject:fom-github}}

\sphinxAtStartPar
GitHub is a web based hosting service for Git repositories. Among many
different other useful perks it adds features that allow collaboration on
Git repositories. \sphinxhref{https://about.gitlab.com}{GitLab} is a similar
service with highly similar features, but its source code is free and open,
whereas GitHub is a subsidiary of Microsoft.

\sphinxAtStartPar
Web\sphinxhyphen{}hosting services like GitHub and {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}} integrate wonderfully with
DataLad. They are especially useful for making your dataset publicly available,
if you have figured out storage for your large files otherwise (as large content
cannot be hosted for free by GitHub). You can make DataLad publish large file content to one location
and afterwards automatically push an update to GitHub, such that
users can install directly from GitHub/GitLab and seemingly also obtain large file
content from GitHub. GitHub can also resolve subdataset links to other GitHub
repositories, which lets you navigate through nested datasets in the web\sphinxhyphen{}interface.

\noindent{\hspace*{\fill}\sphinxincludegraphics{{screenshot_midtermproject}.png}\hspace*{\fill}}

\sphinxAtStartPar
The above screenshot shows the linkage between the analysis project you will create
and its subdataset. Clicking on the subdataset (highlighted) will take you to the iris dataset
the online\sphinxhyphen{}handbook provides, shown below.

\noindent{\hspace*{\fill}\sphinxincludegraphics{{screenshot_submodule}.png}\hspace*{\fill}}


\end{findoutmore}

\index{create\sphinxhyphen{}sibling\sphinxhyphen{}github@\spxentry{create\sphinxhyphen{}sibling\sphinxhyphen{}github}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!create\sphinxhyphen{}sibling\sphinxhyphen{}github@\spxentry{create\sphinxhyphen{}sibling\sphinxhyphen{}github}}\ignorespaces 

\subsection{Publishing the dataset to GitHub}
\label{\detokenize{basics/101-130-yodaproject:publishing-the-dataset-to-github}}\label{\detokenize{basics/101-130-yodaproject:publishtogithub}}\label{\detokenize{basics/101-130-yodaproject:index-12}}
\sphinxAtStartPar
For this, you need to
\begin{itemize}
\item {} 
\sphinxAtStartPar
create a GitHub account, if you do not yet have one

\item {} 
\sphinxAtStartPar
create a repository for this dataset on GitHub,

\item {} 
\sphinxAtStartPar
configure this GitHub repository to be a {\hyperref[\detokenize{glossary:term-sibling}]{\sphinxtermref{\DUrole{xref,std,std-term}{sibling}}}} of the \sphinxcode{\sphinxupquote{midterm\_project}} dataset,

\item {} 
\sphinxAtStartPar
and \sphinxstyleemphasis{publish} your dataset to GitHub.

\end{itemize}

\index{create\sphinxhyphen{}sibling\sphinxhyphen{}gitlab@\spxentry{create\sphinxhyphen{}sibling\sphinxhyphen{}gitlab}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!create\sphinxhyphen{}sibling\sphinxhyphen{}gitlab@\spxentry{create\sphinxhyphen{}sibling\sphinxhyphen{}gitlab}}\ignorespaces 
\sphinxAtStartPar
Luckily, DataLad can make this very easy with the
\sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}github}}
command (or, for \sphinxhref{https://about.gitlab.com}{GitLab}, \sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}gitlab}}).

\sphinxAtStartPar
The two commands have different arguments and options.
Here, we look at \sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}github}}.
The command takes a repository name and GitHub authentication credentials
(either in the command line call with options \sphinxcode{\sphinxupquote{github\sphinxhyphen{}login \textless{}TOKEN\textgreater{}}}, with an \sphinxstyleemphasis{oauth} \sphinxhref{https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens}{token} stored in the Git
configuration, or interactively).

\index{GitHub token@\spxentry{GitHub token}!credential@\spxentry{credential}}\index{credential@\spxentry{credential}!GitHub token@\spxentry{GitHub token}}\ignorespaces \begin{importantnote}[label={index-14}, before title={\thetcbcounter\ }, check odd page=true]{Generate a GitHub token}
\label{\detokenize{basics/101-130-yodaproject:index-14}}

\sphinxAtStartPar
GitHub \sphinxhref{https://developer.github.com/changes/2020-02-14-deprecating-password-auth}{deprecated user\sphinxhyphen{}password authentication} and instead supports authentication via personal access token.
To ensure successful authentication, don’t supply your password, but create a personal access token at \sphinxhref{https://github.com/settings/tokens}{github.com/settings/tokens}%
\begin{footnote}[6]\sphinxAtStartFootnote
Instead of using GitHub’s WebUI you could also obtain a token using the command line GitHub interface (\sphinxurl{https://github.com/sociomantic-tsunami/git-hub}) by running \sphinxcode{\sphinxupquote{git hub setup}} (if no 2FA is used).
%
\end{footnote} instead, and either
\begin{itemize}
\item {} 
\sphinxAtStartPar
supply the token with the argument \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}github\sphinxhyphen{}login \textless{}TOKEN\textgreater{}}} from the command line,

\item {} 
\sphinxAtStartPar
or supply the token from the command line when queried for a password

\end{itemize}


\end{importantnote}

\sphinxAtStartPar
Based on the credentials and the
repository name, it will create a new, empty repository on GitHub, and
configure this repository as a sibling of the dataset.
If you are asked to enter a credential, and things feel weird, check
the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-ghost-credentials}} {\hyperref[\detokenize{basics/101-130-yodaproject:ww-ghost-credentials}]{\sphinxcrossref{\DUrole{std,std-ref}{on typing passwords}}}} (\autopageref*{\detokenize{basics/101-130-yodaproject:ww-ghost-credentials}}).

\index{credential@\spxentry{credential}!entry@\spxentry{entry}}\index{typed credentials are not displayed@\spxentry{typed credentials are not displayed}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!typed credentials are not displayed@\spxentry{typed credentials are not displayed}}\ignorespaces \begin{windowswit}[label={ww-ghost-credentials}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Your shell will not display credentials}
\label{\detokenize{basics/101-130-yodaproject:ww-ghost-credentials}}

\sphinxAtStartPar
Don’t be confused if you are prompted for your GitHub credentials, but can’t seem to type \textendash{} the terminal protects your private information by not displaying what you type.
Simply type in what is requested, and press enter.


\end{windowswit}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }create\PYGZhy{}sibling\PYGZhy{}github\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }midtermproject
\PYG{g+go}{.: github(\PYGZhy{}) [https://github.com/adswa/midtermproject.git (git)]}
\PYG{g+go}{\PYGZsq{}https://github.com/adswa/midtermproject.git\PYGZsq{} configured as sibling \PYGZsq{}github\PYGZsq{} for \PYGZlt{}Dataset path=/home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/midterm\PYGZus{}project\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Verify that this worked by listing the siblings of the dataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }siblings
\PYG{g+go}{[WARNING] Failed to determine if github carries annex.}
\PYG{g+go}{.: here(+) [git]}
\PYG{g+go}{.: github(\PYGZhy{}) [https://github.com/adswa/midtermproject.git (git)]}
\end{sphinxVerbatim}

\index{sibling (GitHub)@\spxentry{sibling}\spxextra{GitHub}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!sibling (GitHub)@\spxentry{sibling}\spxextra{GitHub}}\ignorespaces \begin{gitusernote}[label={index-16}, before title={\thetcbcounter\ }, check odd page=true]{Create-sibling-github internals}
\label{\detokenize{basics/101-130-yodaproject:index-16}}

\sphinxAtStartPar
Creating a sibling on GitHub will create a new empty repository under the
account that you provide and set up a \sphinxstyleemphasis{remote} to this repository. Upon a
\sphinxcode{\sphinxupquote{datalad push}} to this sibling, your datasets history
will be pushed there.


\end{gitusernote}

\index{push@\spxentry{push}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!push@\spxentry{push}}\index{push (dataset)@\spxentry{push}\spxextra{dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!push (dataset)@\spxentry{push}\spxextra{dataset}}\ignorespaces 
\sphinxAtStartPar
On GitHub, you will see a new, empty repository with the name
\sphinxcode{\sphinxupquote{midtermproject}}. However, the repository does not yet contain
any of your dataset’s history or files. This requires \sphinxstyleemphasis{publishing} the current
state of the dataset to this {\hyperref[\detokenize{glossary:term-sibling}]{\sphinxtermref{\DUrole{xref,std,std-term}{sibling}}}} with the \sphinxcode{\sphinxupquote{datalad push}}
command.
\begin{importantnote}[before title={\thetcbcounter\ }, check odd page=true]{Learn how to push “on the job”}

\sphinxAtStartPar
Publishing is one of the remaining big concepts that this book tries to
convey. However, publishing is a complex concept that encompasses a large
proportion of this book’s content so far as a prerequisite. In order to be
not too overwhelmingly detailed, the upcoming sections will approach
\sphinxcode{\sphinxupquote{datalad push}} from a “learning\sphinxhyphen{}by\sphinxhyphen{}doing” perspective:
First, you will see a \sphinxcode{\sphinxupquote{datalad push}} to GitHub, and “On the looks and feels of a published dataset”
will already give a practical glimpse into the
difference between annexed contents and contents stored in Git when pushed
to GitHub. The chapter {\hyperref[\detokenize{basics/basics-thirdparty:chapter-thirdparty}]{\sphinxcrossref{\DUrole{std,std-ref}{Distributing datasets}}}} (\autopageref*{\detokenize{basics/basics-thirdparty:chapter-thirdparty}}) will extend on this,
but the section {\hyperref[\detokenize{basics/101-141-push:push}]{\sphinxcrossref{\DUrole{std,std-ref}{The datalad push command}}}} (\autopageref*{\detokenize{basics/101-141-push:push}})
will finally combine and link all the previous contents to give a comprehensive
and detailed wrap up of the concept of publishing datasets. In this section,
you will also find a detailed overview on how \sphinxcode{\sphinxupquote{datalad push}} works and which
options are available. If you are impatient or need an overview on publishing,
feel free to skip ahead. If you have time to follow along, reading the next
sections will get you towards a complete picture of publishing a bit more
small\sphinxhyphen{}stepped and gently.
For now, we will start with learning by doing, and
the fundamental basics of \sphinxcode{\sphinxupquote{datalad push}}: The command
will make the last saved state of your dataset available (i.e., publish it)
to the {\hyperref[\detokenize{glossary:term-sibling}]{\sphinxtermref{\DUrole{xref,std,std-term}{sibling}}}} you provide with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}to}} option.


\end{importantnote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }push\PYG{+w}{ }\PYGZhy{}\PYGZhy{}to\PYG{+w}{ }github
\PYG{g+go}{copy(ok): pairwise\PYGZus{}relationships.png (file) [to github...]}
\PYG{g+go}{copy(ok): prediction\PYGZus{}report.csv (file) [to github...]}
\PYG{g+go}{publish(ok): . (dataset) [refs/heads/git\PYGZhy{}annex\PYGZhy{}\PYGZgt{}github:refs/heads/git\PYGZhy{}annex ✂FROM✂..✂TO✂]}
\PYG{g+go}{publish(ok): . (dataset) [refs/heads/main\PYGZhy{}\PYGZgt{}github:refs/heads/main [new branch]]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Thus, you have now published your dataset’s history to a public place for others
to see and clone. Now we will explore how this may look and feel for others.
\begin{gitusernote}[before title={\thetcbcounter\ }, check odd page=true]{Push internals}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{datalad push}} uses \sphinxcode{\sphinxupquote{git push}}, and \sphinxcode{\sphinxupquote{git annex copy}} under
the hood. Publication targets need to either be configured remote Git repositories,
or git\sphinxhyphen{}annex special remotes (if they support data upload).


\end{gitusernote}

\sphinxAtStartPar
There is one important detail first, though: By default, your tags will not be published.
Thus, the tag \sphinxcode{\sphinxupquote{ready4analysis}} is not pushed to GitHub, and currently this
version identifier is unavailable to anyone else but you.
The reason for this is that tags are viral \textendash{} they can be removed locally, and old
published tags can cause confusion or unwanted changes. In order to publish a tag,
an additional \sphinxcode{\sphinxupquote{git push}}  with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}tags}} option is required:

\index{push@\spxentry{push}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!push@\spxentry{push}}\index{push (tag)@\spxentry{push}\spxextra{tag}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!push (tag)@\spxentry{push}\spxextra{tag}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-130-yodaproject:index-18}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }push\PYG{+w}{ }github\PYG{+w}{ }\PYGZhy{}\PYGZhy{}tags
\end{sphinxVerbatim}

\index{push (tag)@\spxentry{push}\spxextra{tag}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!push (tag)@\spxentry{push}\spxextra{tag}}\ignorespaces \begin{gitusernote}[label={index-19}, before title={\thetcbcounter\ }, check odd page=true]{Pushing tags}
\label{\detokenize{basics/101-130-yodaproject:index-19}}

\sphinxAtStartPar
Note that this is a \sphinxcode{\sphinxupquote{git push}}, not \sphinxcode{\sphinxupquote{datalad push}}.
Tags could be pushed upon a \sphinxcode{\sphinxupquote{datalad push}}, though, if one
configures (what kind of) tags to be pushed. This would need to be done
on a per\sphinxhyphen{}sibling basis in \sphinxcode{\sphinxupquote{.git/config}} in the \sphinxcode{\sphinxupquote{remote.*.push}}
configuration. If you had a {\hyperref[\detokenize{glossary:term-sibling}]{\sphinxtermref{\DUrole{xref,std,std-term}{sibling}}}} “github”, the following
configuration would push all tags that start with a \sphinxcode{\sphinxupquote{v}} upon a
\sphinxcode{\sphinxupquote{datalad push \sphinxhyphen{}\sphinxhyphen{}to github}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}\PYGZhy{}local\PYG{+w}{ }remote.github.push\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}refs/tags/v*\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This configuration would result in the following entry in \sphinxcode{\sphinxupquote{.git/config}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{[remote \PYGZdq{}github\PYGZdq{}]}
\PYG{+w}{      }\PYG{n+na}{url}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{git@github.com/adswa/midtermproject.git}
\PYG{+w}{      }\PYG{n+na}{fetch}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{+refs/heads/*:refs/remotes/github/*}
\PYG{+w}{      }\PYG{n+na}{annex\PYGZhy{}ignore}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{true}
\PYG{+w}{      }\PYG{n+na}{push}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{refs/tags/v*}
\end{sphinxVerbatim}


\end{gitusernote}

\sphinxAtStartPar
Yay! Consider your midterm project submitted! Others can now install your
dataset and check out your data science project \textendash{} and even better: they can
reproduce your data science project easily from scratch!

\index{work on published YODA dataset@\spxentry{work on published YODA dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!work on published YODA dataset@\spxentry{work on published YODA dataset}}\index{rerun command@\spxentry{rerun command}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!rerun command@\spxentry{rerun command}}\ignorespaces 

\subsection{On the looks and feels of a published dataset}
\label{\detokenize{basics/101-130-yodaproject:on-the-looks-and-feels-of-a-published-dataset}}\label{\detokenize{basics/101-130-yodaproject:index-20}}
\sphinxAtStartPar
Now that you have created and published such a YODA\sphinxhyphen{}compliant dataset, you
are understandably excited how this dataset must look and feel for others.
Therefore, you decide to install this dataset into a new location on your
computer, just to get a feel for it.

\sphinxAtStartPar
Replace the \sphinxcode{\sphinxupquote{url}} in the \sphinxcode{\sphinxupquote{datalad clone}} command with the path
to your own \sphinxcode{\sphinxupquote{midtermproject}} GitHub repository, or clone the “public”
\sphinxcode{\sphinxupquote{midterm\_project}} repository that is available via the online\sphinxhyphen{}handbook’s GitHub
organization at \sphinxhref{https://github.com/datalad-handbook/midterm\_project}{github.com/datalad\sphinxhyphen{}handbook/midterm\_project}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../../
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }clone\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}https://github.com/adswa/midtermproject.git\PYGZdq{}}
\PYG{g+go}{[INFO] Remote origin not usable by git\PYGZhy{}annex; setting annex\PYGZhy{}ignore}
\PYG{g+go}{install(ok): /home/me/dl\PYGZhy{}101/midtermproject (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s start with the subdataset, and see whether we can retrieve the
input \sphinxcode{\sphinxupquote{iris.csv}} file. This should not be a problem, since its origin
is recorded:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }midtermproject
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }input/iris.csv
\PYG{g+go}{[INFO] Remote origin not usable by git\PYGZhy{}annex; setting annex\PYGZhy{}ignore}
\PYG{g+go}{install(ok): /home/me/dl\PYGZhy{}101/midtermproject/input (dataset) [Installed subdataset in order to get /home/me/dl\PYGZhy{}101/midtermproject/input/iris.csv]}
\PYG{g+go}{get(ok): input/iris.csv (file) [from web...]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Nice, this worked well. The output files, however, cannot be easily
retrieved:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }prediction\PYGZus{}report.csv\PYG{+w}{ }pairwise\PYGZus{}relationships.png
\PYG{g+go}{get(error): pairwise\PYGZus{}relationships.png (file) [not available; (Note that these git remotes have annex\PYGZhy{}ignore set: origin)]}
\PYG{g+go}{get(error): prediction\PYGZus{}report.csv (file) [not available; (Note that these git remotes have annex\PYGZhy{}ignore set: origin)]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Why is that? This is the first detail of publishing datasets we will dive into.
When publishing dataset content to GitHub with \sphinxcode{\sphinxupquote{datalad push}}, it is
the dataset’s \sphinxstyleemphasis{history}, i.e., everything that is stored in Git, that is
published. The file \sphinxstyleemphasis{content} of these particular files, though, is managed
by {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} and not stored in Git, and
thus only information about the file name and location is known to Git.
Because GitHub does not host large data for free, annexed file content always
needs to be deposited somewhere else (e.g., a web server) to make it
accessible via \sphinxcode{\sphinxupquote{datalad get}}. The chapter {\hyperref[\detokenize{basics/basics-thirdparty:chapter-thirdparty}]{\sphinxcrossref{\DUrole{std,std-ref}{Distributing datasets}}}} (\autopageref*{\detokenize{basics/basics-thirdparty:chapter-thirdparty}})
will demonstrate how this can be done. For this dataset, it is not
necessary to make the outputs available, though: Because all provenance
on their creation was captured, we can simply recompute them with the
\sphinxcode{\sphinxupquote{datalad rerun}} command. If the tag was published we can simply
rerun any \sphinxcode{\sphinxupquote{datalad run}} command since this tag:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }rerun\PYG{+w}{ }\PYGZhy{}\PYGZhy{}since\PYG{+w}{ }ready4analysis
\end{sphinxVerbatim}

\sphinxAtStartPar
But without the published tag, we can rerun the analysis by specifying its
shasum:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }rerun\PYG{+w}{ }d715890b✂SHA1
\PYG{g+go}{[INFO] run commit d715890; (analyze iris data...)}
\PYG{g+go}{run.remove(ok): pairwise\PYGZus{}relationships.png (file) [Removed file]}
\PYG{g+go}{run.remove(ok): prediction\PYGZus{}report.csv (file) [Removed file]}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{action summary:}
\PYG{g+go}{  get (notneeded: 2)}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{run(ok): /home/me/dl\PYGZhy{}101/midtermproject (dataset) [python3 code/script.py]}
\PYG{g+go}{add(ok): pairwise\PYGZus{}relationships.png (file)}
\PYG{g+go}{add(ok): prediction\PYGZus{}report.csv (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{action summary:}
\PYG{g+go}{  add (ok: 2)}
\PYG{g+go}{  get (notneeded: 3)}
\PYG{g+go}{  run (ok: 1)}
\PYG{g+go}{  run.remove (ok: 2)}
\PYG{g+go}{  save (notneeded: 1, ok: 1)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Hooray, your analysis was reproduced! You happily note that rerunning your
analysis was incredibly easy \textendash{} it would not even be necessary to have any
knowledge about the analysis at all to reproduce it!
With this, you realize again how letting DataLad take care of linking input,
output, and code can make your life and others’ lives so much easier.
Applying the YODA principles to your data analysis was very beneficial indeed.
Proud of your midterm project you cannot wait to use those principles the
next time again.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{reproduced}.pdf}\hspace*{\fill}}

\index{push@\spxentry{push}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!push@\spxentry{push}}\ignorespaces \begin{gitusernote}[label={index-21}, before title={\thetcbcounter\ }, check odd page=true]{Push internals}
\label{\detokenize{basics/101-130-yodaproject:index-21}}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{datalad push}} uses \sphinxcode{\sphinxupquote{git push}}, and \sphinxcode{\sphinxupquote{git annex copy}} under
the hood. Publication targets need to either be configured remote Git repositories,
or git\sphinxhyphen{}annex {\hyperref[\detokenize{glossary:term-special-remote}]{\sphinxtermref{\DUrole{xref,std,std-term}{special remote}}}}s (if they support data upload).


\end{gitusernote}

\sphinxstepscope


\section{Summary}
\label{\detokenize{basics/101-128-summary_yoda:summary}}\label{\detokenize{basics/101-128-summary_yoda:summary-yoda}}\label{\detokenize{basics/101-128-summary_yoda::doc}}
\sphinxAtStartPar
The YODA principles are a small set of guidelines that can make a huge
difference towards reproducibility, comprehensibility, and transparency
in a data analysis project. By applying them in your own midterm analysis
project, you have experienced their immediate benefits.

\sphinxAtStartPar
You also noticed that these standards are not complex \textendash{} quite the opposite,
they are very intuitive.
They structure essential components of a data analysis project \textendash{}
data, code, potentially computational environments, and lastly also the results \textendash{}
in a modular and practical way, and use basic principles and commands
of DataLad you are already familiar with.

\sphinxAtStartPar
There are many advantages to this organization of contents.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Having input data as independent dataset(s) that are not influenced (only
consumed) by an analysis allows for a modular reuse of pure data datasets,
and does not conflate the data of an analysis with the results or the code.
You have experienced this with the \sphinxcode{\sphinxupquote{iris\_data}} subdataset.

\item {} 
\sphinxAtStartPar
Keeping code within an independent, version\sphinxhyphen{}controlled directory, but as a part
of the analysis dataset, makes sharing code easy and transparent, and helps
to keep directories neat and organized. Moreover,
with the data as subdatasets, data and code can be automatically shared together.
By complying to this principle, you were able to submit both code and data
in a single superdataset.

\item {} 
\sphinxAtStartPar
Keeping an analysis dataset fully self\sphinxhyphen{}contained with relative instead of
absolute paths in scripts is critical to ensure that an analysis reproduces
easily on a different computer.

\item {} 
\sphinxAtStartPar
DataLad’s Python API makes all of DataLad’s functionality available in
Python, either as standalone functions that are exposed via \sphinxcode{\sphinxupquote{datalad.api}},
or as methods of the \sphinxcode{\sphinxupquote{Dataset}} class.
This provides an alternative to the command line, but it also opens up the
possibility of performing DataLad commands directly inside of scripts.

\item {} 
\sphinxAtStartPar
Including the computational environment into an analysis dataset encapsulates
software and software versions, and thus prevents re\sphinxhyphen{}computation failures
(or sudden differences in the results) once
software is updated, and software conflicts arising on different machines
than the one the analysis was originally conducted on. You have not yet
experienced how to do this first\sphinxhyphen{}hand, but you will in a later section.

\item {} 
\sphinxAtStartPar
Having all of these components as part of a DataLad dataset allows version
controlling all pieces within the analysis regardless of their size, and
generates provenance for everything, especially if you make use of the tools
that DataLad provides. This way, anyone can understand and even reproduce
your analysis without much knowledge about your project.

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{cfg\_yoda}} procedure is a good starting point to build your next data analysis
project up on.

\end{itemize}


\subsection{Now what can I do with it?}
\label{\detokenize{basics/101-128-summary_yoda:now-what-can-i-do-with-it}}
\sphinxAtStartPar
Using tools that DataLad provides you are able to make the most out of
your data analysis project. The YODA principles are a guide to accompany
you on your path to reproducibility and provenance\sphinxhyphen{}tracking.

\sphinxAtStartPar
What should have become clear in this section is that you are already
equipped with enough DataLad tools and knowledge that complying to these
standards felt completely natural and effortless in your midterm analysis
project.

\sphinxstepscope


\chapter{Containerize!}
\label{\detokenize{basics/basics-containers:containerize}}\label{\detokenize{basics/basics-containers:chapter-containersrun}}\label{\detokenize{basics/basics-containers::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{forward}.pdf}\hspace*{\fill}}

\sphinxstepscope

\index{dataset nesting@\spxentry{dataset nesting}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!dataset nesting@\spxentry{dataset nesting}}\ignorespaces 

\section{Turtles all the way down}
\label{\detokenize{basics/101-132-advancednesting:turtles-all-the-way-down}}\label{\detokenize{basics/101-132-advancednesting:nesting2}}\label{\detokenize{basics/101-132-advancednesting:index-0}}\label{\detokenize{basics/101-132-advancednesting::doc}}
\sphinxAtStartPar
You may have noticed how working in the subdataset felt as if you would be
working in an independent dataset \textendash{} there was no information or influence at
all from the top\sphinxhyphen{}level \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} superdataset, and you build up a
completely stand\sphinxhyphen{}alone history:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{6fc0d0f Provide project description}
\PYG{g+go}{9aadac7 [DATALAD RUNCMD] analyze iris data with classification analysis}
\PYG{g+go}{ca0c747 add script for kNN classification and plotting}
\PYG{g+go}{4f945ed [DATALAD] Added subdataset}
\PYG{g+go}{18f4a98 Apply YODA dataset setup}
\PYG{g+go}{bf231d5 [DATALAD] new dataset}
\end{sphinxVerbatim}

\sphinxAtStartPar
In principle, this is no news to you. From section {\hyperref[\detokenize{basics/101-106-nesting:nesting}]{\sphinxcrossref{\DUrole{std,std-ref}{Dataset nesting}}}} (\autopageref*{\detokenize{basics/101-106-nesting:nesting}}) and the
YODA principles you already know that nesting allows for a modular reuse of
any other DataLad dataset, and that this reuse is possible and simple
precisely because all of the information is kept within a (sub)dataset.

\sphinxAtStartPar
What is new now, however, is that you applied changes to the dataset. While
you already explored the looks and feels of the \sphinxcode{\sphinxupquote{longnow}} subdataset in
previous sections, you now \sphinxstyleemphasis{modified} the contents of the \sphinxcode{\sphinxupquote{midterm\_project}}
subdataset.
How does this influence the superdataset, and how does this look like in the
superdataset’s history? You know from section {\hyperref[\detokenize{basics/101-106-nesting:nesting}]{\sphinxcrossref{\DUrole{std,std-ref}{Dataset nesting}}}} (\autopageref*{\detokenize{basics/101-106-nesting:nesting}}) that the
superdataset only stores the \sphinxstyleemphasis{state} of the subdataset. Upon creation of the
dataset, the very first, initial state of the subdataset was thus recorded in
the superdataset. But now, after you finished your project, your subdataset
evolved. Let’s query the superdataset what it thinks about this.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} move into the superdataset}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{ modified: midterm\PYGZus{}project (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
From the superdataset’s perspective, the subdataset appears as being
“modified”. Note how it is not individual files that show up as “modified”, but
indeed the complete subdataset as a single entity.

\sphinxAtStartPar
What this shows you is that the modifications of the subdataset you performed are not
automatically recorded to the superdataset. This makes sense, after all it
should be up to you to decide whether you want record something or not.
But it is worth repeating: If you modify a subdataset, you will need to save
this \sphinxstyleemphasis{in the superdataset} in order to have a clean superdataset status.

\sphinxAtStartPar
Let’s save the modification of the subdataset into the history of the
superdataset. For this, to avoid confusion, you can specify explicitly to
which dataset you want to save a modification. \sphinxcode{\sphinxupquote{\sphinxhyphen{}d .}} specifies the current
dataset, i.e., \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}, as the dataset to save to.
The \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-save-subds}} {\hyperref[\detokenize{basics/101-132-advancednesting:fom-save-subds}]{\sphinxcrossref{\DUrole{std,std-ref}{on saving subdatasets}}}} (\autopageref*{\detokenize{basics/101-132-advancednesting:fom-save-subds}}) provides some more details.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}finished my midterm project\PYGZdq{}}\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+go}{add(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\index{save modification in nested dataset@\spxentry{save modification in nested dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!save modification in nested dataset@\spxentry{save modification in nested dataset}}\ignorespaces \begin{findoutmore}[label={fom-save-subds}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{‘datalad save’ on nested datasets}
\label{\detokenize{basics/101-132-advancednesting:fom-save-subds}}

\sphinxAtStartPar
In a superdataset with subdatasets, \sphinxcode{\sphinxupquote{datalad save}} by default
tries to figure out on its own which dataset’s history of all available
datasets a \sphinxcode{\sphinxupquote{datalad save}} should be written to. However, it can reduce
confusion or allow specific operations to be very explicit in the command
call and tell DataLad where to save what kind of modifications to.

\sphinxAtStartPar
If you want to save the current state of the subdataset into the superdataset
(as necessary here), start a \sphinxcode{\sphinxupquote{save}} from the superdataset and have the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}d/\sphinxhyphen{}\sphinxhyphen{}dataset}} option point to its root:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} in the root of the superds}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}update subdataset\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you are in the superdataset, and you want to save an unsaved modification
in a subdataset to the \sphinxstyleemphasis{subdatasets} history, let \sphinxcode{\sphinxupquote{\sphinxhyphen{}d/\sphinxhyphen{}\sphinxhyphen{}dataset}} point to
the subdataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} in the superds}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }path/to/subds\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}modified XY\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The recursive option allows you to save any content underneath the specified
directory, and recurse into any potential subdatasets:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }.\PYG{+w}{ }\PYGZhy{}\PYGZhy{}recursive
\end{sphinxVerbatim}


\end{findoutmore}

\sphinxAtStartPar
Let’s check which subproject commit is now recorded in the superdataset:

\fvset{hllines={, 14,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}p\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}
\PYG{g+go}{commit c5c90178✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    finished my midterm project}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/midterm\PYGZus{}project b/midterm\PYGZus{}project}
\PYG{g+go}{index 18f4a98..6fc0d0f 160000}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} a/midterm\PYGZus{}project}
\PYG{g+go}{+++ b/midterm\PYGZus{}project}
\PYG{g+go}{@@ \PYGZhy{}1 +1 @@}
\PYG{g+go}{\PYGZhy{}Subproject commit 18f4a981✂SHA1}
\PYG{g+go}{+Subproject commit 6fc0d0f5✂SHA1}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
As you can see in the log entry, the subproject commit changed from the
first commit hash in the subdataset history to the most recent one. With this
change, therefore, your superdataset tracks the most recent version of
the \sphinxcode{\sphinxupquote{midterm\_project}} dataset, and your dataset’s status is clean again.

\sphinxAtStartPar
This time in DataLad\sphinxhyphen{}101 is a convenient moment to dive a bit deeper
into the functions of the \sphinxcode{\sphinxupquote{datalad status}} command. If you are
interested in this, check out the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-status}} {\hyperref[\detokenize{basics/101-132-advancednesting:fom-status}]{\sphinxcrossref{\DUrole{std,std-ref}{on this topic}}}} (\autopageref*{\detokenize{basics/101-132-advancednesting:fom-status}}).

\index{status@\spxentry{status}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!status@\spxentry{status}}\index{check dataset for modification@\spxentry{check dataset for modification}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!check dataset for modification@\spxentry{check dataset for modification}}\ignorespaces \begin{findoutmore}[label={fom-status}, before title={\thetcbcounter\ }, float, check odd page=true]{More on ‘datalad status’}
\label{\detokenize{basics/101-132-advancednesting:fom-status}}

\sphinxAtStartPar
First of all, let’s start with a quick overview of the different content \sphinxstyleemphasis{types}
and content \sphinxstyleemphasis{states} various \sphinxcode{\sphinxupquote{datalad status}} commands in the course
of DataLad\sphinxhyphen{}101 have shown up to this point.
You have seen the following \sphinxstyleemphasis{content types}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{file}}, e.g., \sphinxcode{\sphinxupquote{notes.txt}}: any file (or symlink that is a placeholder to an annexed file)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{directory}}, e.g., \sphinxcode{\sphinxupquote{books}}: any directory that does not qualify for the \sphinxcode{\sphinxupquote{dataset}} type

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{symlink}}, e.g., the \sphinxcode{\sphinxupquote{.jgp}} that was manually unlocked in section {\hyperref[\detokenize{basics/101-110-run2:run3}]{\sphinxcrossref{\DUrole{std,std-ref}{Input and output}}}} (\autopageref*{\detokenize{basics/101-110-run2:run3}}):
any symlink that is not used as a placeholder for an annexed file

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dataset}}, e.g., the \sphinxcode{\sphinxupquote{midterm\_project}}: any top\sphinxhyphen{}level dataset, or any subdataset
that is properly registered in the superdataset

\end{itemize}

\sphinxAtStartPar
And you have seen the following \sphinxstyleemphasis{content states}: \sphinxcode{\sphinxupquote{modified}} and \sphinxcode{\sphinxupquote{untracked}}.
The section {\hyperref[\detokenize{basics/101-136-filesystem:file-system}]{\sphinxcrossref{\DUrole{std,std-ref}{Dataset ops}}}} (\autopageref*{\detokenize{basics/101-136-filesystem:file-system}}) will show you many instances of \sphinxcode{\sphinxupquote{deleted}} content
state as well.

\sphinxAtStartPar
But beyond understanding the report of \sphinxcode{\sphinxupquote{datalad status}}, there is also
additional functionality:
\sphinxcode{\sphinxupquote{datalad status}} can handle status reports for a whole hierarchy
of datasets, and it can report on a subset of the content across any number of
datasets in this hierarchy by providing selected paths. This is useful as soon
as datasets become more complex and contain subdatasets with changing contents.

\sphinxAtStartPar
When performed without any arguments, \sphinxcode{\sphinxupquote{datalad status}} will report
the state of the current dataset. However, you can specify a path to any
sub\sphinxhyphen{} or superdataset with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dataset}} option.
In order to demonstrate this a bit better, we will make sure that not only the
state of the subdataset \sphinxstyleemphasis{within} the superdataset is modified, but also that the
subdataset contains a modification. For this, let’s add an empty text file into
the \sphinxcode{\sphinxupquote{midterm\_project}} subdataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }touch\PYG{+w}{ }midterm\PYGZus{}project/an\PYGZus{}empty\PYGZus{}file
\end{sphinxVerbatim}

\sphinxAtStartPar
If you are in the root of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}, but interested in the status
\sphinxstyleemphasis{within} the subdataset, simply provide a path (relative to your current location)
to the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+go}{untracked: midterm\PYGZus{}project/an\PYGZus{}empty\PYGZus{}file (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Alternatively, to achieve the same, specify the superdataset as the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dataset}}
and provide a path to the subdataset \sphinxstyleemphasis{with a trailing path separator} like
this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }midterm\PYGZus{}project/
\PYG{g+go}{untracked: midterm\PYGZus{}project/an\PYGZus{}empty\PYGZus{}file (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that both of these commands return only the \sphinxcode{\sphinxupquote{untracked}} file and not
not the \sphinxcode{\sphinxupquote{modified}} subdataset because we’re explicitly querying only the
subdataset for its status.
If you however, as done outside of this Find\sphinxhyphen{}out\sphinxhyphen{}more, you want to know about
the subdataset record in the superdataset without causing a status query for
the state \sphinxstyleemphasis{within} the subdataset itself, you can also provide an explicit
path to the dataset (without a trailing path separator). This can be used
to specify a specific subdataset in the case of a dataset with many subdatasets:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+go}{ modified: midterm\PYGZus{}project (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
But if you are interested in both the state within the subdataset, and
the state of the subdataset within the superdataset, you can combine the
two paths:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }midterm\PYGZus{}project\PYG{+w}{ }midterm\PYGZus{}project/
\PYG{g+go}{ modified: midterm\PYGZus{}project (dataset)}
\PYG{g+go}{untracked: midterm\PYGZus{}project/an\PYGZus{}empty\PYGZus{}file (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, if these subtle differences in the paths are not easy to memorize,
the \sphinxcode{\sphinxupquote{\sphinxhyphen{}r/\sphinxhyphen{}\sphinxhyphen{}recursive}} option will also report you both status aspects:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}\PYGZhy{}recursive
\PYG{g+go}{ modified: midterm\PYGZus{}project (dataset)}
\PYG{g+go}{untracked: midterm\PYGZus{}project/an\PYGZus{}empty\PYGZus{}file (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Importantly, the regular output from a \sphinxcode{\sphinxupquote{datalad status}} command in the commandline is “condensed” to the most important information by a tailored result renderer.
You can, however, also get \sphinxcode{\sphinxupquote{status}}’ unfiltered full output by switching the \sphinxcode{\sphinxupquote{\sphinxhyphen{}f}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}output\sphinxhyphen{}format}} from \sphinxcode{\sphinxupquote{tailored}} (the default) to \sphinxcode{\sphinxupquote{json}} or, for the same infos as \sphinxcode{\sphinxupquote{json}} but better readability, \sphinxcode{\sphinxupquote{json\_pp}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }\PYGZhy{}f\PYG{+w}{ }json\PYGZus{}pp\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+go}{\PYGZob{}}
\PYG{g+go}{  \PYGZdq{}action\PYGZdq{}: \PYGZdq{}status\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}gitshasum\PYGZdq{}: \PYGZdq{}6fc0d0f5✂SHA1\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}parentds\PYGZdq{}: \PYGZdq{}/home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}path\PYGZdq{}: \PYGZdq{}/home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/midterm\PYGZus{}project\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}prev\PYGZus{}gitshasum\PYGZdq{}: \PYGZdq{}6fc0d0f5✂SHA1\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}refds\PYGZdq{}: \PYGZdq{}/home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}state\PYGZdq{}: \PYGZdq{}modified\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}status\PYGZdq{}: \PYGZdq{}ok\PYGZdq{},}
\PYG{g+go}{  \PYGZdq{}type\PYGZdq{}: \PYGZdq{}dataset\PYGZdq{}}
\PYG{g+go}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This still was not all of the available functionality of the
\sphinxcode{\sphinxupquote{datalad status}} command. You could, for example, adjust whether and
how untracked dataset content should be reported with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}untracked}}
option, or get additional information from annexed content with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}annex}}
option (especially powerful when combined with \sphinxcode{\sphinxupquote{\sphinxhyphen{}f json\_pp}}). To get a complete overview on what you could do, check out the technical
documentation of \sphinxcode{\sphinxupquote{datalad status}} \sphinxhref{https://docs.datalad.org/en/latest/generated/man/datalad-status.html}{here}.

\sphinxAtStartPar
Before we leave this Find\sphinxhyphen{}out\sphinxhyphen{}more, lets undo the modification of the subdataset
by removing the untracked file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }rm\PYG{+w}{ }midterm\PYGZus{}project/an\PYGZus{}empty\PYGZus{}file
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}\PYGZhy{}recursive
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}


\end{findoutmore}

\sphinxAtStartPar
While there is much more to say and discover about this topic, this section showed the basic handling of datasets that are composed of, arbitrarily deeply, nested datasets.
Each (sub)dataset can be simultaneously: 1) an independently managed data module, usable and reusable in different contexts; and 2) a tightly integrated component that contributes to a look and feel of such a multi\sphinxhyphen{}unit dataset that is not unlike a \sphinxhref{https://en.wikipedia.org/wiki/Monorepo}{mono repo}.
The nesting pattern can be repeated as often as necessary or sensible.
It can be “turtles all the way down”.

\sphinxstepscope

\index{containerized data analysis@\spxentry{containerized data analysis}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!containerized data analysis@\spxentry{containerized data analysis}}\ignorespaces 

\section{Computational reproducibility with software containers}
\label{\detokenize{basics/101-133-containersrun:computational-reproducibility-with-software-containers}}\label{\detokenize{basics/101-133-containersrun:containersrun}}\label{\detokenize{basics/101-133-containersrun:index-0}}\label{\detokenize{basics/101-133-containersrun::doc}}
\sphinxAtStartPar
Just after submitting your midterm data analysis project, you get together
with your friends. “I’m curious: So what kind of analyses did y’all carry out?”
you ask. The variety of methods and datasets the others used is huge, and
one analysis interests you in particular. Later that day, you decide to
install this particular analysis dataset to learn more about the methods used
in there. However, when you \sphinxcode{\sphinxupquote{datalad rerun}} your friends analysis script,
it throws an error. Hastily, you call her \textendash{} maybe she can quickly fix her
script and resubmit the project with only minor delays. “I don’t know what
you mean”, you hear in return.
“On my machine, everything works fine!”

\sphinxAtStartPar
On its own, DataLad datasets can contain almost anything that is relevant to
ensure reproducibility: Data, code, human\sphinxhyphen{}readable analysis descriptions
(e.g., \sphinxcode{\sphinxupquote{README.md}} files), provenance on the origin of all files
obtained from elsewhere, and machine\sphinxhyphen{}readable records that link generated
outputs to the commands, scripts, and data they were created from.

\sphinxAtStartPar
This however may not be sufficient to ensure that an analysis \sphinxstyleemphasis{reproduces}
(i.e., produces the same or highly similar results), let alone \sphinxstyleemphasis{works} on a
computer different than the one it was initially composed on. This is because
the analysis does not only depend on data and code, but also the
\sphinxstyleemphasis{software environment} that it is conducted in.

\sphinxAtStartPar
A lack of information about the operating system of the computer, the precise
versions of installed software, or their configurations may
make it impossible to replicate your analysis on a different machine, or even
on your own machine once a new software update is installed. Therefore, it is
important to communicate all details about the computational environment for
an analysis as thoroughly as possible. Luckily, DataLad provides an extension
that can link computational environments to datasets, the
\sphinxhref{https://docs.datalad.org/projects/container}{datalad containers}
extension.

\sphinxAtStartPar
This section will give a quick overview on what containers are and
demonstrate how \sphinxcode{\sphinxupquote{datalad\sphinxhyphen{}container}} helps to capture full provenance of an
analysis by linking containers to datasets and analyses.
\begin{importantnote}[before title={\thetcbcounter\ }, check odd page=true]{Install the datalad-container extension}

\sphinxAtStartPar
This section uses the {\hyperref[\detokenize{glossary:term-DataLad-extension}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad extension}}}} \sphinxcode{\sphinxupquote{datalad\sphinxhyphen{}container}}.
As other extensions, it is a stand\sphinxhyphen{}alone Python package, and can be installed using {\hyperref[\detokenize{glossary:term-pip}]{\sphinxtermref{\DUrole{xref,std,std-term}{pip}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }pip\PYG{+w}{ }install\PYG{+w}{ }datalad\PYGZhy{}container
\end{sphinxVerbatim}

\sphinxAtStartPar
As with DataLad and other Python packages, you might want to do the installation in a {\hyperref[\detokenize{glossary:term-virtual-environment}]{\sphinxtermref{\DUrole{xref,std,std-term}{virtual environment}}}}.


\end{importantnote}

\index{recipe@\spxentry{recipe}!software container concept@\spxentry{software container concept}}\index{software container concept@\spxentry{software container concept}!recipe@\spxentry{recipe}}\index{image@\spxentry{image}!software container concept@\spxentry{software container concept}}\index{software container concept@\spxentry{software container concept}!image@\spxentry{image}}\index{container@\spxentry{container}!software container concept@\spxentry{software container concept}}\index{software container concept@\spxentry{software container concept}!container@\spxentry{container}}\ignorespaces 

\subsection{Containers}
\label{\detokenize{basics/101-133-containersrun:containers}}\label{\detokenize{basics/101-133-containersrun:index-1}}
\sphinxAtStartPar
To put it simple, computational containers are cut\sphinxhyphen{}down virtual machines that
allow you to package all software libraries and their dependencies (all in the
precise version your analysis requires) into a bundle you can share with
others. On your own and other’s machines, the container constitutes a secluded
software environment that
\begin{itemize}
\item {} 
\sphinxAtStartPar
contains the exact software environment that you specified, ready to run
analyses

\item {} 
\sphinxAtStartPar
does not effect any software outside of the container

\end{itemize}

\sphinxAtStartPar
Unlike virtual machines, software containers do not run a full operating
system on virtualized hardware. Instead, they use basic services of the host operating system
(in a read\sphinxhyphen{}only fashion). This makes them
lightweight and still portable. By sharing software environments with containers,
others (and also yourself) have easy access to the correct software
without the need to modify the software environment of the machine the
container runs on. Thus, containers are ideal to encapsulate the software
environment and share it together with the analysis code and data to ensure
computational reproducibility of your analyses, or to create a suitable
software environment on a computer that you do not have permissions to deploy
software on.

\sphinxAtStartPar
There are a number of different tools to create and use containers, with
\sphinxhref{https://www.docker.com}{Docker} being one of the most well\sphinxhyphen{}known of them.
While being a powerful tool, it is only rarely used on high performance computing
(HPC) infrastructure%
\begin{footnote}[1]\sphinxAtStartFootnote
The main reason why Docker is not deployed on HPC systems is because
it grants users “\sphinxhref{https://en.wikipedia.org/wiki/Superuser}{superuser privileges}”.
On multi\sphinxhyphen{}user systems such as HPC, users should not have those
privileges, as it would enable them to tamper with other’s or shared
data and resources, posing a severe security threat.
%
\end{footnote}. An alternative is \sphinxhref{https://sylabs.io/docs}{Singularity}.
Both of these tools share core terminology:
\begin{description}
\sphinxlineitem{{\hyperref[\detokenize{glossary:term-container-recipe}]{\sphinxtermref{\DUrole{xref,std,std-term}{container recipe}}}}}
\sphinxAtStartPar
A text file that lists all required components of the computational environment.
It is made by a human user.

\sphinxlineitem{{\hyperref[\detokenize{glossary:term-container-image}]{\sphinxtermref{\DUrole{xref,std,std-term}{container image}}}}}
\sphinxAtStartPar
This is \sphinxstyleemphasis{built} from the recipe file. It is a static file system inside a file,
populated with the software specified in the recipe, and some initial configuration.

\sphinxlineitem{{\hyperref[\detokenize{glossary:term-container}]{\sphinxtermref{\DUrole{xref,std,std-term}{container}}}}}
\sphinxAtStartPar
A running instance of an image that you can actually use for your computations.
If you want to create and run your own software container, you start by writing
a recipe file and build an image from it. Alternatively, you can can also \sphinxstyleemphasis{pull}
an image built from a publicly shared recipe from the \sphinxstyleemphasis{Hub} of the tool you are using.

\sphinxlineitem{hub}
\sphinxAtStartPar
A storage resource to share and consume images. Examples are
{\hyperref[\detokenize{glossary:term-Singularity-Hub}]{\sphinxtermref{\DUrole{xref,std,std-term}{Singularity\sphinxhyphen{}Hub}}}}, {\hyperref[\detokenize{glossary:term-Docker-Hub}]{\sphinxtermref{\DUrole{xref,std,std-term}{Docker\sphinxhyphen{}Hub}}}}, and \sphinxhref{https://aws.amazon.com/ecr}{Amazon ECR} which hosts Docker images.

\end{description}

\sphinxAtStartPar
Note that as of now, the \sphinxcode{\sphinxupquote{datalad\sphinxhyphen{}container}} extension supports
Singularity and Docker images.
Singularity furthermore is compatible with Docker \textendash{} you can use
Docker images as a basis for Singularity images, or run Docker images with
Singularity (even without having Docker installed).
See the \textit{Windows-wit}~{\windowswiticoninline}\textit{\ref{ww-docker}} {\hyperref[\detokenize{basics/101-133-containersrun:ww-docker}]{\sphinxcrossref{\DUrole{std,std-ref}{on Docker}}}} (\autopageref*{\detokenize{basics/101-133-containersrun:ww-docker}}) for installation options.
\begin{importantnote}[before title={\thetcbcounter\ }, check odd page=true]{Additional requirement: Singularity}

\sphinxAtStartPar
To use Singularity containers you have to
\sphinxhref{https://docs.sylabs.io/guides/3.4/user-guide/installation.html}{install} the software singularity.


\end{importantnote}

\index{installation@\spxentry{installation}!Docker@\spxentry{Docker}}\index{Docker@\spxentry{Docker}!installation@\spxentry{installation}}\index{install Docker@\spxentry{install Docker}!on Windows@\spxentry{on Windows}}\index{on Windows@\spxentry{on Windows}!install Docker@\spxentry{install Docker}}\ignorespaces \begin{windowswit}[label={ww-docker}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Docker installation}
\label{\detokenize{basics/101-133-containersrun:ww-docker}}

\sphinxAtStartPar
The software singularity is not available for Windows.
Windows users therefore need to install {\hyperref[\detokenize{glossary:term-Docker}]{\sphinxtermref{\DUrole{xref,std,std-term}{Docker}}}}.
The currently recommended way to do so is by installing \sphinxhref{https://docs.docker.com/desktop/install/windows-install/}{Docker Desktop}, and use its “WSL2” backend (a choice one can set during the installation).
In the case of an “outdated WSL kernel version” issue, run \sphinxcode{\sphinxupquote{wsl \sphinxhyphen{}\sphinxhyphen{}update}} in a regular Windows Command Prompt (CMD).
After the installation, run Docker Desktop, and wait several minutes for it to start the Docker engine in the background.
To verify that everything works as it should, run \sphinxcode{\sphinxupquote{docker ps}} in a Windows Command Prompt (CMD).
If it reports an error that asks “Is the docker daemon running?” give it a few more minutes to let Docker Desktop start it.
If it can’t find the docker command, something went wrong during installation.


\end{windowswit}

\index{containers\sphinxhyphen{}add@\spxentry{containers\sphinxhyphen{}add}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!containers\sphinxhyphen{}add@\spxentry{containers\sphinxhyphen{}add}}\index{containers\sphinxhyphen{}run@\spxentry{containers\sphinxhyphen{}run}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!containers\sphinxhyphen{}run@\spxentry{containers\sphinxhyphen{}run}}\ignorespaces 

\subsection{Using \sphinxstyleliteralintitle{\sphinxupquote{datalad containers}}}
\label{\detokenize{basics/101-133-containersrun:using-datalad-containers}}\label{\detokenize{basics/101-133-containersrun:index-3}}
\sphinxAtStartPar
One core feature of the \sphinxcode{\sphinxupquote{datalad containers}} extension is that it registers
computational containers with a dataset. This is done with the
\sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}add}} command.
Once a container is registered, arbitrary commands can be executed inside of
it, i.e., in the precise software environment the container encapsulates. All it
needs for this it to swap the \sphinxcode{\sphinxupquote{datalad run}} command introduced in
section {\hyperref[\detokenize{basics/101-108-run:run}]{\sphinxcrossref{\DUrole{std,std-ref}{Keeping track}}}} (\autopageref*{\detokenize{basics/101-108-run:run}}) with the \sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}run}} command.

\sphinxAtStartPar
Let’s see this in action for the \sphinxcode{\sphinxupquote{midterm\_analysis}} dataset by rerunning
the analysis you did for the midterm project within a Singularity container.
We start by registering a container to the dataset.
For this, we will pull an image from Singularity hub. This image was made
for the online\sphinxhyphen{}handbook, and it contains the relevant Python setup for
the analysis. Its recipe lives in the online\sphinxhyphen{}handbook’s
\sphinxhref{https://github.com/datalad-handbook/resources}{resources repository}.
If you are curious how to create a Singularity image, the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-container-creation}} {\hyperref[\detokenize{basics/101-133-containersrun:fom-container-creation}]{\sphinxcrossref{\DUrole{std,std-ref}{on this topic}}}} (\autopageref*{\detokenize{basics/101-133-containersrun:fom-container-creation}}) has some pointers:

\index{build container image@\spxentry{build container image}!with Singularity@\spxentry{with Singularity}}\index{with Singularity@\spxentry{with Singularity}!build container image@\spxentry{build container image}}\ignorespaces \begin{findoutmore}[label={fom-container-creation}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{How to make a Singularity image}
\label{\detokenize{basics/101-133-containersrun:fom-container-creation}}

\sphinxAtStartPar
Singularity containers are build from image files, often
called “recipes”, that hold a “definition” of the software container and its
contents and components. The
\sphinxhref{https://docs.sylabs.io/guides/3.4/user-guide/build\_a\_container.html}{singularity documentation}
has its own tutorial on how to build such images from scratch.
An alternative to writing the image file by hand is to use
\sphinxhref{https://github.com/ReproNim/neurodocker}{Neurodocker}. This
command\sphinxhyphen{}line program can help you generate custom Singularity recipes (and
also \sphinxcode{\sphinxupquote{Dockerfiles}}, from which Docker images are built). A wonderful tutorial
on how to use Neurodocker is
\sphinxhref{https://miykael.github.io/nipype\_tutorial/notebooks/introduction\_neurodocker.html}{this introduction}
by Michael Notter.

\sphinxAtStartPar
Once a recipe exists, the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }sudo\PYG{+w}{ }singularity\PYG{+w}{ }build\PYG{+w}{ }\PYGZlt{}NAME\PYGZgt{}\PYG{+w}{ }\PYGZlt{}RECIPE\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
will build a container (called \sphinxcode{\sphinxupquote{\textless{}NAME\textgreater{}}}) from the recipe. Note that this
command requires \sphinxcode{\sphinxupquote{root}} privileges (”\sphinxcode{\sphinxupquote{sudo}}”). You can build the container
on any machine, though, not necessarily the one that is later supposed to
actually run the analysis, e.g., your own laptop versus a compute cluster.


\end{findoutmore}

\index{add container image to dataset@\spxentry{add container image to dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!add container image to dataset@\spxentry{add container image to dataset}}\ignorespaces 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}add}} command takes an arbitrary
name to give to the container, and a path or URL to a container image:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} we are in the midterm\PYGZus{}project subdataset}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }containers\PYGZhy{}add\PYG{+w}{ }midterm\PYGZhy{}software\PYG{+w}{ }\PYGZhy{}\PYGZhy{}url\PYG{+w}{ }shub://adswa/resources:2
\PYG{g+go}{[INFO] Initializing special remote datalad}
\PYG{g+go}{add(ok): .datalad/config (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{add(ok): .datalad/config (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{containers\PYGZus{}add(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/midterm\PYGZus{}project/.datalad/environments/midterm\PYGZhy{}software/image (file)}
\end{sphinxVerbatim}

\index{hub@\spxentry{hub}!Docker@\spxentry{Docker}}\index{Docker@\spxentry{Docker}!hub@\spxentry{hub}}\ignorespaces \begin{findoutmore}[label={fom-container-add}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{How do I add an image from Docker-Hub, Amazon ECR, or a local container?}
\label{\detokenize{basics/101-133-containersrun:fom-container-add}}

\sphinxAtStartPar
Should the image you want to use sit on Dockerhub, specify the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}url}}
option prefixed with \sphinxcode{\sphinxupquote{docker://}} or \sphinxcode{\sphinxupquote{dhub://}} instead of \sphinxcode{\sphinxupquote{shub://}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }containers\PYGZhy{}add\PYG{+w}{ }midterm\PYGZhy{}software\PYG{+w}{ }\PYGZhy{}\PYGZhy{}url\PYG{+w}{ }docker://adswa/resources:2
\end{sphinxVerbatim}

\sphinxAtStartPar
If your image lives on Amazon ECR, use a \sphinxcode{\sphinxupquote{dhub://}} prefix followed by the AWS ECR URL as in

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }containers\PYGZhy{}add\PYG{+w}{ }\PYGZhy{}\PYGZhy{}url\PYG{+w}{ }dhub://12345678.dkr.ecr.us\PYGZhy{}west\PYGZhy{}2.amazonaws.com/maze\PYGZhy{}code/data\PYGZhy{}import:latest\PYG{+w}{ }data\PYGZhy{}import
\end{sphinxVerbatim}

\sphinxAtStartPar
If you want to add a container that exists locally, specify the path to it
like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }containers\PYGZhy{}add\PYG{+w}{ }midterm\PYGZhy{}software\PYG{+w}{ }\PYGZhy{}\PYGZhy{}url\PYG{+w}{ }path/to/container
\end{sphinxVerbatim}


\end{findoutmore}

\sphinxAtStartPar
This command downloaded the container from Singularity Hub, added it to
the \sphinxcode{\sphinxupquote{midterm\_project}} dataset.
This is not the only possible source for containers.
Check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-container-add}} {\hyperref[\detokenize{basics/101-133-containersrun:fom-container-add}]{\sphinxcrossref{\DUrole{std,std-ref}{on more ways to add images}}}} (\autopageref*{\detokenize{basics/101-133-containersrun:fom-container-add}}).
Once added, containers can be listed or removed.
The \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-container-remove}} {\hyperref[\detokenize{basics/101-133-containersrun:fom-container-remove}]{\sphinxcrossref{\DUrole{std,std-ref}{on this topic}}}} (\autopageref*{\detokenize{basics/101-133-containersrun:fom-container-remove}}) shows how.

\sphinxAtStartPar
Adding a container recorded basic information on the
container under its name “midterm\sphinxhyphen{}software” in the dataset’s configuration at
\sphinxcode{\sphinxupquote{.datalad/config}}. You can find out more about them in an upcoming dedicated section on these additional configurations.
Such configurations can, among other things, be important to ensure correct container invocation on specific systems or across systems.
One example is \sphinxstyleemphasis{bind\sphinxhyphen{}mounting} directories into containers, i.e., making a specific directory and its contents available inside a container.
Different containerization software (versions) or configurations of those determine \sphinxstyleemphasis{default bind\sphinxhyphen{}mounts} on a given system.
Thus, depending on the system and the location of the dataset on this system, a shared dataset may be automatically bind\sphinxhyphen{}mounted or not.
To ensure that the dataset is correctly bind\sphinxhyphen{}mounted on all systems, let’s add a call\sphinxhyphen{}format specification with a bind\sphinxhyphen{}mount to the current working directory.

\index{configuration.item@\spxentry{configuration.item}!datalad.containers.\textless{}name\textgreater{}.cmdexec@\spxentry{datalad.containers.\textless{}name\textgreater{}.cmdexec}}\ignorespaces 
\def\sphinxLiteralBlockLabel{\label{\detokenize{basics/101-133-containersrun:index-7}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}f\PYG{+w}{ }.datalad/config\PYG{+w}{ }datalad.containers.midterm\PYGZhy{}software.cmdexec\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}singularity exec \PYGZhy{}B \PYGZob{}\PYGZob{}pwd\PYGZcb{}\PYGZcb{} \PYGZob{}img\PYGZcb{} \PYGZob{}cmd\PYGZcb{}\PYGZsq{}}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Modify the container call format to bind\PYGZhy{}mount the working directory\PYGZdq{}}
\PYG{g+go}{add(ok): .datalad/config (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\index{run command with provenance capture@\spxentry{run command with provenance capture}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!run command with provenance capture@\spxentry{run command with provenance capture}}\index{run command@\spxentry{run command}!with DataLad containers\sphinxhyphen{}run@\spxentry{with DataLad containers\sphinxhyphen{}run}}\index{with DataLad containers\sphinxhyphen{}run@\spxentry{with DataLad containers\sphinxhyphen{}run}!run command@\spxentry{run command}}\ignorespaces 
\sphinxAtStartPar
Now that we have a complete computational environment linked to the \sphinxcode{\sphinxupquote{midterm\_project}}
dataset, we can execute commands in this environment. Let us, for example, try to repeat
the \sphinxcode{\sphinxupquote{datalad run}} command from the section {\hyperref[\detokenize{basics/101-130-yodaproject:yoda-project}]{\sphinxcrossref{\DUrole{std,std-ref}{YODA\sphinxhyphen{}compliant data analysis projects}}}} (\autopageref*{\detokenize{basics/101-130-yodaproject:yoda-project}}) as a
\sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}run}} command.

\sphinxAtStartPar
The previous \sphinxcode{\sphinxupquote{run}} command looked like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}analyze iris data with classification analysis\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}input/iris.csv\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}pairwise\PYGZus{}relationships.png\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}prediction\PYGZus{}report.csv\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYG{l+s+s2}{\PYGZdq{}python3 code/script.py \PYGZob{}inputs\PYGZcb{} \PYGZob{}outputs\PYGZcb{}\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
How would it look like as a \sphinxcode{\sphinxupquote{containers\sphinxhyphen{}run}} command?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }containers\PYGZhy{}run\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}rerun analysis in container\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}container\PYGZhy{}name\PYG{+w}{ }midterm\PYGZhy{}software\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}input/iris.csv\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}pairwise\PYGZus{}relationships.png\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}prediction\PYGZus{}report.csv\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYG{l+s+s2}{\PYGZdq{}python3 code/script.py \PYGZob{}inputs\PYGZcb{} \PYGZob{}outputs\PYGZcb{}\PYGZdq{}}
\PYG{g+go}{unlock(ok): pairwise\PYGZus{}relationships.png (file)}
\PYG{g+go}{unlock(ok): prediction\PYGZus{}report.csv (file)}
\PYG{g+go}{[INFO] == Command start (output follows) =====}
\PYG{g+go}{[INFO] == Command exit (modification check follows) =====}
\PYG{g+go}{run(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/midterm\PYGZus{}project (dataset) [singularity exec \PYGZhy{}B /home/me/dl\PYGZhy{}101/Data...]}
\PYG{g+go}{add(ok): pairwise\PYGZus{}relationships.png (file)}
\PYG{g+go}{add(ok): prediction\PYGZus{}report.csv (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{action summary:}
\PYG{g+go}{  add (ok: 2)}
\PYG{g+go}{  get (notneeded: 4)}
\PYG{g+go}{  run (ok: 1)}
\PYG{g+go}{  save (notneeded: 1, ok: 1)}
\PYG{g+go}{  unlock (ok: 2)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Almost exactly like a \sphinxcode{\sphinxupquote{datalad run}} command! The only additional parameter
is \sphinxcode{\sphinxupquote{container\sphinxhyphen{}name}}. At this point, though, the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}container\sphinxhyphen{}name}}
flag is even \sphinxstyleemphasis{optional} because there is only a single container registered to the dataset.
But if your dataset contains more than one container you will \sphinxstyleemphasis{need} to specify
the name of the container you want to use in your command.
The complete command’s structure looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }containers\PYGZhy{}run\PYG{+w}{ }\PYGZhy{}\PYGZhy{}name\PYG{+w}{ }\PYGZlt{}containername\PYGZgt{}\PYG{+w}{ }\PYG{o}{[}\PYGZhy{}m\PYG{+w}{ }...\PYG{o}{]}\PYG{+w}{ }\PYG{o}{[}\PYGZhy{}\PYGZhy{}input\PYG{+w}{ }...\PYG{o}{]}\PYG{+w}{ }\PYG{o}{[}\PYGZhy{}\PYGZhy{}output\PYG{+w}{ }...\PYG{o}{]}\PYG{+w}{ }\PYGZlt{}COMMAND\PYGZgt{}
\end{sphinxVerbatim}

\index{containers\sphinxhyphen{}remove@\spxentry{containers\sphinxhyphen{}remove}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!containers\sphinxhyphen{}remove@\spxentry{containers\sphinxhyphen{}remove}}\index{containers\sphinxhyphen{}list@\spxentry{containers\sphinxhyphen{}list}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!containers\sphinxhyphen{}list@\spxentry{containers\sphinxhyphen{}list}}\index{list known containers@\spxentry{list known containers}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!list known containers@\spxentry{list known containers}}\ignorespaces \begin{findoutmore}[label={fom-container-remove}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{How can I list available containers or remove them?}
\label{\detokenize{basics/101-133-containersrun:fom-container-remove}}

\sphinxAtStartPar
The command \sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}list}} will list all containers in
the current dataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }containers\PYGZhy{}list
\PYG{g+go}{midterm\PYGZhy{}software \PYGZhy{}\PYGZgt{} .datalad/environments/midterm\PYGZhy{}software/image}
\end{sphinxVerbatim}

\sphinxAtStartPar
The command \sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}remove}} will remove a container
from the dataset, if there exists a container with name given to the
command. Note that this will remove not only the image from the dataset,
but also the configuration for it in \sphinxcode{\sphinxupquote{.datalad/config}}.


\end{findoutmore}

\sphinxAtStartPar
Here is how the history entry looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}p\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}
\PYG{g+go}{commit 4f00ad07✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    [DATALAD RUNCMD] rerun analysis in container}

\PYG{g+go}{    === Do not change lines below ===}
\PYG{g+go}{    \PYGZob{}}
\PYG{g+go}{     \PYGZdq{}chain\PYGZdq{}: [],}
\PYG{g+go}{     \PYGZdq{}cmd\PYGZdq{}: \PYGZdq{}singularity exec \PYGZhy{}B \PYGZob{}pwd\PYGZcb{} .datalad/environments/midterm\PYGZhy{}software/image python3 code/script.py \PYGZob{}inputs\PYGZcb{} \PYGZob{}outputs\PYGZcb{}\PYGZdq{},}
\PYG{g+go}{     \PYGZdq{}dsid\PYGZdq{}: \PYGZdq{}d95bafc8\PYGZhy{}f2a4\PYGZhy{}d27b\PYGZhy{}dcf4\PYGZhy{}bb99f4bea973\PYGZdq{},}
\PYG{g+go}{     \PYGZdq{}exit\PYGZdq{}: 0,}
\PYG{g+go}{     \PYGZdq{}extra\PYGZus{}inputs\PYGZdq{}: [}
\PYG{g+go}{      \PYGZdq{}.datalad/environments/midterm\PYGZhy{}software/image\PYGZdq{}}
\PYG{g+go}{     ],}
\PYG{g+go}{     \PYGZdq{}inputs\PYGZdq{}: [}
\PYG{g+go}{      \PYGZdq{}input/iris.csv\PYGZdq{}}
\PYG{g+go}{     ],}
\PYG{g+go}{     \PYGZdq{}outputs\PYGZdq{}: [}
\PYG{g+go}{      \PYGZdq{}pairwise\PYGZus{}relationships.png\PYGZdq{},}
\PYG{g+go}{      \PYGZdq{}prediction\PYGZus{}report.csv\PYGZdq{}}
\PYG{g+go}{     ],}
\PYG{g+go}{     \PYGZdq{}pwd\PYGZdq{}: \PYGZdq{}.\PYGZdq{}}
\PYG{g+go}{    \PYGZcb{}}
\PYG{g+go}{    \PYGZca{}\PYGZca{}\PYGZca{} Do not change lines above \PYGZca{}\PYGZca{}\PYGZca{}}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/pairwise\PYGZus{}relationships.png b/pairwise\PYGZus{}relationships.png}
\PYG{g+go}{index a24e6b9..963d5a8 120000}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} a/pairwise\PYGZus{}relationships.png}
\PYG{g+go}{+++ b/pairwise\PYGZus{}relationships.png}
\PYG{g+go}{@@ \PYGZhy{}1 +1 @@}
\PYG{g+go}{\PYGZhy{}.git/annex/objects/G3/Mg/✂/MD5E\PYGZhy{}s260649\PYGZhy{}\PYGZhy{}127313ad✂MD5.png}
\PYG{g+go}{\PYGZbs{} No newline at end of file}
\PYG{g+go}{+.git/annex/objects/q1/gp/✂/MD5E\PYGZhy{}s261062\PYGZhy{}\PYGZhy{}025dc493✂MD5.png}
\PYG{g+go}{\PYGZbs{} No newline at end of file}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you would \sphinxcode{\sphinxupquote{datalad rerun}} this commit, it would be re\sphinxhyphen{}executed in the
software container registered to the dataset. If you would share the dataset
with a friend and they would \sphinxcode{\sphinxupquote{datalad rerun}} this commit, the image would first
be obtained from its registered url, and thus your
friend can obtain the correct execution environment automatically.

\sphinxAtStartPar
Note that because this new \sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}run}} command modified the
\sphinxcode{\sphinxupquote{midterm\_project}} subdirectory, we need to also save
the most recent state of the subdataset to the superdataset \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{ modified: midterm\PYGZus{}project (dataset)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add container and execute analysis within container\PYGZdq{}}\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+go}{add(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Software containers, the \sphinxcode{\sphinxupquote{datalad\sphinxhyphen{}container}} extension, and DataLad thus work well together
to make your analysis completely reproducible \textendash{} by not only linking code, data,
and outputs, but also the software environment of an analysis. And this does not
only benefit your future self, but also whomever you share your dataset with, as
the information about the container is shared together with the dataset. How cool
is that?

\index{DataLad concept@\spxentry{DataLad concept}!container image registration@\spxentry{container image registration}}\index{container image registration@\spxentry{container image registration}!DataLad concept@\spxentry{DataLad concept}}\ignorespaces 
\sphinxAtStartPar
What changes in .datalad/config when one adds a container?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }.datalad/config
\PYG{g+go}{[datalad \PYGZdq{}dataset\PYGZdq{}]}
\PYG{g+go}{	id = d95bafc8\PYGZhy{}f2a4\PYGZhy{}d27b\PYGZhy{}dcf4\PYGZhy{}bb99f4bea973}
\PYG{g+go}{[datalad \PYGZdq{}containers.midterm\PYGZhy{}software\PYGZdq{}]}
\PYG{g+go}{	image = .datalad/environments/midterm\PYGZhy{}software/image}
\PYG{g+go}{	cmdexec = singularity exec \PYGZob{}img\PYGZcb{} \PYGZob{}cmd\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This recorded the image’s origin on Singularity\sphinxhyphen{}Hub, the location of the
image in the dataset under \sphinxcode{\sphinxupquote{.datalad/environments/\textless{}NAME\textgreater{}/image}}, and it
specifies the way in which the container should be used: The line

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+na}{cmdexec}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{singularity exec \PYGZob{}img\PYGZcb{} \PYGZob{}cmd\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
can be read as: “If this container is used, take the \sphinxcode{\sphinxupquote{cmd}} (what you wrap in a
\sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}run}} command) and plug it into a
\sphinxcode{\sphinxupquote{ singularity exec}} command. The mode of calling Singularity,
namely \sphinxcode{\sphinxupquote{exec}}, means that the command will be executed inside of the container.

\sphinxAtStartPar
You can configure this call format by modifying it in the config file, or calling \sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}add}} with the option \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}call\sphinxhyphen{}fmt \textless{}alternative format\textgreater{}}}.
This can be useful to, for example, automatically bind\sphinxhyphen{}mount the current working directory in the container.
In the alternative call format, the placeholders \sphinxcode{\sphinxupquote{\{img\}}}, \sphinxcode{\sphinxupquote{\{cmd\}}}, and \sphinxcode{\sphinxupquote{\{img\_dspath\}}} (a relative path to the dataset containing the image) are available.
In all other cases with variables that use curly brackets, you need to escape them with another curly bracket.
Here is an example call format that bind\sphinxhyphen{}mounts the current working directory (and thus the dataset) automatically:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }containers\PYGZhy{}add\PYG{+w}{ }\PYGZhy{}\PYGZhy{}call\PYGZhy{}fmt\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}singularity exec \PYGZhy{}B \PYGZob{}\PYGZob{}pwd\PYGZcb{}\PYGZcb{} \PYGZhy{}\PYGZhy{}cleanenv \PYGZob{}img\PYGZcb{} \PYGZob{}cmd\PYGZcb{}\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the image is saved under \sphinxcode{\sphinxupquote{.datalad/environments}} and the
configuration is done in \sphinxcode{\sphinxupquote{.datalad/config}} \textendash{} as these files are version
controlled and shared with together with a dataset, your software
container and the information where it can be reobtained from are linked
to your dataset.

\sphinxAtStartPar
This is how the \sphinxcode{\sphinxupquote{containers\sphinxhyphen{}add}} command is recorded in your history:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYGZhy{}p
\PYG{g+go}{commit 54aad5de✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    [DATALAD] Configure containerized environment \PYGZsq{}midterm\PYGZhy{}software\PYGZsq{}}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/.datalad/config b/.datalad/config}
\PYG{g+go}{index e99ec14..ad3e5d8 100644}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} a/.datalad/config}
\PYG{g+go}{+++ b/.datalad/config}
\PYG{g+go}{@@ \PYGZhy{}1,2 +1,5 @@}
\PYG{g+go}{ [datalad \PYGZdq{}dataset\PYGZdq{}]}
\PYG{g+go}{ 	id = d95bafc8\PYGZhy{}f2a4\PYGZhy{}d27b\PYGZhy{}dcf4\PYGZhy{}bb99f4bea973}
\PYG{g+go}{+[datalad \PYGZdq{}containers.midterm\PYGZhy{}software\PYGZdq{}]}
\PYG{g+go}{+	image = .datalad/environments/midterm\PYGZhy{}software/image}
\PYG{g+go}{+	cmdexec = singularity exec \PYGZob{}img\PYGZcb{} \PYGZob{}cmd\PYGZcb{}}
\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/.datalad/environments/midterm\PYGZhy{}software/image b/.datalad/environments/midterm\PYGZhy{}software/image}
\PYG{g+go}{new file mode 120000}
\PYG{g+go}{index 0000000..75c8b41}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/.datalad/environments/midterm\PYGZhy{}software/image}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1 @@}
\PYG{g+go}{+../../../.git/annex/objects/F1/K3/✂/MD5E\PYGZhy{}s230694943\PYGZhy{}\PYGZhy{}944b0300✂MD5}
\PYG{g+go}{\PYGZbs{} No newline at end of file}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Summary}
\label{\detokenize{basics/101-134-summary:summary}}\label{\detokenize{basics/101-134-summary:summary-containers}}\label{\detokenize{basics/101-134-summary::doc}}
\sphinxAtStartPar
The last two sections have first of all extended your knowledge on dataset nesting:
\begin{itemize}
\item {} 
\sphinxAtStartPar
When subdatasets are created or installed, they are registered to the superdataset
in their current version state (as identified by their most recent commit’s hash).
For a freshly created subdatasets, the most recent commit is at the same time its
first commit.

\item {} 
\sphinxAtStartPar
Once the subdataset evolves, the superdataset recognizes this as a \sphinxcode{\sphinxupquote{modification}}
of the subdatasets version state. If you want to record this, you need to
\sphinxcode{\sphinxupquote{datalad save}} it in the superdataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}a short summary of changes in subds\PYGZdq{}}\PYG{+w}{ }\PYGZlt{}path\PYG{+w}{ }to\PYG{+w}{ }subds\PYGZgt{}
\end{sphinxVerbatim}

\end{itemize}

\sphinxAtStartPar
But more than nesting concepts, they have also extended your knowledge on
reproducible analyses with \sphinxcode{\sphinxupquote{datalad run}} and you have experienced
for yourself why and how software containers can go hand\sphinxhyphen{}in\sphinxhyphen{}hand with DataLad:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A software container encapsulates a complete software environment, independent
from the environment of the computer it runs on. This allows you to create or
use secluded software and also share it together with your analysis to ensure
computational reproducibility. The DataLad extension
\sphinxhref{https://docs.datalad.org/projects/container}{datalad containers}
can make this possible.

\item {} 
\sphinxAtStartPar
The command \sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}add}} registers an {\hyperref[\detokenize{glossary:term-container-image}]{\sphinxtermref{\DUrole{xref,std,std-term}{container image}}}} from a path or
URL to your dataset.

\item {} 
\sphinxAtStartPar
If you use \sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}run}} instead of \sphinxcode{\sphinxupquote{datalad run}},
you can reproducibly execute a command of your choice \sphinxstyleemphasis{within} the software
environment.

\item {} 
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{datalad rerun}} of a commit produced with \sphinxcode{\sphinxupquote{datalad containers\sphinxhyphen{}run}}
will re\sphinxhyphen{}execute the command in the same software environment.

\end{itemize}

\index{hub@\spxentry{hub}!Docker@\spxentry{Docker}}\index{Docker@\spxentry{Docker}!hub@\spxentry{hub}}\ignorespaces 

\subsection{Now what can I do with it?}
\label{\detokenize{basics/101-134-summary:now-what-can-i-do-with-it}}\label{\detokenize{basics/101-134-summary:index-0}}
\sphinxAtStartPar
For one, you will not be surprised if you ever see a subdataset being shown as
\sphinxcode{\sphinxupquote{modified}} by \sphinxcode{\sphinxupquote{datalad status}}: You now know that if a subdataset
evolves, it’s most recent state needs to be explicitly saved to the superdatasets
history.

\sphinxAtStartPar
On a different matter, you are now able to capture and share analysis provenance that
includes the relevant software environment. This does not only make your analyses
projects automatically reproducible, but automatically \sphinxstyleemphasis{computationally} reproducible \sphinxhyphen{}
you can make sure that your analyses runs on any computer with Singularity,
regardless of the software environment on this computer. Even if you are unsure how you can wrap up an
environment into a software {\hyperref[\detokenize{glossary:term-container-image}]{\sphinxtermref{\DUrole{xref,std,std-term}{container image}}}} at this point, you could make use of
hundreds of publicly available images on \sphinxhref{https://singularity-hub.org}{Singularity\sphinxhyphen{}Hub} and
\sphinxhref{https://hub.docker.com}{Docker\sphinxhyphen{}Hub}.

\sphinxAtStartPar
With this, you have also gotten a first glimpse into an extension of DataLad: A
Python module you can install with Python package managers such as \sphinxcode{\sphinxupquote{pip}} that
extends DataLad’s functionality.

\sphinxstepscope


\chapter{Distributing datasets}
\label{\detokenize{basics/basics-thirdparty:distributing-datasets}}\label{\detokenize{basics/basics-thirdparty:chapter-thirdparty}}\label{\detokenize{basics/basics-thirdparty::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{clouds}.pdf}\hspace*{\fill}}

\sphinxstepscope


\section{Beyond shared infrastructure}
\label{\detokenize{basics/101-138-sharethirdparty:beyond-shared-infrastructure}}\label{\detokenize{basics/101-138-sharethirdparty:sharethirdparty}}\label{\detokenize{basics/101-138-sharethirdparty::doc}}
\sphinxAtStartPar
Data sharing potentially involves a number of different elements.
Other than the dataset you want to share, it can involve repository hosting services, third party storage services, or other computational infrastructure.
As you experienced in the chapter {\hyperref[\detokenize{basics/basics-collaboration:chapter-collaboration}]{\sphinxcrossref{\DUrole{std,std-ref}{Collaboration}}}} (\autopageref*{\detokenize{basics/basics-collaboration:chapter-collaboration}}), users on a common, shared computational infrastructure such as an {\hyperref[\detokenize{glossary:term-SSH-server}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH server}}}}
can share datasets via simple installations with paths, without any involvement of third party storage providers or repository hosting services.
But at some point in a dataset’s life, you may want to share it with people that
can’t access the computer or server your dataset lives on, store it on other infrastructure
to save diskspace, or create a backup.
When this happens, you will want to distribute your dataset to repository hosting
services (for example, {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}, {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}, or {\hyperref[\detokenize{glossary:term-GIN}]{\sphinxtermref{\DUrole{xref,std,std-term}{GIN}}}})
and/or third party storage providers (such as \sphinxhref{https://www.dropbox.com}{Dropbox}, \sphinxhref{https://www.google.com}{Google},
\sphinxhref{https://aws.amazon.com/s3}{Amazon S3 buckets},
the \sphinxhref{https://osf.io}{Open Science Framework} (OSF), and many others).

\sphinxAtStartPar
This chapter walks through mostly conceptual aspects of dataset publishing:
It illustrates general concepts of dataset publishing and the idea of using third party services as {\hyperref[\detokenize{glossary:term-special-remote}]{\sphinxtermref{\DUrole{xref,std,std-term}{special remote}}}}s from
which annexed file contents can be retrieved via \sphinxcode{\sphinxupquote{datalad get}}.
{\hyperref[\detokenize{basics/101-139-hostingservices:share-hostingservice}]{\sphinxcrossref{\DUrole{std,std-ref}{Publishing datasets to Git repository hosting}}}} (\autopageref*{\detokenize{basics/101-139-hostingservices:share-hostingservice}}) then demonstrates how to publish datasets to any kind of Git repository hosting service.
The web version of the book extends this information with step\sphinxhyphen{}by\sphinxhyphen{}step instructions for various repository hosting and third party storage solutions, and showcases a variety of ways to distribute datasets and their contents to different services.


\subsection{Leveraging third party infrastructure}
\label{\detokenize{basics/101-138-sharethirdparty:leveraging-third-party-infrastructure}}
\sphinxAtStartPar
There are several ways to distribute datasets or make them available for others:
\begin{itemize}
\item {} 
\sphinxAtStartPar
You can \sphinxstylestrong{publish your dataset to a repository with annex support} such as {\hyperref[\detokenize{glossary:term-GIN}]{\sphinxtermref{\DUrole{xref,std,std-term}{GIN}}}} or the \sphinxhref{https://osf.io}{OSF}%
\begin{footnote}[1]\sphinxAtStartFootnote
Requires the \sphinxhref{https://docs.datalad.org/projects/osf}{datalad\sphinxhyphen{}osf extension}.
%
\end{footnote}. This is the easiest way to share datasets and all their contents. Read on in the online\sphinxhyphen{}handbook or consult the tutorials of the \sphinxhref{https://docs.datalad.org/projects/osf}{datalad\sphinxhyphen{}osf extension} to learn how to do this.

\item {} 
\sphinxAtStartPar
You can \sphinxstylestrong{publish your dataset to a repository hosting service}, and \sphinxstylestrong{configure an external resource that stores your annexed data}. Such a resource can be a private web server, but also a third party services cloud storage such as \sphinxhref{https://www.dropbox.com}{Dropbox}, \sphinxhref{https://www.google.com}{Google}, \sphinxhref{https://aws.amazon.com/s3}{Amazon S3 buckets}, \sphinxhref{https://www.box.com}{Box.com}, \sphinxhref{https://owncloud.com}{owncloud}, \sphinxhref{https://hochschulcloud.nrw}{sciebo}, or many more.

\item {} 
\sphinxAtStartPar
You can \sphinxstylestrong{export your dataset statically} as a snapshot to a service such as  \sphinxhref{https://figshare.com}{Figshare} or the \sphinxhref{https://osf.io}{OSF}.

\item {} 
\sphinxAtStartPar
You can \sphinxstylestrong{publish your dataset to a repository hosting service} and ensure that
all dataset contents are either available from pre\sphinxhyphen{}existing public sources or can be recomputed from a {\hyperref[\detokenize{glossary:term-run-record}]{\sphinxtermref{\DUrole{xref,std,std-term}{run record}}}}.

\end{itemize}


\subsection{Dataset contents and third party services influence sharing}
\label{\detokenize{basics/101-138-sharethirdparty:dataset-contents-and-third-party-services-influence-sharing}}
\sphinxAtStartPar
Because DataLad datasets are {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} repositories, it is possible to
\sphinxcode{\sphinxupquote{datalad push}} datasets to any Git repository hosting service, such as
{\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}, {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}, {\hyperref[\detokenize{glossary:term-GIN}]{\sphinxtermref{\DUrole{xref,std,std-term}{GIN}}}}, {\hyperref[\detokenize{glossary:term-Bitbucket}]{\sphinxtermref{\DUrole{xref,std,std-term}{Bitbucket}}}}, \sphinxhref{https://gogs.io}{Gogs},
or \sphinxhref{https://about.gitea.com}{Gitea}.
You have already done this in section {\hyperref[\detokenize{basics/101-130-yodaproject:yoda-project}]{\sphinxcrossref{\DUrole{std,std-ref}{YODA\sphinxhyphen{}compliant data analysis projects}}}} (\autopageref*{\detokenize{basics/101-130-yodaproject:yoda-project}}) when you shared your \sphinxcode{\sphinxupquote{midterm\_project}} dataset via {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}.

\sphinxAtStartPar
However, most Git repository hosting services do not support hosting the file content
of the files managed by {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}.
For example, the the results of the analysis in section {\hyperref[\detokenize{basics/101-130-yodaproject:yoda-project}]{\sphinxcrossref{\DUrole{std,std-ref}{YODA\sphinxhyphen{}compliant data analysis projects}}}} (\autopageref*{\detokenize{basics/101-130-yodaproject:yoda-project}}),
\sphinxcode{\sphinxupquote{pairwise\_comparisons.png}} and \sphinxcode{\sphinxupquote{prediction\_report.csv}}, were not published to
GitHub: There was meta data about their file availability, but if a friend cloned
this dataset and ran a \sphinxcode{\sphinxupquote{datalad get}} command, content retrieval would fail
because their only known location is your private computer to which only you have access.
Instead, they would need to be recomputed from the {\hyperref[\detokenize{glossary:term-run-record}]{\sphinxtermref{\DUrole{xref,std,std-term}{run record}}}} in the dataset.

\sphinxAtStartPar
When you are distributing DataLad datasets to other people or third party services,
an important distinction thus lies in \sphinxstyleemphasis{annexed} versus \sphinxstyleemphasis{not\sphinxhyphen{}annexed} content, i.e.,
files that stored in your dataset’s {\hyperref[\detokenize{glossary:term-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{annex}}}} versus files that are committed
into {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}}.
The third\sphinxhyphen{}party service of your choice may have support for both annexed and non\sphinxhyphen{}annexed files, or only one of them.

\begin{figure}[tbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.800\linewidth]{{publishing_network_publishparts2}.pdf}
\caption{Schematic difference between the Git and git\sphinxhyphen{}annex aspect of your dataset, and where each part \sphinxstyleemphasis{usually} gets distributed to.}\label{\detokenize{basics/101-138-sharethirdparty:id5}}\end{figure}


\subsubsection{The common case: Repository hosting without annex support and special remotes}
\label{\detokenize{basics/101-138-sharethirdparty:the-common-case-repository-hosting-without-annex-support-and-special-remotes}}
\sphinxAtStartPar
Because DataLad datasets are {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} repositories, it is possible to
\sphinxcode{\sphinxupquote{datalad push}} datasets to any Git repository hosting service, such as
{\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}, {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}, {\hyperref[\detokenize{glossary:term-GIN}]{\sphinxtermref{\DUrole{xref,std,std-term}{GIN}}}}, {\hyperref[\detokenize{glossary:term-Bitbucket}]{\sphinxtermref{\DUrole{xref,std,std-term}{Bitbucket}}}}, \sphinxhref{https://gogs.io}{Gogs},
or \sphinxhref{https://about.gitea.com}{Gitea}.
But while anything that is managed by Git is accessible in repository hosting services, they usually don’t support storing annexed data%
\begin{footnote}[2]\sphinxAtStartFootnote
In addition to not storing annexed data, most Git repository hosting services also have a size limit for files kept in Git. So while you could \sphinxstyleemphasis{theoretically} commit a sizable file into Git, this would not only negatively impact the performance of your dataset as Git doesn’t handle large files well, but it would also \sphinxhref{https://docs.github.com/en/repositories/working-with-files/managing-large-files/about-large-files-on-github}{prevent your dataset to be published to a Git repository hosting service like GitHub}.
%
\end{footnote}.

\sphinxAtStartPar
When you want to publish a dataset to a Git repository hosting service to allow others to easily find and clone it, but you also want others to be able to retrieve annexed files in this dataset via \sphinxcode{\sphinxupquote{datalad get}}, annexed contents need to be pushed to additional storage hosting services.
The hosting services can be all kinds of private, institutional, or commercial services, and their location will be registered in the dataset under the concept of a {\hyperref[\detokenize{glossary:term-special-remote}]{\sphinxtermref{\DUrole{xref,std,std-term}{special remote}}}}. Check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-special-remote}} {\hyperref[\detokenize{basics/101-138-sharethirdparty:fom-special-remote}]{\sphinxcrossref{\DUrole{std,std-ref}{on this}}}} (\autopageref*{\detokenize{basics/101-138-sharethirdparty:fom-special-remote}}) for some background on this git\sphinxhyphen{}annex concept.

\index{special remote@\spxentry{special remote}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!special remote@\spxentry{special remote}}\ignorespaces \begin{findoutmore}[label={fom-special-remote}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{What is a special remote}
\label{\detokenize{basics/101-138-sharethirdparty:fom-special-remote}}

\sphinxAtStartPar
A special\sphinxhyphen{}remote is an extension to Git’s concept of remotes, and can
enable {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} to transfer data from and possibly to places that are not Git
repositories (e.g., cloud services or external machines such as an HPC
system). For example, an \sphinxstyleemphasis{s3} special remote uploads and downloads content
to AWS S3, a \sphinxstyleemphasis{web} special remote downloads files from the web, the \sphinxstyleemphasis{datalad\sphinxhyphen{}archive} special remote
extracts files from annexed archives, etc. Don’t envision a special\sphinxhyphen{}remote
as merely a physical place or location \textendash{} a special\sphinxhyphen{}remote is a protocol that
defines the underlying transport of your files to and/or from a specific location.


\end{findoutmore}

\sphinxAtStartPar
To register a special remote in your dataset and use it for file storage, you need to configure the service of your choice and \sphinxstyleemphasis{publish} the annexed contents to it. Afterwards, the published dataset (e.g., via {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}} or {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}) stores the information about where to obtain annexed file contents from such that
\sphinxcode{\sphinxupquote{datalad get}} works.
Once you have configured the service of your choice, you can push your datasets Git history to the repository hosting service and the annexed contents to the special remote. DataLad also makes it easy to push these different dataset contents exactly where they need to be automatically via a {\hyperref[\detokenize{glossary:term-publication-dependency}]{\sphinxtermref{\DUrole{xref,std,std-term}{publication dependency}}}}.
The general workflow looks as follows:

\sphinxAtStartPar
From your perspective (as someone who wants to distribute datasets), you will
need to
\begin{itemize}
\item {} 
\sphinxAtStartPar
(potentially) install/setup the relevant \sphinxstyleemphasis{special\sphinxhyphen{}remote},

\item {} 
\sphinxAtStartPar
create a dataset sibling on GitHub/GitLab/… for yourself or others to install from,

\item {} 
\sphinxAtStartPar
set up a \sphinxstyleemphasis{publication dependency} between repository hosting and special remote, so that annexed contents are automatically pushed to the special remote when ever you update the sibling on the Git repository hosting site,

\item {} 
\sphinxAtStartPar
publish your dataset.

\end{itemize}

\sphinxAtStartPar
This gives you the freedom to decide where your data lives and
who can have access to it. Once this set up is complete, updating and
accessing a distributed dataset and its data is almost as easy as if it would
lie on your own machine.

\sphinxAtStartPar
If you decide to share your dataset with others, a dataset consumer or collaborator will need to
\begin{itemize}
\item {} 
\sphinxAtStartPar
(potentially) install the relevant \sphinxstyleemphasis{special\sphinxhyphen{}remote} (dependent on the third\sphinxhyphen{}party service you chose) and

\item {} 
\sphinxAtStartPar
perform the standard \sphinxcode{\sphinxupquote{datalad clone}} and \sphinxcode{\sphinxupquote{datalad get}} commands
as necessary.

\end{itemize}

\sphinxAtStartPar
Thus, from a collaborator’s perspective, with the exception of potentially
installing/setting up the relevant \sphinxstyleemphasis{special\sphinxhyphen{}remote}, obtaining your dataset and its
data is as easy as with any public DataLad dataset.
While you have to invest some setup effort in the beginning, once this
is done, the workflows of yours and others are the same that you are already
very familiar with.

\sphinxAtStartPar
If you are interested in learning how to set up different services as special remotes, you can take a look at handbook.datalad.org for concrete examples with DataLad datasets, and the general section {\hyperref[\detokenize{basics/101-139-hostingservices:share-hostingservice}]{\sphinxcrossref{\DUrole{std,std-ref}{Publishing datasets to Git repository hosting}}}} (\autopageref*{\detokenize{basics/101-139-hostingservices:share-hostingservice}}) on setting up dataset siblings.
In addition, there are step\sphinxhyphen{}by\sphinxhyphen{}step walk\sphinxhyphen{}throughs in the documentation of git\sphinxhyphen{}annex for services such as \sphinxhref{https://git-annex.branchable.com/tips/public\_Amazon\_S3\_remote}{S3}, \sphinxhref{https://git-annex.branchable.com/tips/using\_Google\_Cloud\_Storage}{Google Cloud Storage},
\sphinxhref{https://git-annex.branchable.com/tips/using\_box.com\_as\_a\_special\_remote}{Box.com},
\sphinxhref{https://git-annex.branchable.com/tips/using\_Amazon\_Glacier}{Amazon Glacier},
\sphinxhref{https://git-annex.branchable.com/tips/owncloudannex}{OwnCloud}, and many more.
Here is the complete list: \sphinxhref{https://git-annex.branchable.com/special\_remotes}{git\sphinxhyphen{}annex.branchable.com/special\_remotes}.


\subsubsection{The easy case: Repository hosting with annex support}
\label{\detokenize{basics/101-138-sharethirdparty:the-easy-case-repository-hosting-with-annex-support}}
\sphinxAtStartPar
There are a few Git repository hosting services with support for annexed contents, as illustrated in \hyperref[\detokenize{basics/101-138-sharethirdparty:fig-specialpublishing}]{Fig.\@ \ref{\detokenize{basics/101-138-sharethirdparty:fig-specialpublishing}}}.
One of them is {\hyperref[\detokenize{glossary:term-GIN}]{\sphinxtermref{\DUrole{xref,std,std-term}{GIN}}}}.
What makes them extremely convenient is that there is no need to configure a special remote \textendash{} creating a {\hyperref[\detokenize{glossary:term-sibling}]{\sphinxtermref{\DUrole{xref,std,std-term}{sibling}}}} and running \sphinxcode{\sphinxupquote{datalad push}} is enough.

\begin{figure}[tbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.800\linewidth]{{publishing_network_publishgin}.pdf}
\caption{Some repository hosting services have annex support \sphinxhyphen{} they can host both the Git and git\sphinxhyphen{}annex parts of your dataset. And with some {\hyperref[\detokenize{glossary:term-DataLad-extension}]{\sphinxtermref{\DUrole{xref,std,std-term}{datalad extension}}}}s third party storage services can host Git repositories in addition to annexed contents.}\label{\detokenize{basics/101-138-sharethirdparty:id6}}\label{\detokenize{basics/101-138-sharethirdparty:fig-specialpublishing}}\end{figure}


\subsubsection{The uncommon case: Special remotes with repository hosting support}
\label{\detokenize{basics/101-138-sharethirdparty:the-uncommon-case-special-remotes-with-repository-hosting-support}}
\sphinxAtStartPar
Typically, storage hosting services such as cloud storage providers do not provide
the ability to host Git repositories.
Therefore, it is typically not possible to \sphinxcode{\sphinxupquote{datalad clone}} from a cloud storage.
However, a number of {\hyperref[\detokenize{glossary:term-DataLad-extension}]{\sphinxtermref{\DUrole{xref,std,std-term}{datalad extension}}}}s have been created that equip cloud storage providers with the ability to also host Git repositories, as \hyperref[\detokenize{basics/101-138-sharethirdparty:fig-specialpublishing}]{Fig.\@ \ref{\detokenize{basics/101-138-sharethirdparty:fig-specialpublishing}}} illustrates.
While they do not get the ability to display repositories the same way that pure
Git repository hosting services like GitHub do, they do get the super power of becoming clonable.

\sphinxAtStartPar
One example for this is the Open Science Framework, which can become the home of datasets by using the \sphinxhref{https://docs.datalad.org/projects/osf}{datalad\sphinxhyphen{}osf extension}.
As long as you and your collaborators have the extension installed, annexed dataset
contents and the Git repository part of your dataset can be pushed or cloned in one go.

\sphinxAtStartPar
Please take a look at the documentation and tutorials of the \sphinxhref{https://docs.datalad.org/projects/osf}{datalad\sphinxhyphen{}osf extension} for examples and more information.


\subsubsection{The creative case: Ensuring availability using only repository hosting}
\label{\detokenize{basics/101-138-sharethirdparty:the-creative-case-ensuring-availability-using-only-repository-hosting}}
\sphinxAtStartPar
When you only want to use pure Git repository hosting services without annex support, you can still allow others to obtain (some) file contents with some creativity:

\sphinxAtStartPar
For one, you can use commands such as \sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}} or \sphinxcode{\sphinxupquote{datalad addurls}}  to retrieve files from web sources and register their location automatically.
The first Chapter {\hyperref[\detokenize{basics/basics-datasets:chapter-datasets}]{\sphinxcrossref{\DUrole{std,std-ref}{DataLad datasets}}}} (\autopageref*{\detokenize{basics/basics-datasets:chapter-datasets}}) demonstrates \sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}}.

\sphinxAtStartPar
Other than this, you can rely on digital provenance in the form of {\hyperref[\detokenize{glossary:term-run-record}]{\sphinxtermref{\DUrole{xref,std,std-term}{run record}}}}s that allow consumers of your dataset to recompute a result instead of \sphinxcode{\sphinxupquote{datalad get}}ing it.
The midterm\sphinxhyphen{}project example in section {\hyperref[\detokenize{basics/101-130-yodaproject:yoda-project}]{\sphinxcrossref{\DUrole{std,std-ref}{YODA\sphinxhyphen{}compliant data analysis projects}}}} (\autopageref*{\detokenize{basics/101-130-yodaproject:yoda-project}}) has been an example for this.


\subsubsection{The static case: Exporting dataset snapshots}
\label{\detokenize{basics/101-138-sharethirdparty:the-static-case-exporting-dataset-snapshots}}
\sphinxAtStartPar
While DataLad datasets have the great advantage that they carry a history with all kinds of useful digital provenance and previous versions of files, it may not in all cases be necessary to make use of this advantage.
Sometimes, you may just want to share or archive the most recent state of the dataset as a snapshot.

\sphinxAtStartPar
DataLad provides the ability to do this out of the box to arbitrary locations, and support for specific services such as \sphinxhref{https://figshare.com}{Figshare} that you can read more about in the web version of this book.
Other than that, some {\hyperref[\detokenize{glossary:term-DataLad-extension}]{\sphinxtermref{\DUrole{xref,std,std-term}{datalad extension}}}}s allow an export to additional services such as the Open Science Framework.


\subsection{General information on publishing datasets}
\label{\detokenize{basics/101-138-sharethirdparty:general-information-on-publishing-datasets}}
\sphinxAtStartPar
Beyond concrete examples of distributing datasets, some general information may be useful in addition:
The section {\hyperref[\detokenize{basics/101-141-push:push}]{\sphinxcrossref{\DUrole{std,std-ref}{The datalad push command}}}} (\autopageref*{\detokenize{basics/101-141-push:push}}) illustrates the DataLad command \sphinxcode{\sphinxupquote{datalad push}}, a command that handles every publication operation, regardless of the type of published content or its destination.
In addition to this, the section {\hyperref[\detokenize{basics/101-139-privacy:privacy}]{\sphinxcrossref{\DUrole{std,std-ref}{Keeping (some) dataset contents private}}}} (\autopageref*{\detokenize{basics/101-139-privacy:privacy}}) contains tips and strategies on publishing datasets without leaking potentially private contents or information.

\sphinxstepscope

\index{push to Git hosting@\spxentry{push to Git hosting}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!push to Git hosting@\spxentry{push to Git hosting}}\ignorespaces 

\section{Publishing datasets to Git repository hosting}
\label{\detokenize{basics/101-139-hostingservices:publishing-datasets-to-git-repository-hosting}}\label{\detokenize{basics/101-139-hostingservices:share-hostingservice}}\label{\detokenize{basics/101-139-hostingservices:index-0}}\label{\detokenize{basics/101-139-hostingservices::doc}}
\sphinxAtStartPar
Because DataLad datasets are {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} repositories, it is possible to
\sphinxcode{\sphinxupquote{datalad push}} datasets to any Git repository hosting service, such as
{\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}, {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}, {\hyperref[\detokenize{glossary:term-GIN}]{\sphinxtermref{\DUrole{xref,std,std-term}{GIN}}}}, {\hyperref[\detokenize{glossary:term-Bitbucket}]{\sphinxtermref{\DUrole{xref,std,std-term}{Bitbucket}}}}, \sphinxhref{https://gogs.io}{Gogs}, or \sphinxhref{https://about.gitea.com}{Gitea}.
These published datasets are ordinary {\hyperref[\detokenize{glossary:term-sibling}]{\sphinxtermref{\DUrole{xref,std,std-term}{sibling}}}}s of your dataset, and among other advantages, they can constitute a back\sphinxhyphen{}up, an entry\sphinxhyphen{}point to retrieve your dataset for others or yourself, the backbone for collaboration on datasets, or the means to enhance visibility, findability and citeability of your work%
\begin{footnote}[1]\sphinxAtStartFootnote
Many repository hosting services have useful features to make your work citeable.
For example, {\hyperref[\detokenize{glossary:term-GIN}]{\sphinxtermref{\DUrole{xref,std,std-term}{gin}}}} is able to assign a {\hyperref[\detokenize{glossary:term-DOI}]{\sphinxtermref{\DUrole{xref,std,std-term}{DOI}}}} to your dataset, and GitHub allows \sphinxcode{\sphinxupquote{CITATION.cff}} files. At the same time, archival services such as \sphinxhref{https://zenodo.org}{Zenodo} often integrate with published repositories, allowing you to preserve your dataset with them.
%
\end{footnote}.
This section contains a brief overview on how to publish your dataset to different services.


\subsection{Git repository hosting and annexed data}
\label{\detokenize{basics/101-139-hostingservices:git-repository-hosting-and-annexed-data}}
\sphinxAtStartPar
As outlined in a number of sections before, Git repository hosting sites typically do not support dataset annexes \sphinxhyphen{} some, like {\hyperref[\detokenize{glossary:term-GIN}]{\sphinxtermref{\DUrole{xref,std,std-term}{GIN}}}} however, do.
Depending on whether or not an annex is supported, you can push either only your Git history to the sibling, or the complete dataset including annexed file contents.
You can find out whether a sibling on a remote hosting services carries an annex or not by running the \sphinxcode{\sphinxupquote{datalad siblings}} command.
A \sphinxcode{\sphinxupquote{+}}, \sphinxcode{\sphinxupquote{\sphinxhyphen{}}}, or \sphinxcode{\sphinxupquote{?}} sign in parenthesis indicates whether the sibling carries an annex, does not carry an annex, or whether this information isn’t yet known.
In the example below you can see that the public GitHub repository \sphinxhref{https://github.com/psychoinformatics-de/studyforrest-data-phase2}{github.com/psychoinformatics\sphinxhyphen{}de/studyforrest\sphinxhyphen{}data\sphinxhyphen{}phase2} does not carry an annex on GitHub (the sibling \sphinxcode{\sphinxupquote{origin}}), but that the annexed data are served from an additional sibling \sphinxcode{\sphinxupquote{mddatasrc}} (a {\hyperref[\detokenize{glossary:term-special-remote}]{\sphinxtermref{\DUrole{xref,std,std-term}{special remote}}}} with annex support).
Even though the dataset sibling on GitHub does not serve the data, it constitutes a simple, findable access point to retrieve the dataset, and can be used to provide updates and fixes via {\hyperref[\detokenize{glossary:term-pull-request}]{\sphinxtermref{\DUrole{xref,std,std-term}{pull request}}}}s, issues, etc.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} a clone of github/psychoinformatics/studyforrest\PYGZhy{}data\PYGZhy{}phase2 has the following siblings:}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }siblings
\PYG{g+go}{.: here(+) [git]}
\PYG{g+go}{.: mddatasrc(+)  [https://datapub.fz\PYGZhy{}juelich.de/studyforrest/studyforrest/phase2/.git (git)]}
\PYG{g+go}{.: origin(\PYGZhy{}) [git@github.com:psychoinformatics\PYGZhy{}de/studyforrest\PYGZhy{}data\PYGZhy{}phase2.git (git)]}
\end{sphinxVerbatim}

\sphinxAtStartPar
There are multiple ways to create a dataset sibling on a repository hosting site to push your dataset to.


\subsection{How to add a sibling on a Git repository hosting site: The manual way}
\label{\detokenize{basics/101-139-hostingservices:how-to-add-a-sibling-on-a-git-repository-hosting-site-the-manual-way}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Create a new repository via the webinterface of the hosting service of your choice. Their webinterface usually has an intuitive interface for this.
The new repository does not need to have the same name as your local dataset, but it helps to associate local dataset and remote siblings.

\item {} 
\sphinxAtStartPar
Afterwards, copy the {\hyperref[\detokenize{glossary:term-SSH}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH}}}} or {\hyperref[\detokenize{glossary:term-https}]{\sphinxtermref{\DUrole{xref,std,std-term}{HTTPS}}}} URL of the repository. Usually, repository hosting services will provide you with a convenient way to copy it to your clipboard. An SSH URL takes the form \sphinxcode{\sphinxupquote{git@\textless{}hosting\sphinxhyphen{}service\textgreater{}:/\textless{}user\textgreater{}/\textless{}repo\sphinxhyphen{}name\textgreater{}.git}} and an HTTPS URL takes the form \sphinxcode{\sphinxupquote{https://\textless{}hosting\sphinxhyphen{}service\textgreater{}/\textless{}user\textgreater{}/\textless{}repo\sphinxhyphen{}name\textgreater{}.git}}. The type of URL you choose determines whether and how you will be able to \sphinxcode{\sphinxupquote{push}} to your repository. Note that many services will require you to use the SSH URL to your repository in order to do \sphinxcode{\sphinxupquote{datalad push}} operations, so make sure to take the {\hyperref[\detokenize{glossary:term-SSH}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH}}}} and not the {\hyperref[\detokenize{glossary:term-https}]{\sphinxtermref{\DUrole{xref,std,std-term}{HTTPS}}}} URL if this is the case.

\item {} 
\sphinxAtStartPar
If you pick the {\hyperref[\detokenize{glossary:term-SSH}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH}}}} URL, make sure to have an {\hyperref[\detokenize{glossary:term-SSH-key}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH key}}}} set up. This usually requires generating an SSH key pair if you do not have one yet, and uploading the public key to the repository hosting service. The \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-sshkey}} {\hyperref[\detokenize{basics/101-139-hostingservices:fom-sshkey}]{\sphinxcrossref{\DUrole{std,std-ref}{on SSH keys}}}} (\autopageref*{\detokenize{basics/101-139-hostingservices:fom-sshkey}}) points to a useful tutorial for this.

\item {} 
\sphinxAtStartPar
Use the URL to add the repository as a sibling. There are two commands that allow you to do that; both require you give the sibling a name of your choice (common name choices are \sphinxcode{\sphinxupquote{upstream}}, or a short\sphinxhyphen{}cut for your user name or the hosting platform, but its completely up to you to decide):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{git remote add \textless{}name\textgreater{} \textless{}url\textgreater{}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad siblings add \sphinxhyphen{}\sphinxhyphen{}dataset . \sphinxhyphen{}\sphinxhyphen{}name \textless{}name\textgreater{} \sphinxhyphen{}\sphinxhyphen{}url \textless{}url\textgreater{}}}

\end{enumerate}

\item {} 
\sphinxAtStartPar
Push your dataset to the new sibling: \sphinxcode{\sphinxupquote{datalad push \sphinxhyphen{}\sphinxhyphen{}to \textless{}name\textgreater{}}}

\end{enumerate}

\index{concepts@\spxentry{concepts}!SSH key@\spxentry{SSH key}}\index{SSH@\spxentry{SSH}!key@\spxentry{key}}\ignorespaces \phantomsection\label{\detokenize{basics/101-139-hostingservices:sshkey}}\begin{findoutmore}[label={fom-sshkey}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{What is an SSH key and how can I create one?}
\label{\detokenize{basics/101-139-hostingservices:fom-sshkey}}

\sphinxAtStartPar
An SSH key is an access credential in the {\hyperref[\detokenize{glossary:term-SSH}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH}}}} protocol that can be used
to login from one system to remote servers and services, such as from your private
computer to an {\hyperref[\detokenize{glossary:term-SSH-server}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH server}}}}. For repository hosting services such as {\hyperref[\detokenize{glossary:term-GIN}]{\sphinxtermref{\DUrole{xref,std,std-term}{GIN}}}},
{\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}, or {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}, it can be used to connect and authenticate
without supplying your username or password for each action.

\sphinxAtStartPar
A tutorial by GitHub at \sphinxhref{https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent}{docs.github.com/en/github/authenticating\sphinxhyphen{}to\sphinxhyphen{}github/connecting\sphinxhyphen{}to\sphinxhyphen{}github\sphinxhyphen{}with\sphinxhyphen{}ssh}
has a detailed step\sphinxhyphen{}by\sphinxhyphen{}step instruction to generate and use SSH keys for authentication.
You will also learn how add your public SSH key to your hosting service account
so that you can install or clone datasets or Git repositories via \sphinxcode{\sphinxupquote{SSH}} (in addition
to the \sphinxcode{\sphinxupquote{http}} protocol).

\sphinxAtStartPar
Don’t be intimidated if you have never done this before \textendash{} it is fast and easy:
First, you need to create a private and a public key (an SSH key pair).
All this takes is a single command in the terminal. The resulting files are
text files that look like someone spilled alphabet soup in them, but constitute
a secure password procedure.
You keep the private key on your own machine (the system you are connecting from,
and that \sphinxstylestrong{only you have access to}),
and copy the public key to the system or service you are connecting to.
On the remote system or service, you make the public key an \sphinxstyleemphasis{authorized key} to
allow authentication via the SSH key pair instead of your password. This
either takes a single command in the terminal, or a few clicks in a web interface
to achieve.
You should protect your SSH keys on your machine with a passphrase to prevent
others \textendash{} e.g., in case of theft \textendash{} to log in to servers or services with
SSH authentication%
\begin{footnote}[2]\sphinxAtStartFootnote
Your private SSH key is incredibly valuable, and it is important to keep
it secret!
Anyone who gets your private key has access to anything that the public key
is protecting. If the private key does not have a passphrase, simply copying
this file grants a person access!
%
\end{footnote}, and configure an \sphinxcode{\sphinxupquote{ssh agent}}
to handle this passphrase for you with a single command. How to do all of this
is detailed in the tutorial.


\end{findoutmore}


\subsection{How to add a sibling on a Git repository hosting site: The automated way}
\label{\detokenize{basics/101-139-hostingservices:how-to-add-a-sibling-on-a-git-repository-hosting-site-the-automated-way}}
\sphinxAtStartPar
DataLad provides \sphinxcode{\sphinxupquote{create\sphinxhyphen{}sibling\sphinxhyphen{}*}} commands to automatically create datasets on certain hosting sites.
You can automatically create new repositories from the command line for {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}, {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}, {\hyperref[\detokenize{glossary:term-GIN}]{\sphinxtermref{\DUrole{xref,std,std-term}{GIN}}}}, \sphinxhref{https://gogs.io}{Gogs}, or \sphinxhref{https://about.gitea.com}{Gitea}.
This is implemented with a set of commands called \sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}github}}, \sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}gitlab}}, \sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}gin}}, \sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}gogs}}, and \sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}gitea}}.

\sphinxAtStartPar
Each command is slightly tuned towards the peculiarities of each particular platform, but the most important common parameters are streamlined across commands as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}REPONAME{]}}} (required): The name of the repository on the hosting site. It will be created under a user’s namespace, unless this argument includes an organization name prefix. For example, \sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}github my\sphinxhyphen{}awesome\sphinxhyphen{}repo}} will create a new repository under \sphinxcode{\sphinxupquote{github.com/\textless{}user\textgreater{}/my\sphinxhyphen{}awesome\sphinxhyphen{}repo}}, while \sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}github \textless{}orgname\textgreater{}/my\sphinxhyphen{}awesome\sphinxhyphen{}repo}} will create a new repository of this name under the GitHub organization \sphinxcode{\sphinxupquote{\textless{}orgname\textgreater{}}} (given appropriate permissions).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}s/\sphinxhyphen{}\sphinxhyphen{}name \textless{}name\textgreater{}}} (required): A name under which the sibling is identified. By default, it will be based on or similar to the hosting site. For example, the sibling created with \sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}github}} will  be called \sphinxcode{\sphinxupquote{github}} by default.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}credential \textless{}name\textgreater{}}} (optional): Credentials used for authentication are stored internally by DataLad under specific names. These names allow you to have multiple credentials, and flexibly decide which one to use. When \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}credential \textless{}name\textgreater{}}} is the name of an existing credential, DataLad tries to authenticate with the specified credential; when it does not yet exist DataLad will prompt interactively for a credential, such as an access token, and store it under the given \sphinxcode{\sphinxupquote{\textless{}name\textgreater{}}} for future authentications. By default, DataLad will name a credential according to the hosting service URL it used for, such as \sphinxcode{\sphinxupquote{datalad\sphinxhyphen{}api.github.com}} as the default for credentials used to authenticate against GitHub.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}access\sphinxhyphen{}protocol \{https|ssh|https\sphinxhyphen{}ssh\}}} (default \sphinxcode{\sphinxupquote{https}}): Whether to use {\hyperref[\detokenize{glossary:term-SSH}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH}}}} or {\hyperref[\detokenize{glossary:term-https}]{\sphinxtermref{\DUrole{xref,std,std-term}{HTTPS}}}} URLs, or a hybrid version in which HTTPS is used to \sphinxstyleemphasis{pull} and SSH is used to \sphinxstyleemphasis{push}. Using {\hyperref[\detokenize{glossary:term-SSH}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH}}}} URLs requires an {\hyperref[\detokenize{glossary:term-SSH-key}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH key}}}} setup, but is a very convenient authentication method, especially when pushing updates \textendash{} which would need manual input on user name and token with every \sphinxcode{\sphinxupquote{push}} over HTTPS.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dry\sphinxhyphen{}run}} (optional): With this flag set, the command will not actually create the target repository, but only perform tests for name collisions and report repository name(s).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}private}} (optional): A switch that, if set, makes sure that the created repository is private.

\end{itemize}

\sphinxAtStartPar
Other streamlined arguments, such as \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}recursive}} or \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}publish\sphinxhyphen{}depends}} allow you to perform more complex configurations, such as publication of dataset hierarchies or connections to {\hyperref[\detokenize{glossary:term-special-remote}]{\sphinxtermref{\DUrole{xref,std,std-term}{special remote}}}}s.
The web version of this book demonstrates several of them.

\sphinxAtStartPar
Self\sphinxhyphen{}hosted repository services, e.g., Gogs or Gitea instances, have an additional required argument, the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}api}} flag.
It needs to point to the URL of the instance, for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }create\PYGZhy{}sibling\PYGZhy{}gogs\PYG{+w}{ }my\PYGZus{}repo\PYGZus{}on\PYGZus{}gogs\PYG{+w}{  }\PYGZhy{}\PYGZhy{}api\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}https://try.gogs.io\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
{\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}’s internal organization differs from that of the other hosting services, and as there are multiple different GitLab instances, \sphinxcode{\sphinxupquote{create\sphinxhyphen{}sibling\sphinxhyphen{}gitlab}} requires slightly more configuration than the other commands.
Thus, a short walk\sphinxhyphen{}through is available in the online\sphinxhyphen{}handbook.


\subsection{Authentication by token}
\label{\detokenize{basics/101-139-hostingservices:authentication-by-token}}\label{\detokenize{basics/101-139-hostingservices:token}}
\sphinxAtStartPar
To create or update repositories on remote hosting services you will need to set up appropriate authentication and permissions.
In most cases, this will be in the form of an authorization token with a specific permission scope.


\subsubsection{What is a token?}
\label{\detokenize{basics/101-139-hostingservices:what-is-a-token}}
\sphinxAtStartPar
Personal access tokens are an alternative to authenticating via your password, and take the form of a long character string, associated with a human\sphinxhyphen{}readable name or description.
If you are prompted for \sphinxcode{\sphinxupquote{username}} and \sphinxcode{\sphinxupquote{password}} in the command line, you would enter your token in place of the \sphinxcode{\sphinxupquote{password}}%
\begin{footnote}[3]\sphinxAtStartFootnote
GitHub \sphinxhref{https://developer.github.com/changes/2020-02-14-deprecating-password-auth}{deprecated user\sphinxhyphen{}password authentication} in favor of authentication via personal access token. Supplying a password instead of a token will fail to authenticate.
%
\end{footnote}.
Note that you do not have to type your token at every authentication \textendash{} your token will be stored on your system the first time you have used it and automatically reused whenever relevant. Check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-credential-storage}} {\hyperref[\detokenize{basics/101-139-hostingservices:fom-credential-storage}]{\sphinxcrossref{\DUrole{std,std-ref}{on credential storage}}}} (\autopageref*{\detokenize{basics/101-139-hostingservices:fom-credential-storage}}) to learn how this is done.

\index{credential@\spxentry{credential}!storage@\spxentry{storage}}\ignorespaces \begin{findoutmore}[label={fom-credential-storage}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Where are credentials stored?}
\label{\detokenize{basics/101-139-hostingservices:fom-credential-storage}}

\sphinxAtStartPar
Passwords, user names, tokens, or any other login information is stored in
your system’s (encrypted) \sphinxhref{https://en.wikipedia.org/wiki/GNOME\_Keyring}{keyring}.
It is a built\sphinxhyphen{}in credential store, used in all major operating systems, and
can store credentials securely.


\end{findoutmore}

\sphinxAtStartPar
You can have multiple tokens, and each of them can get a different scope of permissions, but it is important to treat your tokens like passwords and keep them secret.


\subsubsection{Which permissions do they need?}
\label{\detokenize{basics/101-139-hostingservices:which-permissions-do-they-need}}
\sphinxAtStartPar
The most convenient way to generate tokens is typically via the webinterface of the hosting service of your choice.
For creating and updating repositories with DataLad commands it is usually sufficient to grant only repository\sphinxhyphen{}related permissions.
However, broader permission sets may also make sense.
Should you employ GitHub workflows, for example, a token without “workflow” scope could not push changes to workflow files, resulting in errors like this one:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{[remote rejected] (refusing to allow a Personal Access Token to create or update workflow `.github/workflows/benchmarks.yml` without `workflow` scope)]}
\end{sphinxVerbatim}

\sphinxstepscope

\index{sensitive data handling@\spxentry{sensitive data handling}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!sensitive data handling@\spxentry{sensitive data handling}}\ignorespaces 

\section{Keeping (some) dataset contents private}
\label{\detokenize{basics/101-139-privacy:keeping-some-dataset-contents-private}}\label{\detokenize{basics/101-139-privacy:privacy}}\label{\detokenize{basics/101-139-privacy:index-0}}\label{\detokenize{basics/101-139-privacy::doc}}
\sphinxAtStartPar
Datasets can contain information that you don’t want to share with others.
Maybe the collection of pictures from your team\sphinxhyphen{}building event also contains those after\sphinxhyphen{}hour photos where you drunkenly kidnapped a tram.
Or you are handling data with strict privacy requirements, such as patient data or
medical imaging files.
Whatever it may be, this short section summarizes strategies that help you to ensure
to private information is not leaked, even when you publicly share datasets that contain it.


\subsection{Strategy 1: Never save private information to Git}
\label{\detokenize{basics/101-139-privacy:strategy-1-never-save-private-information-to-git}}
\sphinxAtStartPar
The most important strategy to keep in mind in handling datasets with potentially sensitive information is to \sphinxstylestrong{never save sensitive information into Git}. \sphinxstylestrong{NEVER}.
Saving sensitive information into a dataset or Git repository that you intend to share is the equivalent of including your account password as an attachment to every email you write \textendash{} you don’t necessarily point out that there is private information, but it lies around for everyone to accidentally find.
Once a file with sensitive contents has been saved in the version history, sharing this dataset may accidentally expose the sensitive information even if it has been removed in the most recent version \textendash{} the transparent revision history of a dataset allows to simply restore the file.

\sphinxAtStartPar
Thus, make sure to always manage sensitive files with {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}, even if the file is just a small text file.
Having the file annexed allows you to specifically not share its contents, even when you make your dataset publicly available.
However, it is highly important to realize that while annexed file’s \sphinxstyleemphasis{contents} are not saved into Git, annex file’s \sphinxstyleemphasis{names} are.
If private information such as a medical patients non\sphinxhyphen{}anonymized ID or other potentially identifying information becomes a part of the file name, this information is exposed in the Git history of the dataset.
Keep in mind that this applies even if you renamed the file.
Check the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-uncommit}} {\hyperref[\detokenize{basics/101-139-privacy:fom-uncommit}]{\sphinxcrossref{\DUrole{std,std-ref}{on removing information committed to Git}}}} (\autopageref*{\detokenize{basics/101-139-privacy:fom-uncommit}}) in case sensitive would ever leak into one of your datasets.

\index{remove sensitive information@\spxentry{remove sensitive information}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!remove sensitive information@\spxentry{remove sensitive information}}\ignorespaces \begin{findoutmore}[label={fom-uncommit}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Help! I accidentally saved sensitive information to Git!}
\label{\detokenize{basics/101-139-privacy:fom-uncommit}}

\sphinxAtStartPar
The only lasting way to remove contents from the dataset history completely is to substantially rewrite the dataset’s history via tools such as \sphinxcode{\sphinxupquote{git\sphinxhyphen{}filter\sphinxhyphen{}repo}} or \sphinxcode{\sphinxupquote{git filter\sphinxhyphen{}branch}}, two very dangerous and potentially destructive operations.


\end{findoutmore}


\subsection{Strategy 2: Restrict access via third party service or file system permissions}
\label{\detokenize{basics/101-139-privacy:strategy-2-restrict-access-via-third-party-service-or-file-system-permissions}}
\sphinxAtStartPar
When you have a dataset and only authorized actors should be allowed to access it,
it is possible to set access restrictions simply via choice of (third party) storage permissions.
When it is an access restricted dataset on shared infrastructure, for example, a scientific dataset that only researchers who signed a data usage agreement should have access to, it could suffice to create specific \sphinxhref{https://en.wikipedia.org/wiki/Group\_identifier}{Unix groups} with authorized users, and give only those groups the necessary permissions.
Depending on what permissions are set, unauthorized actors would not be able to retrieve file contents, or be able to clone the dataset at all.

\sphinxAtStartPar
The ability of repository hosting services to make datasets private and only allow select collaborators access is yet another method of keeping complete datasets as private as necessary, even though you should think twice on whether or not you should host sensitive repositories at all on these services.

\sphinxAtStartPar
One method to exert potentially fine\sphinxhyphen{}grained access control over file contents is via choice of (third party) hosting service for some or all annexed file contents.
If you chose a service only selected people have access to, and publish annexed contents exclusively there, then only those selected people can perform a successful \sphinxcode{\sphinxupquote{datalad get}}.
For example, when it is a dataset with content hosted on third party cloud storage such as S3 buckets, permission settings in the storage locations would allow data providers to specify or limit who is able to retrieve the file contents.


\subsection{Strategy 3: Selective publishing}
\label{\detokenize{basics/101-139-privacy:strategy-3-selective-publishing}}
\sphinxAtStartPar
If it is individual files that you do not want to share, you can selectively publish the contents of all files you want others to have, and withhold the data of the files you do not want to share.
This can be done by providing paths to the data that should be published, or a \sphinxhref{https://git-annex.branchable.com/git-annex-wanted}{git\sphinxhyphen{}annex\sphinxhyphen{}wanted} configuration and the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}data auto}} option.

\sphinxAtStartPar
Let’s say you have a dataset with three files:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{experiment.txt}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subject\_1.dat}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subject\_2.data}}

\end{itemize}

\sphinxAtStartPar
Consider that all of these files are annexed. While the information in \sphinxcode{\sphinxupquote{experiment.txt}} is fine for everyone to see, \sphinxcode{\sphinxupquote{subject\_1.dat}} and \sphinxcode{\sphinxupquote{subject\_2.dat}} contain personal and potentially identifying data that cannot be shared.
Nevertheless, you want collaborators to know that these files exist.
By publishing only the file contents of \sphinxcode{\sphinxupquote{experiment.txt}} with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }push\PYG{+w}{ }\PYGZhy{}\PYGZhy{}to\PYG{+w}{ }github\PYG{+w}{ }experiment.txt
\end{sphinxVerbatim}

\sphinxAtStartPar
only meta data about file availability of \sphinxcode{\sphinxupquote{subject\_1.dat}} and \sphinxcode{\sphinxupquote{subject\_2.dat}} exists, but as these files’ annexed data is not published, a \sphinxcode{\sphinxupquote{datalad get}}
will fail.
Note, though, that \sphinxcode{\sphinxupquote{datalad push}} will publish the complete dataset history (unless you specify a commit range with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}since}} option \textendash{} see the \sphinxhref{https://docs.datalad.org/en/latest/generated/man/datalad-push.html}{manual} for more information).

\sphinxstepscope

\index{push@\spxentry{push}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!push@\spxentry{push}}\index{distribute dataset@\spxentry{distribute dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!distribute dataset@\spxentry{distribute dataset}}\ignorespaces 

\section{The datalad push command}
\label{\detokenize{basics/101-141-push:the-datalad-push-command}}\label{\detokenize{basics/101-141-push:push}}\label{\detokenize{basics/101-141-push:index-0}}\label{\detokenize{basics/101-141-push::doc}}
\sphinxAtStartPar
Previous contents on publishing DataLad datasets have each
shown you crucial aspects of the functions of dataset publishing with
\sphinxcode{\sphinxupquote{datalad push}}. This section wraps them all together.


\subsection{The general overview}
\label{\detokenize{basics/101-141-push:the-general-overview}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad push}} is the command to turn to when you want to publish datasets.
It is capable of publishing all dataset content, i.e., files stored in {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}},
and files stored with {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}, to a known dataset {\hyperref[\detokenize{glossary:term-sibling}]{\sphinxtermref{\DUrole{xref,std,std-term}{sibling}}}}.

\index{push@\spxentry{push}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!push@\spxentry{push}}\ignorespaces \begin{gitusernote}[label={index-1}, before title={\thetcbcounter\ }, check odd page=true]{Push internals}
\label{\detokenize{basics/101-141-push:index-1}}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{datalad push}} uses \sphinxcode{\sphinxupquote{git push}}, and \sphinxcode{\sphinxupquote{git annex copy}} under
the hood. Publication targets need to either be configured remote Git repositories,
or git\sphinxhyphen{}annex special remotes (if they support data upload).


\end{gitusernote}

\sphinxAtStartPar
In order to publish a dataset, the dataset needs to have a sibling to push to.
This, for instance, can be a {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}, {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}, or {\hyperref[\detokenize{glossary:term-GIN}]{\sphinxtermref{\DUrole{xref,std,std-term}{GIN}}}}
repository, but it can also be a Remote Indexed Archive (RIA) store for backup
or storage of datasets%
\begin{footnote}[1]\sphinxAtStartFootnote
RIA siblings are file system based, scalable storage solutions for
DataLad datasets. You can find out more about them in the online\sphinxhyphen{}handbook.
%
\end{footnote}, or a regular clone.
See the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-all-siblings}} {\hyperref[\detokenize{basics/101-141-push:fom-all-siblings}]{\sphinxcrossref{\DUrole{std,std-ref}{on configuring siblings}}}} (\autopageref*{\detokenize{basics/101-141-push:fom-all-siblings}}) for an overview.

\index{create\sphinxhyphen{}sibling\sphinxhyphen{}github@\spxentry{create\sphinxhyphen{}sibling\sphinxhyphen{}github}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!create\sphinxhyphen{}sibling\sphinxhyphen{}github@\spxentry{create\sphinxhyphen{}sibling\sphinxhyphen{}github}}\index{create\sphinxhyphen{}sibling\sphinxhyphen{}gitlab@\spxentry{create\sphinxhyphen{}sibling\sphinxhyphen{}gitlab}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!create\sphinxhyphen{}sibling\sphinxhyphen{}gitlab@\spxentry{create\sphinxhyphen{}sibling\sphinxhyphen{}gitlab}}\index{create\sphinxhyphen{}sibling\sphinxhyphen{}ria@\spxentry{create\sphinxhyphen{}sibling\sphinxhyphen{}ria}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!create\sphinxhyphen{}sibling\sphinxhyphen{}ria@\spxentry{create\sphinxhyphen{}sibling\sphinxhyphen{}ria}}\index{GitHub@\spxentry{GitHub}!dataset hosting@\spxentry{dataset hosting}}\index{dataset hosting@\spxentry{dataset hosting}!GitHub@\spxentry{GitHub}}\index{GitLab@\spxentry{GitLab}!dataset hosting@\spxentry{dataset hosting}}\index{dataset hosting@\spxentry{dataset hosting}!GitLab@\spxentry{GitLab}}\index{RIA@\spxentry{RIA}!dataset hosting@\spxentry{dataset hosting}}\index{dataset hosting@\spxentry{dataset hosting}!RIA@\spxentry{RIA}}\index{create sibling@\spxentry{create sibling}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!create sibling@\spxentry{create sibling}}\ignorespaces \begin{findoutmore}[label={fom-all-siblings}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{All of the ways to configure siblings}
\label{\detokenize{basics/101-141-push:fom-all-siblings}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Add an existing repository as a sibling with the \sphinxcode{\sphinxupquote{datalad siblings}}
command. Here are common examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} to a remote repository}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }siblings\PYG{+w}{ }add\PYG{+w}{ }\PYGZhy{}\PYGZhy{}name\PYG{+w}{ }github\PYGZhy{}repo\PYG{+w}{ }\PYGZhy{}\PYGZhy{}url\PYG{+w}{ }\PYGZlt{}url.to.github\PYGZgt{}
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} to a local path}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }siblings\PYG{+w}{ }add\PYG{+w}{ }\PYGZhy{}\PYGZhy{}name\PYG{+w}{ }local\PYGZhy{}sibling\PYG{+w}{ }\PYGZhy{}\PYGZhy{}url\PYG{+w}{ }/path/to/sibling/ds
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} to a clone on an SSH\PYGZhy{}accessible machine}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }siblings\PYG{+w}{ }add\PYG{+w}{ }\PYGZhy{}\PYGZhy{}name\PYG{+w}{ }server\PYGZhy{}sibling\PYG{+w}{ }\PYGZhy{}\PYGZhy{}url\PYG{+w}{ }\PYG{o}{[}user@\PYG{o}{]}hostname:/path/to/sibling/ds
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Create a sibling on an external hosting service from scratch, right from
within your repository:
This can be done with the commands \sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}github}} (for GitHub)
or \sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}siblings\sphinxhyphen{}gitlab}} (for GitLab), or
\sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}ria}} (for a remote indexed archive dataset store).
Note that \sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}ria}} can add an existing store as a sibling
or create a new one from scratch.

\item {} 
\sphinxAtStartPar
Create a sibling on a local or SSH accessible Unix machine with
\sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling}}.

\end{itemize}


\end{findoutmore}

\sphinxAtStartPar
In order to publish dataset content, DataLad needs to know to which sibling
content shall be pushed. This can be specified with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}to}} option directly
from the command line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }push\PYG{+w}{ }\PYGZhy{}\PYGZhy{}to\PYG{+w}{ }\PYGZlt{}sibling\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you have more than one {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} in your dataset, note that a
\sphinxcode{\sphinxupquote{datalad push}} command will by default update only the current branch.
If updating multiple branches is relevant for your workflow, please check out
the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-push-branch}} {\hyperref[\detokenize{basics/101-141-push:fom-push-branch}]{\sphinxcrossref{\DUrole{std,std-ref}{about this}}}} (\autopageref*{\detokenize{basics/101-141-push:fom-push-branch}}).

\sphinxAtStartPar
By default, \sphinxcode{\sphinxupquote{datalad push}} will make the last saved state of the dataset
available. Consequently, if the sibling is in the same state as the dataset,
no push is attempted.
Additionally, \sphinxcode{\sphinxupquote{datalad push}} will attempt to automatically decide what type
of dataset contents are going to be published. With a sibling that has a
{\hyperref[\detokenize{glossary:term-special-remote}]{\sphinxtermref{\DUrole{xref,std,std-term}{special remote}}}} configured as a {\hyperref[\detokenize{glossary:term-publication-dependency}]{\sphinxtermref{\DUrole{xref,std,std-term}{publication dependency}}}},
or a sibling that contains an annex (such as a GIN repository or a
{\hyperref[\detokenize{glossary:term-Remote-Indexed-Archive-RIA-store}]{\sphinxtermref{\DUrole{xref,std,std-term}{Remote Indexed Archive (RIA) store}}}}), both the contents
stored in Git (i.e., a dataset’s history) as well as file contents stored in
git\sphinxhyphen{}annex will be published unless dataset configurations overrule this.
Alternatively, one can enforce particular operations or push a subset of dataset
contents. For one, when specifying a path in the \sphinxcode{\sphinxupquote{datalad push}} command,
only data or changes for those paths are considered for a push.
Additionally, one can select a particular mode of operation with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}data}} option.
Several different modes are possible:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nothing}}: With this option, annexed contents are not published. This
means that the sibling will have information on the annexed files’ names, but
file contents will not be available, and thus \sphinxcode{\sphinxupquote{datalad get}} calls in the
sibling would fail.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{anything}}: Transfer all annexed contents.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{auto}}: With this option, the decision which data is transferred is based on configurations that can determine rules on a per\sphinxhyphen{}file and per\sphinxhyphen{}sibling level.
On a technical level, the \sphinxcode{\sphinxupquote{git annex copy}} call to publish file contents is called with its \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}auto}} option.
With this option, only data that satisfies specific git\sphinxhyphen{}annex configurations gets transferred.
Those configurations could be \sphinxcode{\sphinxupquote{numcopies}} settings (the number of copies available at different remotes), or \sphinxcode{\sphinxupquote{wanted}} settings (preferred contents for a specific remote), and need to be created by a user%
\begin{footnote}[2]\sphinxAtStartFootnote
For information on the \sphinxcode{\sphinxupquote{numcopies}} and \sphinxcode{\sphinxupquote{wanted}} settings of git\sphinxhyphen{}annex see its documentation at \sphinxhref{https://git-annex.branchable.com/git-annex-wanted}{git\sphinxhyphen{}annex.branchable.com/git\sphinxhyphen{}annex\sphinxhyphen{}wanted/} and \sphinxhref{https://git-annex.branchable.com/git-annex-numcopies}{git\sphinxhyphen{}annex.branchable.com/git\sphinxhyphen{}annex\sphinxhyphen{}numcopies/}.
%
\end{footnote} with git\sphinxhyphen{}annex commands. If you have files you want to keep private, or do not need published, these configurations are very useful.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{auto\sphinxhyphen{}if\sphinxhyphen{}wanted}} (Default): Unless a \sphinxcode{\sphinxupquote{wanted}} or \sphinxcode{\sphinxupquote{numcopies}} configuration exists in the dataset, all content are published. Should a \sphinxcode{\sphinxupquote{wanted}} or \sphinxcode{\sphinxupquote{numcopies}} configuration exist, the command enables \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}auto}} in the underlying \sphinxcode{\sphinxupquote{git annex copy}} call.

\end{itemize}

\sphinxAtStartPar
Beyond different modes of transferring data, the \sphinxcode{\sphinxupquote{\sphinxhyphen{}f/\sphinxhyphen{}\sphinxhyphen{}force}} option allows to force specific publishing operations with three different modes.
Be careful when using it, as its modes possibly overrule safety protections or optimizations:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{checkdatapresent}}: With this option, the underlying \sphinxcode{\sphinxupquote{git annex copy}} call to
publish file contents is invoked without a \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}fast}} option. Usually, the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}fast}} option increases the speed of the operation, as it disables a check
whether the sibling already has content. This however, might skip copying content
in some cases. Therefore, \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}force datatransfer}} is a slower, but more fail\sphinxhyphen{}safe
option to publish annexed file contents.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gitpush}}: This option triggers a \sphinxcode{\sphinxupquote{git push \sphinxhyphen{}\sphinxhyphen{}force}}. Be very careful using
this option! If the changes on the dataset conflict with the changes that exist
in the sibling, the changes in the sibling will be overwritten.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{all}}: The final mode, \sphinxcode{\sphinxupquote{all}}, combines all force modes \textendash{} thus attempting to really get your dataset contents published by any means.

\end{itemize}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad push}} can publish available subdatasets recursively if the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}r/\sphinxhyphen{}\sphinxhyphen{}recursive}} flag is specified. Note that this requires that all subdatasets
that should be published have sibling names identical to the sibling specified in
the top\sphinxhyphen{}level \sphinxcode{\sphinxupquote{datalad push}} command, or that appropriate default publication
targets are configured throughout the dataset hierarchy.

\index{configure which branches to push@\spxentry{configure which branches to push}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!configure which branches to push@\spxentry{configure which branches to push}}\ignorespaces \begin{findoutmore}[label={fom-push-branch}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Push more than the current branch}
\label{\detokenize{basics/101-141-push:fom-push-branch}}

\sphinxAtStartPar
If you have more than one {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} in your
dataset, a \sphinxcode{\sphinxupquote{datalad push \sphinxhyphen{}\sphinxhyphen{}to \textless{}sibling\textgreater{}}} will by default only push
the current {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}}, \sphinxstyleemphasis{unless} you provide configurations that alter
this default. Here are two ways in which this can be achieved:

\sphinxAtStartPar
\sphinxstylestrong{Option 1:} Setting the \sphinxcode{\sphinxupquote{push.default}} configuration variable from
\sphinxcode{\sphinxupquote{simple}} (the default) to \sphinxcode{\sphinxupquote{matching}} will configure the dataset such that
\sphinxcode{\sphinxupquote{datalad push}} pushes \sphinxstyleemphasis{all} branches to the sibling.
A concrete example: On a dataset level, this can be done using

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}\PYGZhy{}local\PYG{+w}{ }push.default\PYG{+w}{ }matching
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Option 2:}
\sphinxhref{https://git-scm.com/book/en/v2/Git-Internals-The-Refspec}{Tweaking the default push refspec} for the dataset allows to
select a range of branches that should be pushed. The link above gives a
thorough introduction into the refspec. For a hands\sphinxhyphen{}on example, consider how it is done for
\sphinxhref{https://github.com/datalad-handbook/DataLad-101}{the published DataLad\sphinxhyphen{}101 dataset}:

\sphinxAtStartPar
The published version of the DataLad\sphinxhyphen{}101 dataset is known its local clone
as a {\hyperref[\detokenize{glossary:term-remote}]{\sphinxtermref{\DUrole{xref,std,std-term}{remote}}}} called \sphinxcode{\sphinxupquote{public}}, and each section of the book is identified
with a custom branch name that corresponds to the section name. Whenever an
update to the public dataset is pushed, apart from pushing only the \sphinxcode{\sphinxupquote{main}}
branch, all branches starting with the section identifier \sphinxcode{\sphinxupquote{sct}} are pushed
automatically as well. This configuration was achieved by specifying these branches
(using {\hyperref[\detokenize{glossary:term-globbing}]{\sphinxtermref{\DUrole{xref,std,std-term}{globbing}}}} with \sphinxcode{\sphinxupquote{*}}) in the \sphinxcode{\sphinxupquote{push}} specification of this {\hyperref[\detokenize{glossary:term-remote}]{\sphinxtermref{\DUrole{xref,std,std-term}{remote}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}\PYGZhy{}local\PYG{+w}{ }remote.public.push\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}refs/heads/sct*\PYGZsq{}}
\end{sphinxVerbatim}


\end{findoutmore}


\subsection{Pushing errors}
\label{\detokenize{basics/101-141-push:pushing-errors}}
\sphinxAtStartPar
If you are unfamiliar with Git, please be aware that cloning a dataset to a different place and subsequently pushing to it can lead to Git error messages if changes are pushed to a currently checked out {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} of the sibling (in technical Git terms: When pushing to a checked\sphinxhyphen{}out branch of a non\sphinxhyphen{}bare repository remote).
As an example, consider what happens if we attempt a \sphinxcode{\sphinxupquote{datalad push}} to the sibling \sphinxcode{\sphinxupquote{roommate}} that we created in the chapter {\hyperref[\detokenize{basics/basics-collaboration:chapter-collaboration}]{\sphinxcrossref{\DUrole{std,std-ref}{Collaboration}}}} (\autopageref*{\detokenize{basics/basics-collaboration:chapter-collaboration}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }push\PYG{+w}{ }\PYGZhy{}\PYGZhy{}to\PYG{+w}{ }roommate
\PYG{g+go}{copy(ok): books/TLCL.pdf (file) [to roommate...]}
\PYG{g+go}{copy(ok): books/bash\PYGZus{}guide.pdf (file) [to roommate...]}
\PYG{g+go}{copy(ok): books/byte\PYGZhy{}of\PYGZhy{}python.pdf (file) [to roommate...]}
\PYG{g+go}{publish(ok): . (dataset) [refs/heads/git\PYGZhy{}annex\PYGZhy{}\PYGZgt{}roommate:refs/heads/git\PYGZhy{}annex ✂FROM✂..✂TO✂]}
\PYG{g+go}{publish(error): . (dataset) [refs/heads/main\PYGZhy{}\PYGZgt{}roommate:refs/heads/main [remote rejected] (branch is currently checked out)]}
\PYG{g+go}{action summary:}
\PYG{g+go}{  copy (ok: 3)}
\PYG{g+go}{  publish (error: 1, ok: 1)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Publishing fails with the error message \sphinxcode{\sphinxupquote{{[}remote rejected{]} (branch is currently checked out)}}.
This can be prevented with  \sphinxhref{https://github.blog/2015-02-06-git-2-3-has-been-released}{configuration settings} in Git versions 2.3 or higher, or by pushing to a branch of the sibling that is currently not checked\sphinxhyphen{}out.

\sphinxstepscope


\section{Summary}
\label{\detokenize{basics/101-140-summary:summary}}\label{\detokenize{basics/101-140-summary:summaryshare}}\label{\detokenize{basics/101-140-summary::doc}}
\sphinxAtStartPar
Without access to the same computational infrastructure, you can distribute or share your
DataLad datasets with friends and collaborators by leveraging third party
services. DataLad integrates well with a variety of free or commercial services,
and with many available service options this gives you freedom in deciding where
you store your data and thus who can get access.
\begin{itemize}
\item {} 
\sphinxAtStartPar
An easy, free, and fast option is {\hyperref[\detokenize{glossary:term-GIN}]{\sphinxtermref{\DUrole{xref,std,std-term}{GIN}}}}, a
web\sphinxhyphen{}based repository store for scientific data management. If you are registered
and have SSH authentication set up, you can create a new, empty repository,
add it as a sibling to your dataset, and publish all dataset contents \textendash{} including
annexed data, as GIN supports repositories with an annex.

\item {} 
\sphinxAtStartPar
Other repository hosting services such as GitHub and GitLab%
\begin{footnote}[1]\sphinxAtStartFootnote
Older versions of {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}} provide a git\sphinxhyphen{}annex configuration, but it is disabled
by default, and to enable it you would need to have administrative
access to the server and client side of your GitLab instance.
%
\end{footnote} do not support
an annex. If a dataset is shared via one of those platforms, annexed data needs
to be published to an external data store. The published dataset stores
information about where to obtain annexed file contents from such that a
\sphinxcode{\sphinxupquote{datalad get}} works.

\item {} 
\sphinxAtStartPar
The external data store can be any of a variety of third party hosting providers.
To enable data transfer to and from this service, you (may) need to configure an
appropriate {\hyperref[\detokenize{glossary:term-special-remote}]{\sphinxtermref{\DUrole{xref,std,std-term}{special remote}}}}, and configure a publication dependency.

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}data}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}force}} options of \sphinxcode{\sphinxupquote{datalad push}} allows to override
automatic decision making on to\sphinxhyphen{}be\sphinxhyphen{}published contents. If it isn’t specified,
DataLad will attempt to figure out itself which and how dataset contents
shall be published. With a path to files, directories, or subdatasets you
can also publish only selected contents’ data.

\end{itemize}

\begin{figure}[tbp]
\centering

\noindent\sphinxincludegraphics[width=0.400\linewidth]{{going_up}.pdf}
\end{figure}


\subsection{Now what can I do with it?}
\label{\detokenize{basics/101-140-summary:now-what-can-i-do-with-it}}
\sphinxAtStartPar
Finally you can share datasets and their annexed contents with others without the
need for a shared computational infrastructure. It remains your choice where to
publish your dataset to \textendash{} considerations of data access, safety, or potential
costs will likely influence your choice of service.

\sphinxstepscope

\index{dataset operations@\spxentry{dataset operations}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!dataset operations@\spxentry{dataset operations}}\ignorespaces 

\chapter{Dataset ops}
\label{\detokenize{basics/101-136-filesystem:dataset-ops}}\label{\detokenize{basics/101-136-filesystem:file-system}}\label{\detokenize{basics/101-136-filesystem:index-0}}\label{\detokenize{basics/101-136-filesystem::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{help}.pdf}\hspace*{\fill}}

\sphinxAtStartPar
After all of the DataLad\sphinxhyphen{}101 lectures and tutorials so far, you really begin to
appreciate the pre\sphinxhyphen{}crafted examples and tasks this book provides.
“Nothing really goes wrong, and if so, it’s intended”, you acknowledge.
“But how does this prepare me for life after the course? I’ve seen a lot of
different errors and know many caveats and principles already, but I certainly
will mess something up at one point. How can I get help, or use the history of
the dataset to undo what I screwed up? Also, I’m not sure whether I know what I
can and cannot do with the files inside of my dataset… What if I would
like to remove one, for example?”

\sphinxAtStartPar
With all of the information about symlinks and object trees,
you might be reluctant to perform usual file system managing
operations, such as copying, moving, renaming or deleting
files or directories with annexed content.

\sphinxAtStartPar
If I renamed one of those books, would the symlink that points
to the file content still be correct? What happens if I’d copy
an annexed file?
If I moved the whole \sphinxcode{\sphinxupquote{books/}} directory? What if I moved
all of \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} into a different place on my computer?
What if renamed the whole superdataset?
And how do I remove a file, or directory, or subdataset?

\sphinxAtStartPar
Therefore, there is an extra tutorial today, and you attend.
There is no better way of learning than doing. Here, in the
safe space of the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} course, you can try out all
of the things you would be unsure about or reluctant to try
on the dataset that contains your own, valuable data.

\sphinxAtStartPar
Below you will find common questions about file system
management operations, and each question outlines caveats and
solutions with code examples you can paste into your own terminal.
Because these code snippets will add many commits to your
dataset, we are cleaning up within each segment with
common Git operations that manipulate the datasets
history \textendash{} be sure to execute these commands as well (and
be sure to be in the correct dataset).


\section{Move files}
\label{\detokenize{basics/101-136-filesystem:move-files}}
\index{rename file@\spxentry{rename file}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!rename file@\spxentry{rename file}}\ignorespaces 

\subsection{Rename files}
\label{\detokenize{basics/101-136-filesystem:rename-files}}\label{\detokenize{basics/101-136-filesystem:index-1}}
\sphinxAtStartPar
Let’s try it. In Unix, renaming a file is exactly the same as
moving a file, and uses the \sphinxcode{\sphinxupquote{ mv}} command.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }books/
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }TLCL.pdf\PYG{+w}{ }The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}lh\PYG{+w}{ }The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf
\PYG{g+go}{total 16K}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 131 2019\PYGZhy{}06\PYGZhy{}18 16:13 bash\PYGZus{}guide.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/WF/Gq/✂/MD5E\PYGZhy{}s1198170\PYGZhy{}\PYGZhy{}0ab2c121✂MD5.pdf}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 131 2019\PYGZhy{}06\PYGZhy{}18 16:13 byte\PYGZhy{}of\PYGZhy{}python.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/xF/42/✂/MD5E\PYGZhy{}s4161086\PYGZhy{}\PYGZhy{}c832fc13✂MD5.pdf}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 133 2019\PYGZhy{}06\PYGZhy{}18 16:13 progit.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/G6/Gj/✂/MD5E\PYGZhy{}s12465653\PYGZhy{}\PYGZhy{}05cd7ed5✂MD5.pdf}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 131 2019\PYGZhy{}06\PYGZhy{}18 16:13 The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
Try to open the renamed file, e.g., with
\sphinxcode{\sphinxupquote{evince The\_Linux\_Command\_Line.pdf}}.
This works!

\sphinxAtStartPar
But let’s see what changed in the dataset with this operation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/books/The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf (symlink)}
\PYG{g+go}{  deleted: /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/books/TLCL.pdf (symlink)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can see that the old file is marked as \sphinxcode{\sphinxupquote{deleted}}, and
simultaneously, an \sphinxcode{\sphinxupquote{untracked}} file appears: the renamed
PDF.

\sphinxAtStartPar
While this might appear messy, a \sphinxcode{\sphinxupquote{datalad save}} will clean
all of this up. Therefore, do not panic if you rename a file,
and see a dirty dataset status with deleted and untracked files
\textendash{} \sphinxcode{\sphinxupquote{datalad save}} handles these and other cases really well
under the hood.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}rename the book\PYGZdq{}}
\PYG{g+go}{delete(ok): books/TLCL.pdf (symlink)}
\PYG{g+go}{add(ok): books/The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{datalad save}} command will identify that a file was
renamed, and will summarize this nicely in the resulting commit:

\fvset{hllines={, 8, 9, 10, 11,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYGZhy{}p
\PYG{g+go}{commit d05e0ded✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    rename the book}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/books/TLCL.pdf b/books/The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf}
\PYG{g+go}{similarity index 100\PYGZpc{}}
\PYG{g+go}{rename from books/TLCL.pdf}
\PYG{g+go}{rename to books/The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{datalad save}} commits all modifications when
it’s called without a path specification,
so any other changes will be saved in the same commit as the rename.
If there are unsaved modifications you do not want to commit
together with the file name change, you could give both the
new and the deleted file as a path specification to
\sphinxcode{\sphinxupquote{datalad save}}, even if it feels unintuitive to
save a change that is marked as a deletion in a
\sphinxcode{\sphinxupquote{datalad status}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}rename file\PYGZdq{}}\PYG{+w}{ }oldname\PYG{+w}{ }newname
\end{sphinxVerbatim}

\sphinxAtStartPar
Alternatively, there is also a way to save the name change
only using Git tools only, outlined in the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-gitmv}} {\hyperref[\detokenize{basics/101-136-filesystem:fom-gitmv}]{\sphinxcrossref{\DUrole{std,std-ref}{on faster renaming}}}} (\autopageref*{\detokenize{basics/101-136-filesystem:fom-gitmv}}). If you are a Git user, you will be very familiar with it.

\index{rename file@\spxentry{rename file}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!rename file@\spxentry{rename file}}\ignorespaces \begin{findoutmore}[label={fom-gitmv}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Faster renaming with Git tools}
\label{\detokenize{basics/101-136-filesystem:fom-gitmv}}

\sphinxAtStartPar
Git has built\sphinxhyphen{}in commands that provide a solution in two steps.

\sphinxAtStartPar
If you have followed along with the previous \sphinxcode{\sphinxupquote{datalad save}}, let’s revert the renaming of the the files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{HEAD is now at 39e55c8 add container and execute analysis within container}
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we are checking out how to rename files and commit this operation
using only Git:
A Git\sphinxhyphen{}specific way to rename files is the \sphinxcode{\sphinxupquote{git mv}} command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }mv\PYG{+w}{ }TLCL.pdf\PYG{+w}{ }The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{    added: /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/books/The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf (symlink)}
\PYG{g+go}{  deleted: /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/books/TLCL.pdf (symlink)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can see that the old file is still seen as “deleted”, but the “new”,
renamed file is “added”. A \sphinxcode{\sphinxupquote{git status}} displays the change
in the dataset a bit more accurately:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }status
\PYG{g+go}{On branch main}
\PYG{g+go}{Changes to be committed:}
\PYG{g+go}{  (use \PYGZdq{}git restore \PYGZhy{}\PYGZhy{}staged \PYGZlt{}file\PYGZgt{}...\PYGZdq{} to unstage)}
\PYG{g+go}{	renamed:    TLCL.pdf \PYGZhy{}\PYGZgt{} The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
Because the \sphinxcode{\sphinxupquote{git mv}} places the change directly into the
staging area (the \sphinxstyleemphasis{index}) of Git%
\begin{footnote}[1]\sphinxAtStartFootnote
If you want to learn more about the Git\sphinxhyphen{}specific concepts of \sphinxstyleemphasis{worktree},
\sphinxstyleemphasis{staging area}/\sphinxstyleemphasis{index} or \sphinxstyleemphasis{HEAD}, the upcoming section {\hyperref[\detokenize{basics/101-137-history:history}]{\sphinxcrossref{\DUrole{std,std-ref}{Git things done}}}} (\autopageref*{\detokenize{basics/101-137-history:history}}) will
talk briefly about them and demonstrate helpful commands.
%
\end{footnote},
a subsequent \sphinxcode{\sphinxupquote{git commit \sphinxhyphen{}m "rename book"}} will write the renaming
\textendash{} and only the renaming \textendash{} to the dataset’s history, even if other
(unstaged) modifications are present.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }commit\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}rename book\PYGZdq{}}
\PYG{g+go}{[main 515fcc2] rename book}
\PYG{g+go}{ 1 file changed, 0 insertions(+), 0 deletions(\PYGZhy{})}
\PYG{g+go}{ rename books/\PYGZob{}TLCL.pdf =\PYGZgt{} The\PYGZus{}Linux\PYGZus{}Command\PYGZus{}Line.pdf\PYGZcb{} (100\PYGZpc{})}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxhref{https://knowledge-base.psychoinformatics.de/kbi/0022}{Especially when renaming directories with many files, this can be much faster} than a \sphinxcode{\sphinxupquote{mv}} followed by \sphinxcode{\sphinxupquote{datalad save}},


\end{findoutmore}

\sphinxAtStartPar
To summarize, renaming files is easy and worry\sphinxhyphen{}free. Do not be intimidated
by a file marked as deleted \textendash{} a \sphinxcode{\sphinxupquote{datalad save}} will rectify this.
Be mindful of other modifications in your dataset, though, and either supply
appropriate paths to \sphinxcode{\sphinxupquote{datalad save}}, or use Git tools to exclusively save
the name change and nothing else.

\sphinxAtStartPar
Let’s revert this now, to have a clean history.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{HEAD is now at 39e55c8 add container and execute analysis within container}
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\index{move file@\spxentry{move file}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!move file@\spxentry{move file}}\ignorespaces 

\subsection{Move files from or into subdirectories}
\label{\detokenize{basics/101-136-filesystem:move-files-from-or-into-subdirectories}}\label{\detokenize{basics/101-136-filesystem:index-3}}
\sphinxAtStartPar
Let’s move an annexed file from within \sphinxcode{\sphinxupquote{books/}} into the root
of the superdataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }TLCL.pdf\PYG{+w}{ }../TLCL.pdf
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/TLCL.pdf (symlink)}
\PYG{g+go}{  deleted: /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/books/TLCL.pdf (symlink)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In general, this looks exactly like renaming or moving a file
in the same directory. There is a subtle difference though:
Currently, the symlink of the annexed file is broken. There
are two ways to demonstrate this. One is trying to open the
file \textendash{} this will currently fail. The second way is to look
at the symlink:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }TLCL.pdf
\PYG{g+go}{lrwxrwxrwx 1 elena elena 131 2019\PYGZhy{}06\PYGZhy{}18 16:13 TLCL.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first part of the symlink should point into the \sphinxcode{\sphinxupquote{.git/}}
directory, but currently, it does not \textendash{} the symlink still looks
like \sphinxcode{\sphinxupquote{TLCL.pdf}} would be within \sphinxcode{\sphinxupquote{books/}}. Instead of pointing
into \sphinxcode{\sphinxupquote{.git}}, it currently points to \sphinxcode{\sphinxupquote{../.git}}, which is non\sphinxhyphen{}existent,
and even outside of the superdataset. This is why the file
cannot be opened: When any program tries to follow the symlink,
it will not resolve, and an error such as “no file or directory”
will be returned. But do not panic! A \sphinxcode{\sphinxupquote{datalad save}} will
rectify this as well:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}moved book into root\PYGZdq{}}
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }TLCL.pdf
\PYG{g+go}{delete(ok): books/TLCL.pdf (symlink)}
\PYG{g+go}{add(ok): TLCL.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 128 2019\PYGZhy{}06\PYGZhy{}18 16:13 TLCL.pdf \PYGZhy{}\PYGZgt{} .git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
After a \sphinxcode{\sphinxupquote{datalad save}}, the symlink is fixed again.
Therefore, in general, whenever moving or renaming a file,
especially between directories, a \sphinxcode{\sphinxupquote{datalad save}} is
the best option to turn to. Take a look at the
\textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-move-is-change}} {\hyperref[\detokenize{basics/101-136-filesystem:fom-move-is-change}]{\sphinxcrossref{\DUrole{std,std-ref}{on the content impact of a move}}}} (\autopageref*{\detokenize{basics/101-136-filesystem:fom-move-is-change}})
for some more background.

\index{content pointer file@\spxentry{content pointer file}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!content pointer file@\spxentry{content pointer file}}\ignorespaces \begin{findoutmore}[label={fom-move-is-change}, before title={\thetcbcounter\ }, float, floatplacement=tp, check odd page=true]{Why a move between directories is actually a content change}
\label{\detokenize{basics/101-136-filesystem:fom-move-is-change}}

\sphinxAtStartPar
Let’s see how this shows up in the dataset history:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYGZhy{}p
\PYG{g+go}{commit b315f5c4✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    moved book into root}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/TLCL.pdf b/TLCL.pdf}
\PYG{g+go}{new file mode 120000}
\PYG{g+go}{index 0000000..34328e2}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/TLCL.pdf}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1 @@}
\PYG{g+go}{+.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\PYG{g+go}{\PYGZbs{} No newline at end of file}
\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/books/TLCL.pdf b/books/TLCL.pdf}
\PYG{g+go}{deleted file mode 120000}
\PYG{g+go}{index 4c84b61..0000000}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} a/books/TLCL.pdf}
\PYG{g+go}{+++ /dev/null}
\PYG{g+go}{@@ \PYGZhy{}1 +0,0 @@}
\PYG{g+go}{\PYGZhy{}../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\PYG{g+go}{\PYGZbs{} No newline at end of file}
\end{sphinxVerbatim}

\sphinxAtStartPar
As you can see, this action does not show up as a move, but instead
a deletion and addition of a new file. Why? Because the content
that is tracked is the actual symlink, and due to the change in
relative location, the symlink needed to change. Hence, what looks
and feels like a move on the file system for you is actually a
move plus a content change for Git.


\end{findoutmore}

\index{fix@\spxentry{fix}!git\sphinxhyphen{}annex command@\spxentry{git\sphinxhyphen{}annex command}}\index{git\sphinxhyphen{}annex command@\spxentry{git\sphinxhyphen{}annex command}!fix@\spxentry{fix}}\ignorespaces \begin{gitusernote}[label={gun-annex-fix}, before title={\thetcbcounter\ }, float, floatplacement=tp, check odd page=true]{‘datalad save’ internals: ‘git annex fix’}
\label{\detokenize{basics/101-136-filesystem:gun-annex-fix}}

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{datalad save}} command internally uses a \sphinxcode{\sphinxupquote{git commit}} to save changes to a dataset.
\sphinxcode{\sphinxupquote{git commit}} in turn triggers a \sphinxcode{\sphinxupquote{git annex fix}}
command. This git\sphinxhyphen{}annex command fixes up links that have become broken
to again point to annexed content, and is responsible for cleaning up
what needs to be cleaned up. Thanks, git\sphinxhyphen{}annex!


\end{gitusernote}

\sphinxAtStartPar
Finally, let’s clean up:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+go}{HEAD is now at 39e55c8 add container and execute analysis within container}
\end{sphinxVerbatim}

\index{move file to other dataset@\spxentry{move file to other dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!move file to other dataset@\spxentry{move file to other dataset}}\ignorespaces 

\subsection{Moving files across dataset boundaries}
\label{\detokenize{basics/101-136-filesystem:moving-files-across-dataset-boundaries}}\label{\detokenize{basics/101-136-filesystem:index-6}}
\sphinxAtStartPar
Generally speaking, moving files across dataset hierarchies is not advised.
While DataLad blurs the dataset boundaries to ease working in nested dataset,
the dataset boundaries do still exist. If you move a file from one subdataset
into another, or up or down a dataset hierarchy, you will move it out of the
version control it was in (i.e., from one \sphinxcode{\sphinxupquote{.git}} directory into a different
one). From the perspective of the first subdataset, the file will be deleted,
and from the perspective of the receiving dataset, the file will be added to
the dataset, but straight out of nowhere, with none of its potential history
from its original dataset attached to it. Before moving a file, consider whether
\sphinxstyleemphasis{copying} it (outlined in the next but one paragraph) might be a more suitable
alternative.

\sphinxAtStartPar
If you are willing to sacrifice%
\begin{footnote}[2]\sphinxAtStartFootnote
Or rather: split \textendash{} basically, the file is getting a fresh new start.
Think of it as some sort of witness\sphinxhyphen{}protection program with complete
disrespect for provenance…
%
\end{footnote} the file’s history and move it to a
different dataset, the procedure differs between annexed files, and files
stored in Git.

\sphinxAtStartPar
For files that Git manages, moving and saving is simple: Move the file, and
save the resulting changes in \sphinxstyleemphasis{both} affected datasets (this can be done with
one recursive \sphinxcode{\sphinxupquote{datalad save}} from a top\sphinxhyphen{}level dataset, though).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }notes.txt\PYG{+w}{ }midterm\PYGZus{}project/notes.txt
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}r
\PYG{g+go}{ modified: midterm\PYGZus{}project (dataset)}
\PYG{g+go}{untracked: midterm\PYGZus{}project/notes.txt (file)}
\PYG{g+go}{  deleted: notes.txt (file)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}moved notes.txt from root of top\PYGZhy{}ds to midterm subds\PYGZdq{}}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{delete(ok): notes.txt (file)}
\PYG{g+go}{add(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{action summary:}
\PYG{g+go}{  add (ok: 3)}
\PYG{g+go}{  delete (ok: 1)}
\PYG{g+go}{  save (notneeded: 2, ok: 2)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note how the history of \sphinxcode{\sphinxupquote{notes.txt}} does not exist in the subdataset \textendash{} it appears
as if the file was generated at once, instead of successively over the course:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }notes.txt
\PYG{g+go}{commit 1e273c59✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    moved notes.txt from root of top\PYGZhy{}ds to midterm subds}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s undo this change again. It requires a \sphinxcode{\sphinxupquote{git reset}}s in \sphinxstyleemphasis{both} datasets.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} in midterm\PYGZus{}project}
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}

\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} in DataLad\PYGZhy{}101}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}
\PYG{g+go}{HEAD is now at 4f00ad0 [DATALAD RUNCMD] rerun analysis in container}
\PYG{g+go}{HEAD is now at 39e55c8 add container and execute analysis within container}
\end{sphinxVerbatim}

\sphinxAtStartPar
The process is a bit more complex for annexed files. Let’s do it wrong, first:
What happens if we move an annexed file in the same way as \sphinxcode{\sphinxupquote{notes.txt}}?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }books/TLCL.pdf\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}r
\PYG{g+go}{  deleted: books/TLCL.pdf (symlink)}
\PYG{g+go}{ modified: midterm\PYGZus{}project (dataset)}
\PYG{g+go}{untracked: midterm\PYGZus{}project/TLCL.pdf (symlink)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}move annexed file around\PYGZdq{}}
\PYG{g+go}{add(ok): TLCL.pdf (file) [TLCL.pdf is a git\PYGZhy{}annex symlink.]}
\PYG{g+go}{save(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{delete(ok): books/TLCL.pdf (symlink)}
\PYG{g+go}{add(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{action summary:}
\PYG{g+go}{  add (ok: 3)}
\PYG{g+go}{  delete (ok: 1)}
\PYG{g+go}{  save (notneeded: 2, ok: 2)}
\end{sphinxVerbatim}

\sphinxAtStartPar
At this point, this does not look that different to the result of moving
\sphinxcode{\sphinxupquote{notes.txt}}. Note, though, that the deleted and untracked PDFs are symlinks \textendash{}
and therein lies the problem: What was moved was not the file content (which is
still in the annex of the top\sphinxhyphen{}level dataset, \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}), but its symlink that
was stored in Git. After moving the file, the symlink is broken, and git\sphinxhyphen{}annex
has no way of finding out where the file content could be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }annex\PYG{+w}{ }whereis\PYG{+w}{ }TLCL.pdf
\PYG{g+go}{whereis TLCL.pdf (0 copies) failed}
\PYG{g+go}{whereis: 1 failed}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s rewind, and find out how to do it correctly:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}
\PYG{g+go}{HEAD is now at 4f00ad0 [DATALAD RUNCMD] rerun analysis in container}
\PYG{g+go}{HEAD is now at 39e55c8 add container and execute analysis within container}
\end{sphinxVerbatim}

\sphinxAtStartPar
The crucial step to remember is to get the annexed file out of the annex prior
to moving it. For this, we need to fall back to git\sphinxhyphen{}annex commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }annex\PYG{+w}{ }unlock\PYG{+w}{ }books/TLCL.pdf
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }books/TLCL.pdf\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}r
\PYG{g+go}{unlock books/TLCL.pdf ok}
\PYG{g+gp+gpVirtualEnv}{(recording state in git...)}
\PYG{g+go}{  deleted: books/TLCL.pdf (file)}
\PYG{g+go}{ modified: midterm\PYGZus{}project (dataset)}
\PYG{g+go}{untracked: midterm\PYGZus{}project/TLCL.pdf (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Afterwards, a (recursive) \sphinxcode{\sphinxupquote{datalad save}} commits the removal of the book from
DataLad\sphinxhyphen{}101, and adds the file content into the annex of \sphinxcode{\sphinxupquote{midterm\_project}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}move book into midterm\PYGZus{}project\PYGZdq{}}
\PYG{g+go}{add(ok): TLCL.pdf (file)}
\PYG{g+go}{save(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{delete(ok): books/TLCL.pdf (file)}
\PYG{g+go}{add(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{action summary:}
\PYG{g+go}{  add (ok: 3)}
\PYG{g+go}{  delete (ok: 1)}
\PYG{g+go}{  save (notneeded: 2, ok: 2)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Even though you did split the file’s history, at least its content is in the
correct dataset now:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }annex\PYG{+w}{ }whereis\PYG{+w}{ }TLCL.pdf
\PYG{g+go}{whereis TLCL.pdf (1 copy)}
\PYG{g+go}{  	✂UUID✂ \PYGZhy{}\PYGZhy{} me@appveyor\PYGZhy{}vm:\PYGZti{}/dl\PYGZhy{}101/DataLad\PYGZhy{}101/midterm\PYGZus{}project [here]}
\PYG{g+go}{ok}
\end{sphinxVerbatim}

\sphinxAtStartPar
But more than showing you how it can be done, if necessary, this paragraph
hopefully convinced you that moving files across dataset boundaries is not
convenient. It can be a confusing and potentially “file\sphinxhyphen{}content\sphinxhyphen{}losing”\sphinxhyphen{}dangerous
process, but it also dissociates a file from its provenance that is captured
in its previous dataset, with no machine\sphinxhyphen{}readable way to learn about the move
easily. A better alternative may be copying files with the \sphinxcode{\sphinxupquote{datalad copy\sphinxhyphen{}file}}
command introduced in detail in the online\sphinxhyphen{}handbook, and demonstrated in the next
but one paragraph. Let’s quickly clean up by moving the file back:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} in midterm\PYGZus{}project}
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }annex\PYG{+w}{ }unannex\PYG{+w}{ }TLCL.pdf
\PYG{g+go}{unannex TLCL.pdf ok}
\PYG{g+gp+gpVirtualEnv}{(recording state in git...)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }TLCL.pdf\PYG{+w}{ }../books
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}move book back from midterm\PYGZus{}project\PYGZdq{}}
\PYG{g+go}{delete(ok): TLCL.pdf (symlink)}
\PYG{g+go}{save(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{add(ok): midterm\PYGZus{}project (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{add(ok): books/TLCL.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{action summary:}
\PYG{g+go}{  add (ok: 3)}
\PYG{g+go}{  delete (ok: 1)}
\PYG{g+go}{  save (notneeded: 2, ok: 2)}
\end{sphinxVerbatim}

\index{copy file@\spxentry{copy file}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!copy file@\spxentry{copy file}}\ignorespaces 

\subsection{Copy files}
\label{\detokenize{basics/101-136-filesystem:copy-files}}\label{\detokenize{basics/101-136-filesystem:index-7}}
\sphinxAtStartPar
Let’s create a copy of an annexed file, using the Unix
command \sphinxcode{\sphinxupquote{cp}} to copy.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cp\PYG{+w}{ }books/TLCL.pdf\PYG{+w}{ }copyofTLCL.pdf
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: copyofTLCL.pdf (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
That’s expected. The copy shows up as a new, untracked
file. Let’s save it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add copy of TLCL.pdf\PYGZdq{}}
\PYG{g+go}{add(ok): copyofTLCL.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{1}\PYG{+w}{ }\PYGZhy{}p
\PYG{g+go}{commit ebbe6b93✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    add copy of TLCL.pdf}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/copyofTLCL.pdf b/copyofTLCL.pdf}
\PYG{g+go}{new file mode 120000}
\PYG{g+go}{index 0000000..34328e2}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/copyofTLCL.pdf}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1 @@}
\PYG{g+go}{+.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\PYG{g+go}{\PYGZbs{} No newline at end of file}
\end{sphinxVerbatim}

\sphinxAtStartPar
That’s it. For that magic that just happend, read the
\textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-link-copies}} {\hyperref[\detokenize{basics/101-136-filesystem:fom-link-copies}]{\sphinxcrossref{\DUrole{std,std-ref}{on linking identical content}}}} (\autopageref*{\detokenize{basics/101-136-filesystem:fom-link-copies}}).

\index{content pointer file@\spxentry{content pointer file}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!content pointer file@\spxentry{content pointer file}}\ignorespaces \begin{findoutmore}[label={fom-link-copies}, before title={\thetcbcounter\ }, float, floatplacement=tb, check odd page=true]{Symlinks!}
\label{\detokenize{basics/101-136-filesystem:fom-link-copies}}

\sphinxAtStartPar
If you have read the additional content in the section
{\hyperref[\detokenize{basics/101-115-symlinks:symlink}]{\sphinxcrossref{\DUrole{std,std-ref}{Data integrity}}}} (\autopageref*{\detokenize{basics/101-115-symlinks:symlink}}), you know that the same file content
is only stored once, and copies of the same file point to
the same location in the object tree.

\sphinxAtStartPar
Let’s check that out:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }copyofTLCL.pdf
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }books/TLCL.pdf
\PYG{g+go}{lrwxrwxrwx 1 elena elena 128 2019\PYGZhy{}06\PYGZhy{}18 16:13 copyofTLCL.pdf \PYGZhy{}\PYGZgt{} .git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 131 2019\PYGZhy{}06\PYGZhy{}18 16:13 books/TLCL.pdf \PYGZhy{}\PYGZgt{} ../.git/annex/objects/jf/3M/✂/MD5E\PYGZhy{}s2120211\PYGZhy{}\PYGZhy{}06d1efcb✂MD5.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
Indeed! Apart from their relative location (\sphinxcode{\sphinxupquote{.git}} versus
\sphinxcode{\sphinxupquote{../.git}}) their symlink is identical. Thus, even though two
copies of the book exist in your dataset, your disk needs to
store it only once.

\sphinxAtStartPar
In most cases, this is just an interesting fun\sphinxhyphen{}fact, but beware
when dropping content with \sphinxcode{\sphinxupquote{datalad drop}}
as outlined in {\hyperref[\detokenize{basics/101-136-filesystem:remove}]{\sphinxcrossref{\DUrole{std,std-ref}{Remove annexed content entirely}}}} (\autopageref*{\detokenize{basics/101-136-filesystem:remove}}):
If you drop the content of one copy of a file, all
other copies will lose this content as well.


\end{findoutmore}

\sphinxAtStartPar
Finally, let’s clean up:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+go}{HEAD is now at de2d23c move book back from midterm\PYGZus{}project}
\end{sphinxVerbatim}

\index{copy file to other dataset@\spxentry{copy file to other dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!copy file to other dataset@\spxentry{copy file to other dataset}}\ignorespaces 

\subsection{Copy files across dataset boundaries}
\label{\detokenize{basics/101-136-filesystem:copy-files-across-dataset-boundaries}}\label{\detokenize{basics/101-136-filesystem:index-9}}\label{\detokenize{basics/101-136-filesystem:copyfilefs}}
\sphinxAtStartPar
Instead of moving files across dataset boundaries, \sphinxstyleemphasis{copying} them is an easier
and actually supported method.
The DataLad command that can be used for this is \sphinxcode{\sphinxupquote{datalad copy\sphinxhyphen{}file}}.
This command allows to copy files
(from any dataset or non\sphinxhyphen{}dataset location, annexed or not annexed) into a dataset.
If the file is copied from a dataset and is annexed, its recorded URLs
are added to the new dataset as well, and there is no need for unannex’ing the
or even retrieving its file contents. Let’s see this in action for a file
stored in Git, and a file stored in annex:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }copy\PYGZhy{}file\PYG{+w}{ }notes.txt\PYG{+w}{ }midterm\PYGZus{}project\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+go}{copy\PYGZus{}file(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/notes.txt}
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }copy\PYGZhy{}file\PYG{+w}{ }books/bash\PYGZus{}guide.pdf\PYG{+w}{ }midterm\PYGZus{}project\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+go}{copy\PYGZus{}file(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/books/bash\PYGZus{}guide.pdf [/home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/midterm\PYGZus{}project/bash\PYGZus{}guide.pdf]}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Both files have been successfully transferred and saved to the subdataset, and
no unannexing was necessary.
\sphinxcode{\sphinxupquote{notes.txt}} was annexed in the subdataset, though, as this subdataset
was not configured with the \sphinxcode{\sphinxupquote{text2git}} {\hyperref[\detokenize{glossary:term-run-procedure}]{\sphinxtermref{\DUrole{xref,std,std-term}{run procedure}}}}.

\fvset{hllines={, 3, 10,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }tree\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+go}{midterm\PYGZus{}project}
\PYG{g+go}{├── bash\PYGZus{}guide.pdf \PYGZhy{}\PYGZgt{} .git/annex/objects/31/wQ/SHA256E\PYGZhy{}s1198170\PYGZhy{}\PYGZhy{}d08f2c7b✂SHA162d6b24a20cb5abae4d4402c.pdf/SHA256E\PYGZhy{}s1198170\PYGZhy{}\PYGZhy{}d08f2c7b✂SHA162d6b24a20cb5abae4d4402c.pdf}
\PYG{g+go}{├── CHANGELOG.md}
\PYG{g+go}{├── code}
\PYG{g+go}{│   ├── README.md}
\PYG{g+go}{│   └── script.py}
\PYG{g+go}{├── input}
\PYG{g+go}{│   └── iris.csv \PYGZhy{}\PYGZgt{} .git/annex/objects/qz/Jg/✂/MD5E\PYGZhy{}s3975\PYGZhy{}\PYGZhy{}341a3b52✂MD5.csv}
\PYG{g+go}{├── notes.txt \PYGZhy{}\PYGZgt{} .git/annex/objects/p1/jm/✂/MD5E\PYGZhy{}s5080\PYGZhy{}\PYGZhy{}73ec6967✂MD5.txt}
\PYG{g+go}{├── pairwise\PYGZus{}relationships.png \PYGZhy{}\PYGZgt{} .git/annex/objects/q1/gp/✂/MD5E\PYGZhy{}s261062\PYGZhy{}\PYGZhy{}025dc493✂MD5.png}
\PYG{g+go}{├── prediction\PYGZus{}report.csv \PYGZhy{}\PYGZgt{} .git/annex/objects/8q/6M/✂/MD5E\PYGZhy{}s345\PYGZhy{}\PYGZhy{}a88cab39✂MD5.csv}
\PYG{g+go}{└── README.md}

\PYG{g+go}{2 directories, 9 files}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
The subdataset has two new commits as \sphinxcode{\sphinxupquote{datalad copy\sphinxhyphen{}file}} can take care
of saving changes in the copied\sphinxhyphen{}to dataset, and thus the new subdataset state
would need to be saved in the superdataset.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status\PYG{+w}{ }\PYGZhy{}r
\PYG{g+go}{ modified: midterm\PYGZus{}project (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Still, just as when we \sphinxstyleemphasis{moved} files across dataset boundaries, the files’
provenance record is lost:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }midterm\PYGZus{}project
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }notes.txt
\PYG{g+go}{commit 5b8d330f✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    [DATALAD] Recorded changes}
\end{sphinxVerbatim}

\sphinxAtStartPar
Nevertheless, copying files with \sphinxcode{\sphinxupquote{datalad copy\sphinxhyphen{}file}} is easier and safer
than moving them with standard Unix commands, especially so for annexed files.
A more detailed introduction to \sphinxcode{\sphinxupquote{datalad copy\sphinxhyphen{}file}} and a concrete
use case can be found in the online\sphinxhyphen{}handbook.

\sphinxAtStartPar
Let’s clean up:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}2
\PYG{g+go}{HEAD is now at b2b6855 move book back from midterm\PYGZus{}project}
\end{sphinxVerbatim}


\section{Move datasets}
\label{\detokenize{basics/101-136-filesystem:move-datasets}}
\index{move subdataset@\spxentry{move subdataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!move subdataset@\spxentry{move subdataset}}\ignorespaces 

\subsection{Move/rename a subdirectory or subdataset}
\label{\detokenize{basics/101-136-filesystem:move-rename-a-subdirectory-or-subdataset}}\label{\detokenize{basics/101-136-filesystem:index-10}}
\sphinxAtStartPar
Moving or renaming subdirectories, especially if they are subdatasets,
\sphinxstyleemphasis{can} be a minefield. But in principle, a safe way to proceed is using
the Unix \sphinxcode{\sphinxupquote{ mv}} command to move or rename, and the \sphinxcode{\sphinxupquote{datalad save}}
to clean up afterwards, just as in the examples above. Make sure to
\sphinxstylestrong{not} use \sphinxcode{\sphinxupquote{git mv}}, especially for subdatasets.

\sphinxAtStartPar
Let’s, for example, rename the \sphinxcode{\sphinxupquote{books}} directory:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }books/\PYG{+w}{ }readings
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: readings (directory)}
\PYG{g+go}{  deleted: books/TLCL.pdf (symlink)}
\PYG{g+go}{  deleted: books/bash\PYGZus{}guide.pdf (symlink)}
\PYG{g+go}{  deleted: books/byte\PYGZhy{}of\PYGZhy{}python.pdf (symlink)}
\PYG{g+go}{  deleted: books/progit.pdf (symlink)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}renamed directory\PYGZdq{}}
\PYG{g+go}{delete(ok): books/TLCL.pdf (symlink)}
\PYG{g+go}{delete(ok): books/bash\PYGZus{}guide.pdf (symlink)}
\PYG{g+go}{delete(ok): books/byte\PYGZhy{}of\PYGZhy{}python.pdf (symlink)}
\PYG{g+go}{delete(ok): books/progit.pdf (symlink)}
\PYG{g+go}{add(ok): readings/TLCL.pdf (file)}
\PYG{g+go}{add(ok): readings/bash\PYGZus{}guide.pdf (file)}
\PYG{g+go}{add(ok): readings/byte\PYGZhy{}of\PYGZhy{}python.pdf (file)}
\PYG{g+go}{add(ok): readings/progit.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is easy, and complication free. Moving (as in: changing the location, instead of
the name) the directory would work in the
same fashion, and a \sphinxcode{\sphinxupquote{datalad save}} would fix broken symlinks afterwards.
Let’s quickly clean this up:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+go}{HEAD is now at de2d23c move book back from midterm\PYGZus{}project}
\end{sphinxVerbatim}

\sphinxAtStartPar
But let’s now try to move the \sphinxcode{\sphinxupquote{longnow}} subdataset into the root of the
superdataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }recordings/longnow\PYG{+w}{ }.
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: longnow (directory)}
\PYG{g+go}{  deleted: recordings/longnow (dataset)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}moved subdataset\PYGZdq{}}
\PYG{g+go}{delete(ok): recordings/longnow (dataset)}
\PYG{g+go}{add(ok): longnow (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\sphinxAtStartPar
This seems fine, and it has indeed worked.
However, \sphinxstyleemphasis{reverting} a commit like this is tricky, at the moment. This could
lead to trouble if you at a later point try to revert or rebase chunks of your
history including this move. Therefore, if you can, try not to move subdatasets
around. For now we’ll clean up in a somewhat “hacky” way: Reverting, and
moving remaining subdataset contents back to their original place by hand
to take care of the unwanted changes the commit reversal introduced.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+go}{warning: unable to rmdir \PYGZsq{}longnow\PYGZsq{}: Directory not empty}
\PYG{g+go}{HEAD is now at de2d23c move book back from midterm\PYGZus{}project}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }\PYGZhy{}f\PYG{+w}{ }longnow\PYG{+w}{ }recordings
\end{sphinxVerbatim}

\sphinxAtStartPar
The take\sphinxhyphen{}home message therefore is that it is best not to move subdatasets,
but very possible to move subdirectories if necessary. In both cases, do not
attempt moving with the \sphinxcode{\sphinxupquote{git mv}}, but stick with \sphinxcode{\sphinxupquote{ mv}} and
a subsequent \sphinxcode{\sphinxupquote{datalad save}}.

\index{move superdataset@\spxentry{move superdataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!move superdataset@\spxentry{move superdataset}}\ignorespaces 

\subsection{Move/rename a superdataset}
\label{\detokenize{basics/101-136-filesystem:move-rename-a-superdataset}}\label{\detokenize{basics/101-136-filesystem:index-11}}
\sphinxAtStartPar
Once created, a DataLad superdataset may not be in an optimal
place on your file system, or have the best name.

\sphinxAtStartPar
After a while, you might think that the dataset would fit much
better into \sphinxcode{\sphinxupquote{/home/user/research\_projects/}} than in
\sphinxcode{\sphinxupquote{/home/user/Documents/tmp/}}. Or maybe at
some point, a long name such as \sphinxcode{\sphinxupquote{My\sphinxhyphen{}very\sphinxhyphen{}first\sphinxhyphen{}DataLad\sphinxhyphen{}project\sphinxhyphen{}wohoo\sphinxhyphen{}I\sphinxhyphen{}am\sphinxhyphen{}so\sphinxhyphen{}excited}}
does not look pretty in your terminal prompt anymore, and going for
\sphinxcode{\sphinxupquote{finance\sphinxhyphen{}2019}} seems more professional.

\sphinxAtStartPar
These will be situations in which you want to rename or move
a superdataset. Will that break anything?

\sphinxAtStartPar
In all standard situations, no, it will be completely fine.
You can use standard Unix commands such as \sphinxcode{\sphinxupquote{mv}} to do it,
and also whichever graphical user interface or explorer you may
use.

\sphinxAtStartPar
Beware of one thing though: If your dataset either is a sibling
or has a sibling with the source being a path, moving or renaming
the dataset will break the linkage between the datasets. This can
be fixed easily though. Let’s demo this.

\index{move subdataset@\spxentry{move subdataset}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!move subdataset@\spxentry{move subdataset}}\ignorespaces 
\sphinxAtStartPar
As section {\hyperref[\detokenize{basics/101-122-config:config}]{\sphinxcrossref{\DUrole{std,std-ref}{Local configuration}}}} (\autopageref*{\detokenize{basics/101-122-config:config}}) explains, each
sibling is registered in \sphinxcode{\sphinxupquote{.git/config}} in a “submodule” section.
Let’s look at how our sibling “roommate” is registered there:

\fvset{hllines={, 18, 19,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }.git/config
\PYG{g+go}{[core]}
\PYG{g+go}{	repositoryformatversion = 0}
\PYG{g+go}{	filemode = true}
\PYG{g+go}{	bare = false}
\PYG{g+go}{	logallrefupdates = true}
\PYG{g+go}{	editor = nano}
\PYG{g+go}{[annex]}
\PYG{g+go}{	uuid = 46b169aa\PYGZhy{}bb91\PYGZhy{}42d6\PYGZhy{}be06\PYGZhy{}355d957fb4f7}
\PYG{g+go}{	version = 10}
\PYG{g+go}{[filter \PYGZdq{}annex\PYGZdq{}]}
\PYG{g+go}{	smudge = git\PYGZhy{}annex smudge \PYGZhy{}\PYGZhy{} \PYGZpc{}f}
\PYG{g+go}{	clean = git\PYGZhy{}annex smudge \PYGZhy{}\PYGZhy{}clean \PYGZhy{}\PYGZhy{} \PYGZpc{}f}
\PYG{g+go}{	process = git\PYGZhy{}annex filter\PYGZhy{}process}
\PYG{g+go}{[submodule \PYGZdq{}recordings/longnow\PYGZdq{}]}
\PYG{g+go}{	active = true}
\PYG{g+go}{	url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\PYG{g+go}{[remote \PYGZdq{}roommate\PYGZdq{}]}
\PYG{g+go}{	url = ../mock\PYGZus{}user/DataLad\PYGZhy{}101}
\PYG{g+go}{	fetch = +refs/heads/*:refs/remotes/roommate/*}
\PYG{g+go}{	annex\PYGZhy{}uuid = ✂UUID✂}
\PYG{g+go}{	annex\PYGZhy{}ignore = false}
\PYG{g+go}{[submodule \PYGZdq{}midterm\PYGZus{}project\PYGZdq{}]}
\PYG{g+go}{	active = true}
\PYG{g+go}{	url = ./midterm\PYGZus{}project}
\PYG{g+go}{[submodule \PYGZdq{}longnow\PYGZdq{}]}
\PYG{g+go}{	active = true}
\PYG{g+go}{	url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
As you can see, its “url” is specified as a relative path. Say your
room mate’s directory is a dataset you would want to move. Let’s see
what happens if we move the dataset such that the path does not point
to the dataset anymore:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} add an intermediate directory}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../mock\PYGZus{}user
\PYG{g+gp}{\PYGZdl{} }mkdir\PYG{+w}{ }onemoredir
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} move your room mates dataset into this new directory}
\PYG{g+gp}{\PYGZdl{} }mv\PYG{+w}{ }DataLad\PYGZhy{}101\PYG{+w}{ }onemoredir
\end{sphinxVerbatim}

\sphinxAtStartPar
This means that relative to your \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}}, your room mates
dataset is not at \sphinxcode{\sphinxupquote{../mock\_user/DataLad\sphinxhyphen{}101}} anymore, but in
\sphinxcode{\sphinxupquote{../mock\_user/onemoredir/DataLad\sphinxhyphen{}101}}. The path specified in
the configuration file is thus wrong now.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} navigate back into your dataset}
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../DataLad\PYGZhy{}101
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} attempt a datalad update}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }update
\PYG{g+go}{update(error): . (dataset) [Fetch failed: CommandError(CommandError: \PYGZsq{}git \PYGZhy{}c diff.ignoreSubmodules=none \PYGZhy{}c core.quotepath=false fetch \PYGZhy{}\PYGZhy{}verbose \PYGZhy{}\PYGZhy{}progress \PYGZhy{}\PYGZhy{}no\PYGZhy{}recurse\PYGZhy{}submodules \PYGZhy{}\PYGZhy{}prune roommate\PYGZsq{} failed with exitcode 128 under /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 [err: \PYGZsq{}fatal: \PYGZsq{}../mock\PYGZus{}user/DataLad\PYGZhy{}101\PYGZsq{} does not appear to be a git repository}
\PYG{g+go}{fatal: Could not read from remote repository.}

\PYG{g+go}{Please make sure you have the correct access rights}
\PYG{g+go}{and the repository exists.\PYGZsq{}])] [CommandError: \PYGZsq{}git \PYGZhy{}c diff.ignoreSubmodules=none \PYGZhy{}c core.quotepath=false fetch \PYGZhy{}\PYGZhy{}verbose \PYGZhy{}\PYGZhy{}progress \PYGZhy{}\PYGZhy{}no\PYGZhy{}recurse\PYGZhy{}submodules \PYGZhy{}\PYGZhy{}prune roommate\PYGZsq{} failed with exitcode 128 under /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101 [err: \PYGZsq{}fatal: \PYGZsq{}../mock\PYGZus{}user/DataLad\PYGZhy{}101\PYGZsq{} does not appear to be a git repository}
\PYG{g+go}{fatal: Could not read from remote repository.}

\PYG{g+go}{Please make sure you have the correct access rights}
\PYG{g+go}{and the repository exists.\PYGZsq{}]]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here we go:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}fatal: \PYGZsq{}../mock\PYGZus{}user/DataLad\PYGZhy{}101\PYGZsq{} does not appear to be a git repository
 fatal: Could not read from remote repository.
\end{sphinxVerbatim}

\sphinxAtStartPar
Git seems pretty insistent (given the amount of error messages) that
it cannot seem to find a Git repository at the location the \sphinxcode{\sphinxupquote{.git/config}}
file specified. Luckily, we can provide this information. Edit the file with
an editor of your choice and fix the path from
\sphinxcode{\sphinxupquote{url = ../mock\_user/DataLad\sphinxhyphen{}101}} to
\sphinxcode{\sphinxupquote{url = ../mock\_user/onemoredir/DataLad\sphinxhyphen{}101}}.

\sphinxAtStartPar
Below, we are using the stream editor \sphinxhref{https://en.wikipedia.org/wiki/Sed}{sed}
for this operation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }sed\PYG{+w}{ }\PYGZhy{}i\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}s/..\PYGZbs{}/mock\PYGZus{}user\PYGZbs{}/DataLad\PYGZhy{}101/..\PYGZbs{}/mock\PYGZus{}user\PYGZbs{}/onemoredir\PYGZbs{}/DataLad\PYGZhy{}101/\PYGZsq{}}\PYG{+w}{ }.git/config
\end{sphinxVerbatim}

\sphinxAtStartPar
This is how the file looks now:

\fvset{hllines={, 19,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }.git/config
\PYG{g+go}{[core]}
\PYG{g+go}{	repositoryformatversion = 0}
\PYG{g+go}{	filemode = true}
\PYG{g+go}{	bare = false}
\PYG{g+go}{	logallrefupdates = true}
\PYG{g+go}{	editor = nano}
\PYG{g+go}{[annex]}
\PYG{g+go}{	uuid = 46b169aa\PYGZhy{}bb91\PYGZhy{}42d6\PYGZhy{}be06\PYGZhy{}355d957fb4f7}
\PYG{g+go}{	version = 10}
\PYG{g+go}{[filter \PYGZdq{}annex\PYGZdq{}]}
\PYG{g+go}{	smudge = git\PYGZhy{}annex smudge \PYGZhy{}\PYGZhy{} \PYGZpc{}f}
\PYG{g+go}{	clean = git\PYGZhy{}annex smudge \PYGZhy{}\PYGZhy{}clean \PYGZhy{}\PYGZhy{} \PYGZpc{}f}
\PYG{g+go}{	process = git\PYGZhy{}annex filter\PYGZhy{}process}
\PYG{g+go}{[submodule \PYGZdq{}recordings/longnow\PYGZdq{}]}
\PYG{g+go}{	active = true}
\PYG{g+go}{	url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\PYG{g+go}{[remote \PYGZdq{}roommate\PYGZdq{}]}
\PYG{g+go}{	url = ../mock\PYGZus{}user/onemoredir/DataLad\PYGZhy{}101}
\PYG{g+go}{	fetch = +refs/heads/*:refs/remotes/roommate/*}
\PYG{g+go}{	annex\PYGZhy{}uuid = ✂UUID✂}
\PYG{g+go}{	annex\PYGZhy{}ignore = false}
\PYG{g+go}{[submodule \PYGZdq{}midterm\PYGZus{}project\PYGZdq{}]}
\PYG{g+go}{	active = true}
\PYG{g+go}{	url = ./midterm\PYGZus{}project}
\PYG{g+go}{[submodule \PYGZdq{}longnow\PYGZdq{}]}
\PYG{g+go}{	active = true}
\PYG{g+go}{	url = https://github.com/datalad\PYGZhy{}datasets/longnow\PYGZhy{}podcasts.git}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
Let’s try to update now:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }update
\PYG{g+go}{update(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Nice! We fixed it!
Therefore, if a dataset you move or rename is known to other
datasets from its path, or identifies siblings with paths,
make sure to adjust them in the \sphinxcode{\sphinxupquote{.git/config}} file.

\sphinxAtStartPar
To clean up, we’ll redo the move of the dataset and the
modification in \sphinxcode{\sphinxupquote{.git/config}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../mock\PYGZus{}user\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }mv\PYG{+w}{ }onemoredir/DataLad\PYGZhy{}101\PYG{+w}{ }.
\PYG{g+gp}{\PYGZdl{} }rm\PYG{+w}{ }\PYGZhy{}r\PYG{+w}{ }onemoredir
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{cd}\PYG{+w}{ }../DataLad\PYGZhy{}101\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }sed\PYG{+w}{ }\PYGZhy{}i\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}s/..\PYGZbs{}/mock\PYGZus{}user\PYGZbs{}/onemoredir\PYGZbs{}/DataLad\PYGZhy{}101/..\PYGZbs{}/mock\PYGZus{}user\PYGZbs{}/DataLad\PYGZhy{}101/\PYGZsq{}}\PYG{+w}{ }.git/config
\end{sphinxVerbatim}


\section{Stop tracking}
\label{\detokenize{basics/101-136-filesystem:stop-tracking}}
\index{stop tracking file@\spxentry{stop tracking file}!with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}}\index{with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}!stop tracking file@\spxentry{stop tracking file}}\ignorespaces 

\subsection{Get contents out of git\sphinxhyphen{}annex}
\label{\detokenize{basics/101-136-filesystem:get-contents-out-of-git-annex}}\label{\detokenize{basics/101-136-filesystem:index-13}}
\sphinxAtStartPar
Files in your dataset can either be handled by {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} or {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git\sphinxhyphen{}annex}}}}.
Self\sphinxhyphen{}made or predefined configurations to \sphinxcode{\sphinxupquote{.gitattributes}}, defaults, or the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}to\sphinxhyphen{}git}} option to \sphinxcode{\sphinxupquote{datalad save}} allow you to control which tool
does what on up to single\sphinxhyphen{}file basis. Accidentally though, you may give a file of yours
to git\sphinxhyphen{}annex when it was intended to be stored in Git, or you want to get a previously
annexed file into Git.

\sphinxAtStartPar
Consider you intend to share the cropped \sphinxcode{\sphinxupquote{.png}} images you created from the
\sphinxcode{\sphinxupquote{longnow}} logos. Would you publish your \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} dataset so {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}
or {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}, these files would not be available to others, because annexed
dataset contents cannot be published to these services.
Even though you could find a third party service of your choice
and publish your dataset \sphinxstyleemphasis{and} the annexed data as described in  {\hyperref[\detokenize{basics/101-138-sharethirdparty:sharethirdparty}]{\sphinxcrossref{\DUrole{std,std-ref}{Beyond shared infrastructure}}}} (\autopageref*{\detokenize{basics/101-138-sharethirdparty:sharethirdparty}}),
you are feeling lazy today. And since it
is only two files, and they are quite small, you decide to store them in Git \textendash{}
this way, the files would be available without configuring an external data
store.

\sphinxAtStartPar
To get a file out of git\sphinxhyphen{}annex’s hands you need to \sphinxstyleemphasis{unannex} it. This is
done with the git\sphinxhyphen{}annex command \sphinxcode{\sphinxupquote{git annex unannex}}. Let’s see how it
works:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }annex\PYG{+w}{ }unannex\PYG{+w}{ }recordings/*logo\PYGZus{}small.jpg
\PYG{g+go}{unannex recordings/interval\PYGZus{}logo\PYGZus{}small.jpg ok}
\PYG{g+go}{unannex recordings/salt\PYGZus{}logo\PYGZus{}small.jpg ok}
\PYG{g+gp+gpVirtualEnv}{(recording state in git...)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Your dataset notices the unannexing of the files as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }status
\PYG{g+go}{On branch main}
\PYG{g+go}{Changes to be committed:}
\PYG{g+go}{  (use \PYGZdq{}git restore \PYGZhy{}\PYGZhy{}staged \PYGZlt{}file\PYGZgt{}...\PYGZdq{} to unstage)}
\PYG{g+go}{	deleted:    recordings/interval\PYGZus{}logo\PYGZus{}small.jpg}
\PYG{g+go}{	deleted:    recordings/salt\PYGZus{}logo\PYGZus{}small.jpg}

\PYG{g+go}{Untracked files:}
\PYG{g+go}{  (use \PYGZdq{}git add \PYGZlt{}file\PYGZgt{}...\PYGZdq{} to include in what will be committed)}
\PYG{g+go}{	recordings/interval\PYGZus{}logo\PYGZus{}small.jpg}
\PYG{g+go}{	recordings/salt\PYGZus{}logo\PYGZus{}small.jpg}
\end{sphinxVerbatim}

\sphinxAtStartPar
Once files have been unannexed, they are “untracked” again, and you can save them
into Git, either by adding a rule to \sphinxcode{\sphinxupquote{.gitattributes}}, or with
\sphinxcode{\sphinxupquote{datalad save \sphinxhyphen{}\sphinxhyphen{}to\sphinxhyphen{}git}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}\PYGZhy{}to\PYGZhy{}git\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}save cropped logos to Git\PYGZdq{}}\PYG{+w}{ }recordings/*jpg
\PYG{g+go}{add(ok): recordings/interval\PYGZus{}logo\PYGZus{}small.jpg (file)}
\PYG{g+go}{add(ok): recordings/salt\PYGZus{}logo\PYGZus{}small.jpg (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that git\sphinxhyphen{}annex keeps the previously annexed file’s content in the annex for safety, to prevent accidental data loss.
If it is only few and small files that were unannexed, their size in the annex will not matter much.
If it is a lot of files or larger files that were accidentally annexed, you may want to drop the left\sphinxhyphen{}behind content using \sphinxcode{\sphinxupquote{git annex unused}} and \sphinxcode{\sphinxupquote{git annex dropunused}}.

\index{remove dataset annex@\spxentry{remove dataset annex}!with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}}\index{with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}!remove dataset annex@\spxentry{remove dataset annex}}\ignorespaces 

\subsection{Get all content out of the annex (remove the annex)}
\label{\detokenize{basics/101-136-filesystem:get-all-content-out-of-the-annex-remove-the-annex}}\label{\detokenize{basics/101-136-filesystem:uninit}}\label{\detokenize{basics/101-136-filesystem:index-14}}
\sphinxAtStartPar
In case you want to get all annexed contents out of a Dataset at once, you could turn to \sphinxhref{https://git-annex.branchable.com/git-annex-uninit}{git annex uninit}.
It is a command that can be used to stop using git annex entirely in a given dataset.
Running this command will unannex every file in the repository, remove all of git\sphinxhyphen{}annex’s other data, and remove the {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} branch, leaving you with a normal Git repository plus the previously annexed files.

\sphinxAtStartPar
Note a \sphinxcode{\sphinxupquote{datalad push}} will reinstate the git\sphinxhyphen{}annex branch \sphinxstyleemphasis{if} your dataset has siblings that still contain the annex branch.


\subsection{Delete (annexed) files}
\label{\detokenize{basics/101-136-filesystem:delete-annexed-files}}
\sphinxAtStartPar
Removing annexed file content from a dataset is possible in two different ways:
Either by removing the file from the current state of the repository
(which Git calls the \sphinxstyleemphasis{worktree}) but keeping the content in the history
of the dataset, or by removing content entirely from a dataset and its
history.

\index{remove file@\spxentry{remove file}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!remove file@\spxentry{remove file}}\ignorespaces 

\subsubsection{Removing a file, but keeping content in history}
\label{\detokenize{basics/101-136-filesystem:removing-a-file-but-keeping-content-in-history}}\label{\detokenize{basics/101-136-filesystem:index-15}}
\sphinxAtStartPar
An \sphinxcode{\sphinxupquote{rm \textless{}file\textgreater{}}} or \sphinxcode{\sphinxupquote{rm \sphinxhyphen{}rf \textless{}directory\textgreater{}}} with a subsequent \sphinxcode{\sphinxupquote{datalad save}}
will remove a file or directory, and save its removal. The file content however will
still be in the history of the dataset, and the file can be brought back to existence
by going back into the history of the dataset or reverting the removal commit:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} download a file}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }download\PYGZhy{}url\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Added flower mosaic from wikimedia\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }https://upload.wikimedia.org/wikipedia/commons/a/a5/Flower\PYGZus{}poster\PYGZus{}2.jpg\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{  }\PYGZhy{}\PYGZhy{}path\PYG{+w}{ }flowers.jpg
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }flowers.jpg
\PYG{g+go}{download\PYGZus{}url(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/flowers.jpg (file)}
\PYG{g+go}{add(ok): flowers.jpg (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{lrwxrwxrwx 1 elena elena 128 2019\PYGZhy{}06\PYGZhy{}18 16:13  2013 flowers.jpg \PYGZhy{}\PYGZgt{} .git/annex/objects/7q/9Z/✂/MD5E\PYGZhy{}s4487679\PYGZhy{}\PYGZhy{}3898ef0e✂MD5.jpg}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} removal is easy:}
\PYG{g+gp}{\PYGZdl{} }rm\PYG{+w}{ }flowers.jpg
\end{sphinxVerbatim}

\sphinxAtStartPar
This will lead to a dirty dataset status:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{  deleted: flowers.jpg (symlink)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If a removal happened by accident, a \sphinxcode{\sphinxupquote{git checkout \sphinxhyphen{}\sphinxhyphen{} flowers.jpg}} would undo
the removal at this stage. To stick with the removal and clean up the dataset
state, \sphinxcode{\sphinxupquote{datalad save}} will suffice:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}removed file again\PYGZdq{}}
\PYG{g+go}{delete(ok): flowers.jpg (symlink)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This commits the deletion of the file in the dataset’s history.
If this commit is reverted, the file comes back to existence:

\fvset{hllines={, 6,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}1
\PYG{g+gp}{\PYGZdl{} }ls
\PYG{g+go}{HEAD is now at 682d11f Added flower mosaic from wikimedia}
\PYG{g+go}{books}
\PYG{g+go}{code}
\PYG{g+go}{flowers.jpg}
\PYG{g+go}{midterm\PYGZus{}project}
\PYG{g+go}{notes.txt}
\PYG{g+go}{recordings}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
In other words, with an \sphinxcode{\sphinxupquote{ rm}} and subsequent \sphinxcode{\sphinxupquote{datalad save}},
the symlink is removed, but the content is retained in the history.

\index{drop@\spxentry{drop}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!drop@\spxentry{drop}}\index{remove file@\spxentry{remove file}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!remove file@\spxentry{remove file}}\ignorespaces 

\subsubsection{Remove annexed content entirely}
\label{\detokenize{basics/101-136-filesystem:remove-annexed-content-entirely}}\label{\detokenize{basics/101-136-filesystem:remove}}\label{\detokenize{basics/101-136-filesystem:index-16}}
\sphinxAtStartPar
The command to remove file content entirely and irreversibly from a repository is
the \sphinxcode{\sphinxupquote{datalad drop}} command.
This command will delete the content stored in the annex of the dataset,
and can be very helpful to make a dataset more lean if the file content is
either irrelevant or can be retrieved from other sources easily. Think about a
situation in which a very large result file is computed by default
in some analysis, but is not relevant for any project, and can thus be removed.
Or if only the results of an analysis need to be kept, but the file contents from
its input datasets can be dropped at these input datasets are backed\sphinxhyphen{}up else
where. Because the command works on annexed contents, it will drop file \sphinxstyleemphasis{content}
from a dataset, but it will retain the symlink for this file (as this symlink
is stored in Git).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datalad drop}} can take any number of files.
If an entire dataset is specified, all file content in sub\sphinxhyphen{}\sphinxstyleemphasis{directories} is
dropped automatically, but for content in sub\sphinxhyphen{}\sphinxstyleemphasis{datasets} to be dropped, the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}r/\sphinxhyphen{}\sphinxhyphen{}recursive}} flag has to be included.
By default, DataLad will not drop any content that does not have at least
one verified remote copy that the content could be retrieved from again.
It is possible to drop the downloaded image, because thanks to
\sphinxcode{\sphinxupquote{datalad download\sphinxhyphen{}url}} its original location in the web is known:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }drop\PYG{+w}{ }flowers.jpg
\PYG{g+go}{drop(ok): flowers.jpg (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Currently, the file content is gone, but the symlink still exist. Opening the
remaining symlink will fail, but the content can be obtained easily again with
\sphinxcode{\sphinxupquote{datalad get}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }flowers.jpg
\PYG{g+go}{get(ok): flowers.jpg (file) [from web...]}
\end{sphinxVerbatim}

\sphinxAtStartPar
If a file has no verified remote copies, DataLad will only drop its
content if the user enforces it using the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}reckless {[}MODE{]}}} option, where \sphinxcode{\sphinxupquote{{[}MODE{]}}} is either \sphinxcode{\sphinxupquote{modification}} (drop despite unsaved modifications), \sphinxcode{\sphinxupquote{availability}} (drop even though no other copy is known), \sphinxcode{\sphinxupquote{undead}} (only for datasets; would drop a dataset without announcing its death to linked dataset clones) or \sphinxcode{\sphinxupquote{kill}} (no safety checks at all are run).
We will demonstrate this by generating an empty file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }dd\PYG{+w}{ }\PYG{k}{if}\PYG{o}{=}/dev/zero\PYG{+w}{ }\PYG{p}{|}\PYG{+w}{ }head\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }\PYG{l+m}{18520}\PYG{+w}{ }\PYGZgt{}\PYG{+w}{ }a.pdf
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add some file\PYGZdq{}}\PYG{+w}{ }a.pdf
\PYG{g+go}{add(ok): a.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
DataLad will safeguard dropping content that it cannot retrieve again:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }drop\PYG{+w}{ }a.pdf
\PYG{g+go}{drop(error): a.pdf (file) [unsafe; Could only verify the existence of 0 out of 1 necessary copy; (Use \PYGZhy{}\PYGZhy{}reckless availability to override this check, or adjust numcopies.)]}
\end{sphinxVerbatim}

\sphinxAtStartPar
But with \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}reckless availability}} it will work:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }drop\PYG{+w}{ }\PYGZhy{}\PYGZhy{}reckless\PYG{+w}{ }availability\PYG{+w}{ }a.pdf
\PYG{g+go}{drop(ok): a.pdf (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note though that this file content is irreversibly gone now, and
even going back in time in the history of the dataset will not bring it
back into existence.

\sphinxAtStartPar
Finally, let’s clean up:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }HEAD\PYGZti{}2
\PYG{g+go}{HEAD is now at c278f6a save cropped logos to Git}
\end{sphinxVerbatim}

\index{remove file@\spxentry{remove file}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!remove file@\spxentry{remove file}}\ignorespaces 

\subsection{Delete content stored in Git}
\label{\detokenize{basics/101-136-filesystem:delete-content-stored-in-git}}\label{\detokenize{basics/101-136-filesystem:index-17}}
\sphinxAtStartPar
It is much harder to delete dataset content that is stored in Git compared to
content stored in git\sphinxhyphen{}annex.
Operations such as \sphinxcode{\sphinxupquote{rm}} or \sphinxcode{\sphinxupquote{git rm}} remove the file from the \sphinxstyleemphasis{worktree},
but not from its history, and they can be brought back to life just as annexed
contents that were solely \sphinxcode{\sphinxupquote{rm}}\textquotesingle{}ed. There is also no straightforward
Git equivalent of \sphinxcode{\sphinxupquote{drop}}.
To accomplish a complete removal of a file from a dataset, we recommend the external tool
\sphinxhref{https://github.com/newren/git-filter-repo}{git\sphinxhyphen{}filter\sphinxhyphen{}repo}.
It is a powerful and potentially very dangerous tool to rewrite Git history.

\sphinxAtStartPar
Usually, removing files stored in Git completely
is not a common or recommended operation, as it involves quite aggressive
rewriting of the dataset history. Sometimes, however, sensitive files, for example
private {\hyperref[\detokenize{glossary:term-SSH-key}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH key}}}}s or passwords, or too many or too large files are
accidentally saved into Git, and \sphinxstyleemphasis{need} to get out of the dataset history.
The command \sphinxcode{\sphinxupquote{git\sphinxhyphen{}filter\sphinxhyphen{}repo \textless{}path\sphinxhyphen{}specification\textgreater{} \sphinxhyphen{}\sphinxhyphen{}force}} will “filter\sphinxhyphen{}out”,
i.e., remove all files \sphinxstylestrong{but the ones specified} in \sphinxcode{\sphinxupquote{\textless{}path\sphinxhyphen{}specification\textgreater{}}}
from the dataset’s history. An advanced chapter in the online\sphinxhyphen{}handbook
shows an example invocation.


\section{Remove datasets}
\label{\detokenize{basics/101-136-filesystem:remove-datasets}}
\index{uninstall dataset@\spxentry{uninstall dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!uninstall dataset@\spxentry{uninstall dataset}}\index{drop dataset@\spxentry{drop dataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!drop dataset@\spxentry{drop dataset}}\index{drop@\spxentry{drop}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!drop@\spxentry{drop}}\ignorespaces 

\subsection{Uninstall or delete subdatasets}
\label{\detokenize{basics/101-136-filesystem:uninstall-or-delete-subdatasets}}\label{\detokenize{basics/101-136-filesystem:index-18}}
\sphinxAtStartPar
Depending on the exact aim, different commands are relevant for
deleting a DataLad subdataset.
One way to uninstall a dataset is the \sphinxcode{\sphinxupquote{datalad drop}} command.
To work on datasets, \sphinxcode{\sphinxupquote{drop}} needs to be parametrized with \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}what all}}.
If needed, add \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}recursive}} in case the dataset contains subdatasets, and a
fitting \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}reckless}} mode, such as \sphinxcode{\sphinxupquote{datalad drop \sphinxhyphen{}\sphinxhyphen{}what all \sphinxhyphen{}\sphinxhyphen{}reckless kill \sphinxhyphen{}\sphinxhyphen{}recursive}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} clone a subdataset \PYGZhy{} the content is irrelevant, so why not a cloud :)}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }clone\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{ }https://github.com/datalad\PYGZhy{}datasets/disneyanimation\PYGZhy{}cloud.git\PYG{+w}{ }\PYG{l+s+se}{\PYGZbs{}}
\PYG{+w}{ }cloud
\PYG{g+go}{[INFO] Remote origin not usable by git\PYGZhy{}annex; setting annex\PYGZhy{}ignore}
\PYG{g+go}{install(ok): cloud (dataset)}
\PYG{g+go}{add(ok): cloud (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
To uninstall the dataset, you can use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }drop\PYG{+w}{ }\PYGZhy{}\PYGZhy{}what\PYG{+w}{ }all\PYG{+w}{ }\PYGZhy{}\PYGZhy{}reckless\PYG{+w}{ }\PYG{n+nb}{kill}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}recursive\PYG{+w}{ }cloud
\PYG{g+go}{uninstall(ok): cloud (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}reckless kill}} sounds bad, but is harmless here: we just clones this dataset, and we know we did not do anything locally that is worth keeping.

\sphinxAtStartPar
Note that the dataset is still known in the dataset, and not completely removed.
A \sphinxcode{\sphinxupquote{datalad get {[}\sphinxhyphen{}n/\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}data{]} cloud}} would install the dataset again.

\index{remove@\spxentry{remove}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!remove@\spxentry{remove}}\ignorespaces 
\sphinxAtStartPar
In case one wants to fully delete a subdataset from a dataset, the
\sphinxcode{\sphinxupquote{datalad remove}} command is relevant%
\begin{footnote}[3]\sphinxAtStartFootnote
This is indeed the only case in which \sphinxcode{\sphinxupquote{datalad remove}} is
relevant. For all other cases of content deletion a normal \sphinxcode{\sphinxupquote{rm}}
with a subsequent \sphinxcode{\sphinxupquote{datalad save}} works best.
%
\end{footnote}.
It needs a pointer to the root of the superdataset with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}d/\sphinxhyphen{}\sphinxhyphen{}dataset}}
flag, a path to the subdataset to be removed, and optionally a commit message
(\sphinxcode{\sphinxupquote{\sphinxhyphen{}m/\sphinxhyphen{}\sphinxhyphen{}message}}) or recursive specification (\sphinxcode{\sphinxupquote{\sphinxhyphen{}r/\sphinxhyphen{}\sphinxhyphen{}recursive}}).
To remove a subdataset, we will install the uninstalled subdataset again, and
subsequently remove it with the \sphinxcode{\sphinxupquote{datalad remove}} command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }cloud
\PYG{g+go}{[INFO] Remote origin not usable by git\PYGZhy{}annex; setting annex\PYGZhy{}ignore}
\PYG{g+go}{install(ok): /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/cloud (dataset) [Installed subdataset in order to get /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/cloud]}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} delete the subdataset}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }remove\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}remove obsolete subds\PYGZdq{}}\PYG{+w}{ }\PYGZhy{}d\PYG{+w}{ }.\PYG{+w}{ }cloud
\PYG{g+go}{uninstall(ok): cloud (dataset)}
\PYG{g+go}{remove(ok): cloud (dataset)}
\PYG{g+go}{add(ok): .gitmodules (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that for both commands a pointer to the \sphinxstyleemphasis{current directory} will not work.
\sphinxcode{\sphinxupquote{datalad remove .}} or \sphinxcode{\sphinxupquote{datalad drop .}} will fail, even if
the command is executed in a subdataset instead of the top\sphinxhyphen{}level
superdataset \textendash{} you need to execute the command from a higher\sphinxhyphen{}level directory.

\index{uninstall superdataset@\spxentry{uninstall superdataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!uninstall superdataset@\spxentry{uninstall superdataset}}\index{drop superdataset@\spxentry{drop superdataset}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!drop superdataset@\spxentry{drop superdataset}}\ignorespaces 

\subsection{Delete a superdataset}
\label{\detokenize{basics/101-136-filesystem:delete-a-superdataset}}\label{\detokenize{basics/101-136-filesystem:index-20}}
\sphinxAtStartPar
If for whatever reason you at one point tried to remove a DataLad dataset,
whether with a GUI or the command line call \sphinxcode{\sphinxupquote{rm \sphinxhyphen{}rf \textless{}directory\textgreater{}}}, you likely
have seen permission denied errors such as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{rm: cannot remove \PYGZsq{}\PYGZlt{}directory\PYGZgt{}/.git/annex/objects/Mz/M1/MD5E\PYGZhy{}s422982\PYGZhy{}\PYGZhy{}2977b5c6ea32de1f98689bc42613aac7.jpg/MD5E\PYGZhy{}s422982\PYGZhy{}\PYGZhy{}2977b5c6ea32de1f98689bc42613aac7.jpg\PYGZsq{}: Permission denied}
\PYG{g+go}{rm: cannot remove \PYGZsq{}\PYGZlt{}directory\PYGZgt{}/.git/annex/objects/FP/wv/MD5E\PYGZhy{}s543180\PYGZhy{}\PYGZhy{}6209797211280fc0a95196b0f781311e.jpg/MD5E\PYGZhy{}s543180\PYGZhy{}\PYGZhy{}6209797211280fc0a95196b0f781311e.jpg\PYGZsq{}: Permission denied}
\PYG{g+go}{ [...]}
\end{sphinxVerbatim}

\sphinxAtStartPar
This error indicates that there is write\sphinxhyphen{}protected content within \sphinxcode{\sphinxupquote{.git}} that
cannot not be deleted. What is this write\sphinxhyphen{}protected content? It’s the file content
stored in the object tree of git\sphinxhyphen{}annex. If you want, you can re\sphinxhyphen{}read the section on
{\hyperref[\detokenize{basics/101-115-symlinks:symlink}]{\sphinxcrossref{\DUrole{std,std-ref}{Data integrity}}}} (\autopageref*{\detokenize{basics/101-115-symlinks:symlink}}) to find out how git\sphinxhyphen{}annex revokes write permission for the user
to protect the file content given to it. To remove a dataset with annexed content
one has to regain write permissions to everything in the dataset. This is done
with the Unix \sphinxcode{\sphinxupquote{chmod}} command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }chmod\PYG{+w}{ }\PYGZhy{}R\PYG{+w}{ }u+w\PYG{+w}{ }\PYGZlt{}dataset\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
This \sphinxstyleemphasis{recursively} (\sphinxcode{\sphinxupquote{\sphinxhyphen{}R}}, i.e., throughout all files and (sub)directories) gives users
(\sphinxcode{\sphinxupquote{u}}) write permissions (\sphinxcode{\sphinxupquote{+w}}) for the dataset.

\sphinxAtStartPar
Afterwards, \sphinxcode{\sphinxupquote{rm \sphinxhyphen{}rf \textless{}dataset\textgreater{}}} will succeed.

\sphinxAtStartPar
However, instead of \sphinxcode{\sphinxupquote{rm \sphinxhyphen{}rf}}, a faster way to remove a dataset is using \sphinxcode{\sphinxupquote{datalad drop}}: Run \sphinxcode{\sphinxupquote{datalad drop \sphinxhyphen{}d \textless{}dataset\textgreater{}}} outside of the
superdataset to remove a top\sphinxhyphen{}level dataset with all its contents. Likely,
both  \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}recursive}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}reckless {[}availability|undead|kill{]}}} flags are necessary
to traverse into subdatasets and to remove content that does not have verified remotes.
\begin{importantnote}[before title={\thetcbcounter\ }, check odd page=true]{Deleting a dataset clone cannot be undone!}

\sphinxAtStartPar
Be aware that deleting a dataset clone in which ever way will
irrevocably delete the clone, it’s contents, and it’s history.
Unless another clone still exists elsewhere, the dataset will be gone forever.


\end{importantnote}


\section{Summary}
\label{\detokenize{basics/101-136-filesystem:summary}}
\sphinxAtStartPar
To sum up, file system management operations are safe and easy.
Even if you are currently confused about one or two operations,
worry not \textendash{} the take\sphinxhyphen{}home\sphinxhyphen{}message is simple: Use \sphinxcode{\sphinxupquote{datalad save}}
whenever you move or rename files. Be mindful that a \sphinxcode{\sphinxupquote{datalad status}}
can appear unintuitive or that symlinks can break if annexed files are moved,
but all of these problems are solved after a \sphinxcode{\sphinxupquote{datalad save}} command.
Apart from this command, having a clean dataset status prior to doing anything
is your friend as well. It will make sure that you have a neat and organized
commit history, and no accidental commits of changes unrelated to your file
system management operations. The only operation you should beware of is
moving subdatasets around \textendash{} this can be a minefield.
With all of these experiences and tips, you feel confident that you know
how to handle your datasets files and directories well and worry\sphinxhyphen{}free.

\sphinxstepscope


\chapter{Git things done}
\label{\detokenize{basics/101-137-history:git-things-done}}\label{\detokenize{basics/101-137-history:history}}\label{\detokenize{basics/101-137-history::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{versioncontrol}.pdf}\hspace*{\fill}}

\sphinxAtStartPar
Almost everyone inadvertently deleted or overwrote files at some point with
a hasty operation that caused data fatalities or at least troubles to
reobtain or restore data.
With DataLad, no mistakes are forever: One powerful feature of datasets
is the ability to revert data to a previous state and thus view earlier content or
correct mistakes. As long as the content was version controlled (i.e., tracked),
it is possible to look at previous states of the data, or revert changes \textendash{}
even years after they happened \textendash{} thanks to the underlying version control
system {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}}.

\sphinxAtStartPar
To get a glimpse into how to work with the history of a dataset, today’s lecture
has an external Git\sphinxhyphen{}expert as a guest lecturer.
“I do not have enough time to go through all the details in only
one lecture. But I’ll give you the basics, and an idea of what is possible.
Always remember: Just google what you need. You will find thousands of helpful tutorials
or questions on \sphinxhref{https://stackoverflow.com}{Stack Overflow} right away.
Even experts will \sphinxstyleemphasis{constantly} seek help to find out which Git command to
use, and how to use it.”, he reassures with a wink.

\sphinxAtStartPar
The basis of working with the history is to \sphinxstyleemphasis{look at it} with tools such
as {\hyperref[\detokenize{glossary:term-tig}]{\sphinxtermref{\DUrole{xref,std,std-term}{tig}}}}, {\hyperref[\detokenize{glossary:term-gitk}]{\sphinxtermref{\DUrole{xref,std,std-term}{gitk}}}}, or simply the \sphinxcode{\sphinxupquote{git log}} command.
The most important information in an entry (commit) in the history is
the {\hyperref[\detokenize{glossary:term-shasum}]{\sphinxtermref{\DUrole{xref,std,std-term}{shasum}}}} (or hash) associated with it.
This hash is how dataset modifications in the history are identified,
and with this hash you can communicate with DataLad or {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} about these
modifications or version states%
\begin{footnote}[1]\sphinxAtStartFootnote
For example, the \sphinxcode{\sphinxupquote{datalad rerun}} command introduced in section
{\hyperref[\detokenize{basics/101-109-rerun:run2}]{\sphinxcrossref{\DUrole{std,std-ref}{DataLad, rerun!}}}} (\autopageref*{\detokenize{basics/101-109-rerun:run2}}) takes such a hash as an argument, and re\sphinxhyphen{}executes
the \sphinxcode{\sphinxupquote{datalad run}} or \sphinxcode{\sphinxupquote{datalad rerun}} {\hyperref[\detokenize{glossary:term-run-record}]{\sphinxtermref{\DUrole{xref,std,std-term}{run record}}}} associated with
this hash. Likewise, the \sphinxcode{\sphinxupquote{git diff}} command can work with commit hashes.
%
\end{footnote}.
Here is an excerpt from the \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} history to show a
few abbreviated hashes of the 15 most recent commits%
\begin{footnote}[2]\sphinxAtStartFootnote
There are other alternatives to reference commits in the history of a dataset,
for example, “counting” ancestors of the most recent commit using the notation
\sphinxcode{\sphinxupquote{HEAD\textasciitilde{}2}}, \sphinxcode{\sphinxupquote{HEAD\textasciicircum{}2}} or \sphinxcode{\sphinxupquote{HEAD@\{2\}}}. However, using hashes to reference
commits is a very fail\sphinxhyphen{}save method and saves you from accidentally miscounting.
%
\end{footnote}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}15\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{996f459 remove obsolete subds}
\PYG{g+go}{15acb2a [DATALAD] Added subdataset}
\PYG{g+go}{c278f6a save cropped logos to Git}
\PYG{g+go}{de2d23c move book back from midterm\PYGZus{}project}
\PYG{g+go}{a648756 move book into midterm\PYGZus{}project}
\PYG{g+go}{39e55c8 add container and execute analysis within container}
\PYG{g+go}{c5c9017 finished my midterm project}
\PYG{g+go}{0edd3ea [DATALAD] Recorded changes}
\PYG{g+go}{08684a4 add note on DataLad\PYGZsq{}s procedures}
\PYG{g+go}{c2400da add note on configurations and git config}
\PYG{g+go}{e202e94 Add note on adding siblings}
\PYG{g+go}{6ae8e71 Merge remote\PYGZhy{}tracking branch \PYGZsq{}roommate/main\PYGZsq{}}
\PYG{g+go}{4bb5d39 add note about datalad update}
\PYG{g+go}{5b6e19a Include nesting demo from datalad website}
\PYG{g+go}{adb4b5d add note on git annex whereis}
\end{sphinxVerbatim}

\sphinxAtStartPar
“I’ll let you people direct this lecture”, the guest lecturer proposes.
“You tell me what you would be interested in doing, and I’ll show you how it’s
done. For the rest of the lecture, call me Google!”


\section{Fix commit messages}
\label{\detokenize{basics/101-137-history:fix-commit-messages}}
\sphinxAtStartPar
From the back of the lecture hall comes a question you are really glad
someone asked: “It has happened to me that I accidentally did a
\sphinxcode{\sphinxupquote{datalad save}} and forgot to specify the commit message,
how can I fix this?”.
The room nods in agreement \textendash{} apparently, others have run into this
premature slip of the \sphinxcode{\sphinxupquote{Enter}} key as well.

\sphinxAtStartPar
Let’s demonstrate a simple example. First, let’s create some random files.
Do this right in your dataset.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYG{+w}{ }Gitjoke1.txt
\PYG{g+go}{Git knows what you did last summer!}
\PYG{g+go}{EOT}

\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYG{+w}{ }Gitjoke2.txt
\PYG{g+go}{Knock knock. Who\PYGZsq{}s there? Git.}
\PYG{g+go}{Git\PYGZhy{}who?}
\PYG{g+go}{Sorry, \PYGZsq{}who\PYGZsq{} is not a git command \PYGZhy{} did you mean \PYGZsq{}show\PYGZsq{}?}
\PYG{g+go}{EOT}

\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYG{+w}{ }Gitjoke3.txt
\PYG{g+go}{In Soviet Russia, git commits YOU!}
\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\sphinxAtStartPar
This will generate three new files in your dataset. Run a
\sphinxcode{\sphinxupquote{datalad status}} to verify this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: Gitjoke1.txt (file)}
\PYG{g+go}{untracked: Gitjoke2.txt (file)}
\PYG{g+go}{untracked: Gitjoke3.txt (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
And now:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save
\PYG{g+go}{add(ok): Gitjoke1.txt (file)}
\PYG{g+go}{add(ok): Gitjoke2.txt (file)}
\PYG{g+go}{add(ok): Gitjoke3.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Whooops! A \sphinxcode{\sphinxupquote{datalad save}} without a
commit message that saved all of the files.

\fvset{hllines={, 6,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}p\PYG{+w}{ }\PYGZhy{}1
\PYG{g+go}{commit 58e40d9a✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    [DATALAD] Recorded changes}

\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/Gitjoke1.txt b/Gitjoke1.txt}
\PYG{g+go}{new file mode 100644}
\PYG{g+go}{index 0000000..d7e1359}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/Gitjoke1.txt}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1 @@}
\PYG{g+go}{+Git knows what you did last summer!}
\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/Gitjoke2.txt b/Gitjoke2.txt}
\PYG{g+go}{new file mode 100644}
\PYG{g+go}{index 0000000..51beecb}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/Gitjoke2.txt}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1,3 @@}
\PYG{g+go}{+Knock knock. Who\PYGZsq{}s there? Git.}
\PYG{g+go}{+Git\PYGZhy{}who?}
\PYG{g+go}{+Sorry, \PYGZsq{}who\PYGZsq{} is not a git command \PYGZhy{} did you mean \PYGZsq{}show\PYGZsq{}?}
\PYG{g+go}{diff \PYGZhy{}\PYGZhy{}git a/Gitjoke3.txt b/Gitjoke3.txt}
\PYG{g+go}{new file mode 100644}
\PYG{g+go}{index 0000000..7b83d95}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{} /dev/null}
\PYG{g+go}{+++ b/Gitjoke3.txt}
\PYG{g+go}{@@ \PYGZhy{}0,0 +1 @@}
\PYG{g+go}{+In Soviet Russia, git commits YOU!}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
As expected, all of the modifications present prior to the
command are saved into the most recent commit, and the commit
message DataLad provides by default, \sphinxcode{\sphinxupquote{{[}DATALAD{]} Recorded changes}},
is not very helpful.

\sphinxAtStartPar
Changing the commit message of the most recent commit can be done with
the command \sphinxcode{\sphinxupquote{git commit \sphinxhyphen{}\sphinxhyphen{}amend}}. Running this command will open
an editor (the default, as configured in Git), and allow you
to change the commit message. Make sure to read the {\hyperref[\detokenize{basics/101-137-history:fom-rebase1}]{\sphinxcrossref{\DUrole{std,std-ref}{find\sphinxhyphen{}out\sphinxhyphen{}more on changing other than the most recent commit}}}} (\autopageref*{\detokenize{basics/101-137-history:fom-rebase1}}) in case you want to improve the commit message of more commits than only the latest.

\sphinxAtStartPar
Try running the \sphinxcode{\sphinxupquote{git commit \sphinxhyphen{}\sphinxhyphen{}amend}} command right now and give
the commit a new commit message (you can just delete the one created by
DataLad in the editor)!

\index{save \sphinxhyphen{}\sphinxhyphen{}amend@\spxentry{save \sphinxhyphen{}\sphinxhyphen{}amend}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!save \sphinxhyphen{}\sphinxhyphen{}amend@\spxentry{save \sphinxhyphen{}\sphinxhyphen{}amend}}\index{add changes to previous commit@\spxentry{add changes to previous commit}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!add changes to previous commit@\spxentry{add changes to previous commit}}\index{change the last commit message@\spxentry{change the last commit message}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!change the last commit message@\spxentry{change the last commit message}}\ignorespaces \begin{gitusernote}[label={index-0}, before title={\thetcbcounter\ }, check odd page=true]{‘git commit –amend’ versus ‘datalad save –amend’}
\label{\detokenize{basics/101-137-history:index-0}}

\sphinxAtStartPar
Similar to \sphinxcode{\sphinxupquote{git commit}}, \sphinxcode{\sphinxupquote{datalad save}} also has an \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}amend}} option.
Like its Git equivalent, it can be used to record changes not in a new, separate commit, but integrate them with the previously saved state.
Though this has not been the use case for \sphinxcode{\sphinxupquote{git commit \sphinxhyphen{}\sphinxhyphen{}amend}} here, experienced Git users will be accustomed to using \sphinxcode{\sphinxupquote{git commit \sphinxhyphen{}\sphinxhyphen{}amend}} to achieve something similar in their Git workflows.
In contrast to \sphinxcode{\sphinxupquote{git commit \sphinxhyphen{}\sphinxhyphen{}amend}}, \sphinxcode{\sphinxupquote{datalad save \sphinxhyphen{}\sphinxhyphen{}amend}} will not open up an interactive editor to potentially change a commit message (unless the configuration \sphinxcode{\sphinxupquote{datalad.save.no\sphinxhyphen{}message}} is set to \sphinxcode{\sphinxupquote{interactive}}), but a new commit message can be supplied with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}m}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}message}} option.


\end{gitusernote}

\index{change historical commit messages@\spxentry{change historical commit messages}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!change historical commit messages@\spxentry{change historical commit messages}}\index{rebase@\spxentry{rebase}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!rebase@\spxentry{rebase}}\index{rewrite history@\spxentry{rewrite history}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!rewrite history@\spxentry{rewrite history}}\ignorespaces \begin{findoutmore}[label={fom-rebase1}, before title={\thetcbcounter\ }, float, check odd page=true]{Changing the commit messages of not-the-most-recent commits}
\label{\detokenize{basics/101-137-history:fom-rebase1}}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{git commit \sphinxhyphen{}\sphinxhyphen{}amend}} command will let you
rewrite the commit message of the most recent commit. However, if you
need to rewrite commit messages of older commits, you
can do with an “interactive rebase”:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }rebase\PYG{+w}{ }\PYGZhy{}\PYGZhy{}interactive\PYG{+w}{ }HEAD\PYGZti{}N
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{N}} specifies how far back you want to rewrite commits.
\sphinxcode{\sphinxupquote{git rebase \sphinxhyphen{}i HEAD\textasciitilde{}3}}, for example, lets you apply changes to the
any number of commit messages within the last three commits.

\sphinxAtStartPar
Be aware that an interactive rebase lets you \sphinxstyleemphasis{rewrite} history.
This can lead to confusion or worse if the history you are rewriting
is shared with others, for example, in a collaborative project. Be also aware
that rewriting history that is \sphinxstyleemphasis{pushed}/\sphinxstyleemphasis{published} to another location
will require a force\sphinxhyphen{}push!

\sphinxAtStartPar
Running this command yields a list of the N most recent commits
in a text editor (which may be {\hyperref[\detokenize{glossary:term-vim}]{\sphinxtermref{\DUrole{xref,std,std-term}{vim}}}}!), with
the most recent commit at the bottom:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pick 8503f26 Add note on adding siblings
pick 23f0a52 add note on configurations and git config
pick c42cba4 add note on DataLad\PYGZsq{}s procedures

\PYGZsh{} Rebase b259ce8..c42cba4 onto b259ce8 (3 commands)
\PYGZsh{}
\PYGZsh{} Commands:
\PYGZsh{} p, pick \PYGZlt{}commit\PYGZgt{} = use commit
\PYGZsh{} r, reword \PYGZlt{}commit\PYGZgt{} = use commit, but edit the commit message
\PYGZsh{} s, squash \PYGZlt{}commit\PYGZgt{} = use commit, but meld into previous commit
\PYGZsh{} f, fixup \PYGZlt{}commit\PYGZgt{} = like \PYGZdq{}squash\PYGZdq{}, but discard this commit\PYGZsq{}s log message
\PYGZhy{}✂\PYGZhy{}\PYGZhy{}✂\PYGZhy{}
\end{sphinxVerbatim}

\sphinxAtStartPar
With an interactive rebase we can apply various modifications to any
number of commits in the list. Below the list are examples for some of these
actions. Among them is “reword”, which lets you “edit the commit
message”. To apply this action and reword the top\sphinxhyphen{}most commit message in this list
(\sphinxcode{\sphinxupquote{8503f26 Add note on adding siblings}}, three commits back in the history),
exchange the word \sphinxcode{\sphinxupquote{pick}} in the beginning of the line with the word
\sphinxcode{\sphinxupquote{reword}} or simply \sphinxcode{\sphinxupquote{r}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
r\PYG{+w}{ }8503f26\PYG{+w}{ }Add\PYG{+w}{ }note\PYG{+w}{ }on\PYG{+w}{ }adding\PYG{+w}{ }siblings
\end{sphinxVerbatim}

\sphinxAtStartPar
If you want to reword more than one commit message, exchange several
\sphinxcode{\sphinxupquote{pick}}s. Any commit with the word \sphinxcode{\sphinxupquote{pick}} at the beginning of the line will
be kept as is. Once you are done, save and close the editor. This will
sequentially open up a new editor for each commit you want to reword. In
it, you will be able to change the commit message. Save to proceed to
the next commit message until the rebase is complete.

\sphinxAtStartPar
Be careful not to delete any lines in the above editor view \textendash{}
\sphinxstylestrong{An interactive rebase can be dangerous, and if you remove a line, this commit will be lost!}


\end{findoutmore}

\index{stop content tracking@\spxentry{stop content tracking}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!stop content tracking@\spxentry{stop content tracking}}\ignorespaces 

\section{Change history}
\label{\detokenize{basics/101-137-history:change-history}}\label{\detokenize{basics/101-137-history:index-2}}

\subsection{Untracking accidentally saved contents (tracked in Git)}
\label{\detokenize{basics/101-137-history:untracking-accidentally-saved-contents-tracked-in-git}}
\sphinxAtStartPar
The next question comes from the front:
“It happened that I forgot to give a path to the \sphinxcode{\sphinxupquote{datalad save}}
command when I wanted to only start tracking a very specific file.
Other times I just didn’t remember that
additional, untracked files existed in the dataset and saved unaware of
those. I know that it is good practice to only save
those changes together that belong together, so is there a way to
disentangle an accidental \sphinxcode{\sphinxupquote{datalad save}} again?”

\sphinxAtStartPar
Let’s say instead of saving \sphinxstyleemphasis{all three} previously untracked Git jokes
you intended to save \sphinxstyleemphasis{only one} of those files. What we
want to achieve is to keep all of the files and their contents
in the dataset, but get them out of the history into an
\sphinxstyleemphasis{untracked} state again, and save them \sphinxstyleemphasis{individually} afterwards.
\begin{importantnote}[before title={\thetcbcounter\ }, check odd page=true]{Untracking is different for Git versus git-annex!}

\sphinxAtStartPar
Note that this is a case with \sphinxstyleemphasis{text files} (stored in Git)! For
accidental annexing of files, please make sure to check out
the next paragraph!


\end{importantnote}

\sphinxAtStartPar
This is a task for the \sphinxcode{\sphinxupquote{git reset}} command. It essentially allows to
undo commits by resetting the history of a dataset to an earlier version.
\sphinxcode{\sphinxupquote{git reset}} comes with several \sphinxstyleemphasis{modes} that determine the
exact behavior it, but the relevant one for this aim is \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}mixed}}%
\begin{footnote}[3]\sphinxAtStartFootnote
The option \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}mixed}} is the default mode for a \sphinxcode{\sphinxupquote{git reset}}
command, omitting it (i.e., running just \sphinxcode{\sphinxupquote{git reset}}) leads to the
same behavior. It is explicitly stated in this book to make the mode
clear, though.
%
\end{footnote}.
Specifying the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}mixed\PYG{+w}{ }COMMIT
\end{sphinxVerbatim}

\sphinxAtStartPar
will preserve all changes made to files since the specified
commit in the dataset but remove them from the dataset’s history.
This means all commits \sphinxstyleemphasis{since} \sphinxcode{\sphinxupquote{COMMIT}} (but \sphinxstyleemphasis{not including} \sphinxcode{\sphinxupquote{COMMIT}})
will not be in your history anymore and become “untracked files” or
“unsaved changes” instead. In other words, the modifications
you made in these commits that are “undone” will still be present
in your dataset \textendash{} just not written to the history anymore. Let’s
try this to get a feel for it.

\sphinxAtStartPar
The COMMIT in the command can either be a hash or a reference
with the HEAD pointer. Take a look at the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-git-heads}} {\hyperref[\detokenize{basics/101-137-history:fom-git-heads}]{\sphinxcrossref{\DUrole{std,std-ref}{on terminology}}}} (\autopageref*{\detokenize{basics/101-137-history:fom-git-heads}}) for more on these Git concepts.

\index{branch@\spxentry{branch}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!branch@\spxentry{branch}}\index{HEAD@\spxentry{HEAD}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!HEAD@\spxentry{HEAD}}\ignorespaces \begin{findoutmore}[label={fom-git-heads}, before title={\thetcbcounter\ }, float, floatplacement=tbp, check odd page=true]{Git terminology: branches and HEADs?}
\label{\detokenize{basics/101-137-history:fom-git-heads}}

\sphinxAtStartPar
A Git repository (and thus any DataLad dataset) is built up as a tree of
commits. A \sphinxstyleemphasis{branch} is a named pointer (reference) to a commit, and allows you
to isolate developments. The default branch is called \sphinxcode{\sphinxupquote{main}}. \sphinxcode{\sphinxupquote{HEAD}} is
a pointer to the branch you are currently on, and thus to the last commit
in the given branch.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{git_branch_HEAD}.png}\hspace*{\fill}}

\sphinxAtStartPar
Using \sphinxcode{\sphinxupquote{HEAD}}, you can identify the most recent commit, or count backwards
starting from the most recent commit. \sphinxcode{\sphinxupquote{HEAD\textasciitilde{}1}} is the ancestor of the most
recent commit, i.e., one commit back (\sphinxcode{\sphinxupquote{f30ab}} in the figure above). Apart from
the notation \sphinxcode{\sphinxupquote{HEAD\textasciitilde{}N}}, there is also \sphinxcode{\sphinxupquote{HEAD\textasciicircum{}N}} used to count backwards, but
\sphinxhref{https://stackoverflow.com/q/2221658/10068927}{less frequently used and of importance primarily in the case of merge
commits}.


\end{findoutmore}

\sphinxAtStartPar
Let’s stay with the hash, and reset to the commit prior to saving the Git jokes.

\sphinxAtStartPar
First, find out the shasum, and afterwards, reset it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{58e40d9 [DATALAD] Recorded changes}
\PYG{g+go}{996f459 remove obsolete subds}
\PYG{g+go}{15acb2a [DATALAD] Added subdataset}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}mixed\PYG{+w}{ }996f459a✂SHA1
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s see what has happened. First, let’s check the history:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{996f459 remove obsolete subds}
\PYG{g+go}{15acb2a [DATALAD] Added subdataset}
\end{sphinxVerbatim}

\sphinxAtStartPar
As you can see, the commit in which the jokes were tracked
is not in the history anymore! Go on to see what \sphinxcode{\sphinxupquote{datalad status}}
reports:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: Gitjoke1.txt (file)}
\PYG{g+go}{untracked: Gitjoke2.txt (file)}
\PYG{g+go}{untracked: Gitjoke3.txt (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Nice, the files are present, and untracked again. Do they contain
the content still? We will read all of them with \sphinxcode{\sphinxupquote{ cat}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }Gitjoke*
\PYG{g+go}{Git knows what you did last summer!}
\PYG{g+go}{Knock knock. Who\PYGZsq{}s there? Git.}
\PYG{g+go}{Git\PYGZhy{}who?}
\PYG{g+go}{Sorry, \PYGZsq{}who\PYGZsq{} is not a git command \PYGZhy{} did you mean \PYGZsq{}show\PYGZsq{}?}
\PYG{g+go}{In Soviet Russia, git commits YOU!}
\end{sphinxVerbatim}

\sphinxAtStartPar
Great. Now we can go ahead and save only the file we intended
to track:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}save my favorite Git joke\PYGZdq{}}\PYG{+w}{ }Gitjoke2.txt
\PYG{g+go}{add(ok): Gitjoke2.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, let’s check how the history looks afterwards:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}2
\PYG{g+go}{commit 4bdb06cf✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    save my favorite Git joke}

\PYG{g+go}{commit 996f459a✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    remove obsolete subds}
\end{sphinxVerbatim}

\sphinxAtStartPar
Wow! You have rewritten history%
\begin{footnote}[4]\sphinxAtStartFootnote
Note though that rewriting history can be dangerous, and you should
be aware of what you are doing. For example, rewriting parts of the
dataset’s history that have been published (e.g., to a GitHub repository)
already or that other people have copies of, is not advised.
%
\end{footnote}!

\index{stop content tracking@\spxentry{stop content tracking}!with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}}\index{with git\sphinxhyphen{}annex@\spxentry{with git\sphinxhyphen{}annex}!stop content tracking@\spxentry{stop content tracking}}\ignorespaces 

\subsection{Untracking accidentally saved contents (stored in git\sphinxhyphen{}annex)}
\label{\detokenize{basics/101-137-history:untracking-accidentally-saved-contents-stored-in-git-annex}}\label{\detokenize{basics/101-137-history:index-4}}
\sphinxAtStartPar
The previous \sphinxcode{\sphinxupquote{git reset}} undid the tracking of \sphinxstyleemphasis{text} files.
However, those files are stored in Git, and thus their content
is also stored in Git. Files that are annexed, however, have
their content stored in git\sphinxhyphen{}annex, and not the file itself is stored
in the history, but a symlink pointing to the location of the file
content in the dataset’s annex. This has consequences for
a \sphinxcode{\sphinxupquote{git reset}} command: Reverting a save of a file that is
annexed would revert the save of the symlink into Git, but it will
not revert the \sphinxstyleemphasis{annexing} of the file.
Thus, what will be left in the dataset is an untracked symlink.

\sphinxAtStartPar
To undo an accidental save of that annexed a file, the annexed file
has to be “unlocked” first with a \sphinxcode{\sphinxupquote{datalad unlock}} command.

\sphinxAtStartPar
We will simulate such a situation by creating a PDF file that
gets annexed with an accidental \sphinxcode{\sphinxupquote{datalad save}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} create an empty pdf file}
\PYG{g+gp}{\PYGZdl{} }convert\PYG{+w}{ }xc:none\PYG{+w}{ }\PYGZhy{}page\PYG{+w}{ }Letter\PYG{+w}{ }apdffile.pdf
\PYG{g+gp}{\PYGZdl{} }\PYG{c+c1}{\PYGZsh{} accidentally save it}
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save
\PYG{g+go}{add(ok): Gitjoke1.txt (file)}
\PYG{g+go}{add(ok): Gitjoke3.txt (file)}
\PYG{g+go}{add(ok): apdffile.pdf (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This accidental \sphinxcode{\sphinxupquote{datalad save}} has thus added both text files
stored in Git, but also a PDF file to the history of the dataset.
As an \sphinxcode{\sphinxupquote{ ls \sphinxhyphen{}l}} reveals, the PDF file has been annexed and is
thus a {\hyperref[\detokenize{glossary:term-symlink}]{\sphinxtermref{\DUrole{xref,std,std-term}{symlink}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }apdffile.pdf
\PYG{g+go}{lrwxrwxrwx 1 elena elena 122 2019\PYGZhy{}06\PYGZhy{}18 16:13 apdffile.pdf \PYGZhy{}\PYGZgt{} .git/annex/objects/zZ/v7/✂/MD5E\PYGZhy{}s1216\PYGZhy{}\PYGZhy{}b954106f✂MD5.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
Prior to resetting, the PDF file has to be unannexed.
To unannex files, i.e., get the contents out of the object tree,
the \sphinxcode{\sphinxupquote{datalad unlock}} command is relevant:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }unlock\PYG{+w}{ }apdffile.pdf
\PYG{g+go}{unlock(ok): apdffile.pdf (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The file is now no longer symlinked:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }ls\PYG{+w}{ }\PYGZhy{}l\PYG{+w}{ }apdffile.pdf
\PYG{g+go}{\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 elena elena 1216 2019\PYGZhy{}06\PYGZhy{}18 16:13 apdffile.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, \sphinxcode{\sphinxupquote{git reset \sphinxhyphen{}\sphinxhyphen{}mixed}} can be used to revert the
accidental \sphinxcode{\sphinxupquote{datalad save}}. Again, find out the shasum first, and
afterwards, reset it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{3}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{9b3495b [DATALAD] Recorded changes}
\PYG{g+go}{4bdb06c save my favorite Git joke}
\PYG{g+go}{996f459 remove obsolete subds}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}mixed\PYG{+w}{ }4bdb06cf✂SHA1
\end{sphinxVerbatim}

\sphinxAtStartPar
To see what has happened, let’s check the history:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{4bdb06c save my favorite Git joke}
\PYG{g+go}{996f459 remove obsolete subds}
\end{sphinxVerbatim}

\sphinxAtStartPar
… and also the status of the dataset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: Gitjoke1.txt (file)}
\PYG{g+go}{untracked: Gitjoke3.txt (file)}
\PYG{g+go}{untracked: apdffile.pdf (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The accidental save has been undone, and the file is present
as untracked content again.
As before, this action has not been recorded in your history.


\subsection{Viewing previous versions of files and datasets}
\label{\detokenize{basics/101-137-history:viewing-previous-versions-of-files-and-datasets}}
\sphinxAtStartPar
The next question is truly magical: How does one \sphinxstyleemphasis{see}
data as it was at a previous state in history?

\sphinxAtStartPar
This magic trick can be performed with the \sphinxcode{\sphinxupquote{git checkout}}.
It is a very heavily used command for various tasks, but among
many it can send you back in time to view the state of a dataset
at the time of a specific commit.

\sphinxAtStartPar
Let’s say you want to find out which notes you took in the first
few chapters of this book. Find a commit {\hyperref[\detokenize{glossary:term-shasum}]{\sphinxtermref{\DUrole{xref,std,std-term}{shasum}}}} in your history
to specify the point in time you want to go back to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{16}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{4bdb06c save my favorite Git joke}
\PYG{g+go}{996f459 remove obsolete subds}
\PYG{g+go}{15acb2a [DATALAD] Added subdataset}
\PYG{g+go}{c278f6a save cropped logos to Git}
\PYG{g+go}{de2d23c move book back from midterm\PYGZus{}project}
\PYG{g+go}{a648756 move book into midterm\PYGZus{}project}
\PYG{g+go}{39e55c8 add container and execute analysis within container}
\PYG{g+go}{c5c9017 finished my midterm project}
\PYG{g+go}{0edd3ea [DATALAD] Recorded changes}
\PYG{g+go}{08684a4 add note on DataLad\PYGZsq{}s procedures}
\PYG{g+go}{c2400da add note on configurations and git config}
\PYG{g+go}{e202e94 Add note on adding siblings}
\PYG{g+go}{6ae8e71 Merge remote\PYGZhy{}tracking branch \PYGZsq{}roommate/main\PYGZsq{}}
\PYG{g+go}{4bb5d39 add note about datalad update}
\PYG{g+go}{5b6e19a Include nesting demo from datalad website}
\PYG{g+go}{adb4b5d add note on git annex whereis}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s go 15 commits back in time:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }checkout\PYG{+w}{ }1e73592e✂SHA1
\PYG{g+go}{warning: unable to rmdir \PYGZsq{}midterm\PYGZus{}project\PYGZsq{}: Directory not empty}
\PYG{g+go}{Note: switching to \PYGZsq{}1e73592e✂SHA1\PYGZsq{}.}

\PYG{g+go}{You are in \PYGZsq{}detached HEAD\PYGZsq{} state. You can look around, make experimental}
\PYG{g+go}{changes and commit them, and you can discard any commits you make in this}
\PYG{g+go}{state without impacting any branches by switching back to a branch.}

\PYG{g+go}{If you want to create a new branch to retain commits you create, you may}
\PYG{g+go}{do so (now or later) by using \PYGZhy{}c with the switch command. Example:}

\PYG{g+go}{  git switch \PYGZhy{}c \PYGZlt{}new\PYGZhy{}branch\PYGZhy{}name\PYGZgt{}}

\PYG{g+go}{Or undo this operation with:}

\PYG{g+go}{  git switch \PYGZhy{}}

\PYG{g+go}{Turn off this advice by setting config variable advice.detachedHead to false}

\PYG{g+go}{HEAD is now at 1e73592 add note about cloning from paths and recursive datalad get}
\end{sphinxVerbatim}

\sphinxAtStartPar
How did your \sphinxcode{\sphinxupquote{notes.txt}} file look at this point?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }tail\PYG{+w}{ }notes.txt
\PYG{g+go}{registered in the superdataset \PYGZhy{}\PYGZhy{} you will have to do a}
\PYG{g+go}{\PYGZdq{}datalad get \PYGZhy{}n PATH/TO/SUBDATASET\PYGZdq{} to install the subdataset for file}
\PYG{g+go}{availability meta data. The \PYGZhy{}n/\PYGZhy{}\PYGZhy{}no\PYGZhy{}data options prevents that file}
\PYG{g+go}{contents are also downloaded.}

\PYG{g+go}{Note that a recursive \PYGZdq{}datalad get\PYGZdq{} would install all further}
\PYG{g+go}{registered subdatasets underneath a subdataset, so a safer way to}
\PYG{g+go}{proceed is to set a decent \PYGZhy{}\PYGZhy{}recursion\PYGZhy{}limit:}
\PYG{g+go}{\PYGZdq{}datalad get \PYGZhy{}n \PYGZhy{}r \PYGZhy{}\PYGZhy{}recursion\PYGZhy{}limit 2 \PYGZlt{}subds\PYGZgt{}\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Neat, isn’t it? By checking out a commit shasum you can explore a previous
state of a datasets history. And this does not only apply to simple text
files, but every type of file in your dataset, regardless of size.
The checkout command however led to something that Git calls a “detached HEAD state”.
While this sounds scary, a \sphinxcode{\sphinxupquote{git checkout main}} will bring you
back into the most recent version of your dataset and get you out of the
“detached HEAD state”:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }checkout\PYG{+w}{ }main
\PYG{g+go}{Previous HEAD position was 1e73592 add note about cloning from paths and recursive datalad get}
\PYG{g+go}{Switched to branch \PYGZsq{}main\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note one very important thing: The previously untracked files are still
there.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: Gitjoke1.txt (file)}
\PYG{g+go}{untracked: Gitjoke3.txt (file)}
\PYG{g+go}{untracked: apdffile.pdf (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The contents of \sphinxcode{\sphinxupquote{notes.txt}} will now be the most recent version again:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }tail\PYG{+w}{ }notes.txt
\PYG{g+go}{configurations, create files or file hierarchies, or perform arbitrary}
\PYG{g+go}{tasks in datasets. They can be shipped with DataLad, its extensions,}
\PYG{g+go}{or datasets, and you can even write your own procedures and distribute}
\PYG{g+go}{them.}
\PYG{g+go}{The \PYGZdq{}datalad run\PYGZhy{}procedure\PYGZdq{} command is used to apply such a procedure}
\PYG{g+go}{to a dataset. Procedures shipped with DataLad or its extensions}
\PYG{g+go}{starting with a \PYGZdq{}cfg\PYGZdq{} prefix can also be applied at the creation of a}
\PYG{g+go}{dataset with \PYGZdq{}datalad create \PYGZhy{}c \PYGZlt{}PROC\PYGZhy{}NAME\PYGZgt{} \PYGZlt{}PATH\PYGZgt{}\PYGZdq{} (omitting the}
\PYG{g+go}{\PYGZdq{}cfg\PYGZdq{} prefix).}
\end{sphinxVerbatim}

\sphinxAtStartPar
… Wow! You traveled back and forth in time!
But an even more magical way to see the contents of files in previous
versions is Git’s \sphinxcode{\sphinxupquote{ cat\sphinxhyphen{}file}} command: Among many other things, it lets
you read a file’s contents as of any point in time in the history, without a
prior \sphinxcode{\sphinxupquote{git checkout}} (note that the output is shortened for brevity and shows only the last few lines of the file):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }cat\PYGZhy{}file\PYG{+w}{ }\PYGZhy{}\PYGZhy{}textconv\PYG{+w}{ }1e73592e✂SHA1:notes.txt

\PYG{g+go}{Note that subdatasets will not be installed by default, but are only}
\PYG{g+go}{registered in the superdataset \PYGZhy{}\PYGZhy{} you will have to do a}
\PYG{g+go}{\PYGZdq{}datalad get \PYGZhy{}n PATH/TO/SUBDATASET\PYGZdq{} to install the subdataset for file}
\PYG{g+go}{availability meta data. The \PYGZhy{}n/\PYGZhy{}\PYGZhy{}no\PYGZhy{}data options prevents that file}
\PYG{g+go}{contents are also downloaded.}

\PYG{g+go}{Note that a recursive \PYGZdq{}datalad get\PYGZdq{} would install all further}
\PYG{g+go}{registered subdatasets underneath a subdataset, so a safer way to}
\PYG{g+go}{proceed is to set a decent \PYGZhy{}\PYGZhy{}recursion\PYGZhy{}limit:}
\PYG{g+go}{\PYGZdq{}datalad get \PYGZhy{}n \PYGZhy{}r \PYGZhy{}\PYGZhy{}recursion\PYGZhy{}limit 2 \PYGZlt{}subds\PYGZgt{}\PYGZdq{}}
\end{sphinxVerbatim}

\index{cat\sphinxhyphen{}file@\spxentry{cat\sphinxhyphen{}file}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!cat\sphinxhyphen{}file@\spxentry{cat\sphinxhyphen{}file}}\ignorespaces 
\sphinxAtStartPar
The cat\sphinxhyphen{}file command is very versatile, and
\sphinxhref{https://git-scm.com/docs/git-cat-file}{it’s documentation} will list all
of its functionality. To use it to see the contents of a file at a previous
state as done above, this is how the general structure looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }cat\PYGZhy{}file\PYG{+w}{ }\PYGZhy{}\PYGZhy{}textconv\PYG{+w}{ }SHASUM:\PYGZlt{}path/to/file\PYGZgt{}
\end{sphinxVerbatim}


\subsection{Undoing latest modifications of files}
\label{\detokenize{basics/101-137-history:undoing-latest-modifications-of-files}}
\sphinxAtStartPar
Previously, we saw how to remove files from a datasets history that
were accidentally saved and thus tracked for the first time.
How does one undo a \sphinxstyleemphasis{modification} to a tracked file?

\sphinxAtStartPar
Let’s modify the saved \sphinxcode{\sphinxupquote{Gitjoke1.txt}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}this is by far my favorite joke!\PYGZdq{}}\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }Gitjoke2.txt
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }Gitjoke2.txt
\PYG{g+go}{Knock knock. Who\PYGZsq{}s there? Git.}
\PYG{g+go}{Git\PYGZhy{}who?}
\PYG{g+go}{Sorry, \PYGZsq{}who\PYGZsq{} is not a git command \PYGZhy{} did you mean \PYGZsq{}show\PYGZsq{}?}
\PYG{g+go}{this is by far my favorite joke!}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: Gitjoke1.txt (file)}
\PYG{g+go}{untracked: Gitjoke3.txt (file)}
\PYG{g+go}{untracked: apdffile.pdf (file)}
\PYG{g+go}{ modified: Gitjoke2.txt (file)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add joke evaluation to joke\PYGZdq{}}\PYG{+w}{ }Gitjoke2.txt
\PYG{g+go}{add(ok): Gitjoke2.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
How could this modification to \sphinxcode{\sphinxupquote{Gitjoke2.txt}} be undone?
With the \sphinxcode{\sphinxupquote{git reset}} command again. If you want to
“unsave” the modification but keep it in the file, use
\sphinxcode{\sphinxupquote{git reset \sphinxhyphen{}\sphinxhyphen{}mixed}} as before. However, if you want to
get rid of the modifications entirely, use the option \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}hard}}
instead of \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}mixed}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{2}\PYG{+w}{ }\PYGZhy{}\PYGZhy{}oneline
\PYG{g+go}{a4ab359 add joke evaluation to joke}
\PYG{g+go}{4bdb06c save my favorite Git joke}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }reset\PYG{+w}{ }\PYGZhy{}\PYGZhy{}hard\PYG{+w}{ }4bdb06cf✂SHA1
\PYG{g+go}{HEAD is now at 4bdb06c save my favorite Git joke}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }Gitjoke2.txt
\PYG{g+go}{Knock knock. Who\PYGZsq{}s there? Git.}
\PYG{g+go}{Git\PYGZhy{}who?}
\PYG{g+go}{Sorry, \PYGZsq{}who\PYGZsq{} is not a git command \PYGZhy{} did you mean \PYGZsq{}show\PYGZsq{}?}
\end{sphinxVerbatim}

\sphinxAtStartPar
The change has been undone completely. This method will work with
files stored in Git and annexed files.

\sphinxAtStartPar
Note that this operation only restores this one file, because the commit that
was undone only contained modifications to this one file. This is a
demonstration of one of the reasons why one should strive for commits to
represent meaningful logical units of change \textendash{} if necessary, they can be
undone easily.


\subsection{Undoing past modifications of files}
\label{\detokenize{basics/101-137-history:undoing-past-modifications-of-files}}
\sphinxAtStartPar
What \sphinxcode{\sphinxupquote{git reset}} did was to undo commits from
the most recent version of your dataset. How
would one undo a change that happened a while ago, though,
with important changes being added afterwards that you want
to keep?

\sphinxAtStartPar
Let’s save a bad modification to \sphinxcode{\sphinxupquote{Gitjoke2.txt}},
but also a modification to \sphinxcode{\sphinxupquote{notes.txt}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{echo}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}bad modification\PYGZdq{}}\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }Gitjoke2.txt
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}did a bad modification\PYGZdq{}}\PYG{+w}{ }Gitjoke2.txt
\PYG{g+go}{add(ok): Gitjoke2.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }\PYGZlt{}\PYGZlt{}\PYG{+w}{ }EOT\PYG{+w}{ }\PYGZgt{}\PYGZgt{}\PYG{+w}{ }notes.txt

\PYG{g+go}{Git has many handy tools to go back in forth in time and work with the}
\PYG{g+go}{history of datasets. Among many other things you can rewrite commit}
\PYG{g+go}{messages, undo changes, or look at previous versions of datasets.}
\PYG{g+go}{A superb resource to find out more about this and practice such Git}
\PYG{g+go}{operations is this chapter in the Pro\PYGZhy{}git book:}
\PYG{g+go}{https://git\PYGZhy{}scm.com/book/en/v2/Git\PYGZhy{}Tools\PYGZhy{}Rewriting\PYGZhy{}History}
\PYG{g+go}{EOT}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }save\PYG{+w}{ }\PYGZhy{}m\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}add note on helpful git resource\PYGZdq{}}\PYG{+w}{ }notes.txt
\PYG{g+go}{add(ok): notes.txt (file)}
\PYG{g+go}{save(ok): . (dataset)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The objective is to remove the first, “bad” modification, but
keep the more recent modification of \sphinxcode{\sphinxupquote{notes.txt}}. A \sphinxcode{\sphinxupquote{git reset}}
command is not convenient, because resetting would need to reset
the most recent, “good” modification as well.

\sphinxAtStartPar
One way to accomplish it is with an \sphinxstyleemphasis{interactive rebase}, using the
\sphinxcode{\sphinxupquote{git rebase \sphinxhyphen{}i}} command%
\begin{footnote}[5]\sphinxAtStartFootnote
When in need to interactively rebase, please consult further documentation
and tutorials. It is out of scope of this book to be a complete
guide on rebasing, and not all interactive rebasing operations are
complication\sphinxhyphen{}free. However, you can always undo mistakes that occur
during rebasing with the help of the \sphinxhref{https://git-scm.com/docs/git-reflog}{reflog}.
%
\end{footnote}. Experienced Git\sphinxhyphen{}users will know
under which situations and how to perform such an interactive rebase.

\sphinxAtStartPar
However, outlining an interactive rebase here in this book could lead to
problems for readers without (much) Git experience: An interactive rebase,
even if performed successfully, can lead to many problems if it is applied with
too little experience, for example, in any collaborative real\sphinxhyphen{}world project.

\index{revert@\spxentry{revert}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!revert@\spxentry{revert}}\ignorespaces 
\sphinxAtStartPar
Instead, we demonstrate a different, less intrusive way to revert one or more
changes at any point in the history of a dataset: the \sphinxcode{\sphinxupquote{git revert}}
command.
Instead of \sphinxstyleemphasis{rewriting} the history, it will add an additional commit in which
the changes of an unwanted commit are reverted.

\sphinxAtStartPar
The command looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }revert\PYG{+w}{ }SHASUM
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{SHASUM}} specifies the commit hash of the modification that should
be reverted. The \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-revert}} {\hyperref[\detokenize{basics/101-137-history:fom-revert}]{\sphinxcrossref{\DUrole{std,std-ref}{on reverting}}}} (\autopageref*{\detokenize{basics/101-137-history:fom-revert}}) shows how to revert
more than one commit.

\index{revert multiple commit@\spxentry{revert multiple commit}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!revert multiple commit@\spxentry{revert multiple commit}}\ignorespaces \begin{findoutmore}[label={fom-revert}, before title={\thetcbcounter\ }, float, floatplacement=tbp, check odd page=true]{Reverting more than a single commit}
\label{\detokenize{basics/101-137-history:fom-revert}}

\sphinxAtStartPar
You can also specify a range of commits like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }revert\PYG{+w}{ }OLDER\PYGZus{}SHASUM..NEWERSHASUM
\end{sphinxVerbatim}

\sphinxAtStartPar
This command will revert all commits starting with the one after
\sphinxcode{\sphinxupquote{OLDER\_SHASUM}} (i.e. \sphinxstylestrong{not including} this commit) until and \sphinxstylestrong{including}
the one specified with \sphinxcode{\sphinxupquote{NEWERSHASUM}}.
For each reverted commit, one new commit will be added to the history that
reverts it. Thus, if you revert a range of three commits, there will be three
reversal commits. If you however want the reversal of a range of commits
saved in a single commit, supply the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}no\sphinxhyphen{}commit}} option as in

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }revert\PYG{+w}{ }\PYGZhy{}\PYGZhy{}no\PYGZhy{}commit\PYG{+w}{ }OLDER\PYGZus{}SHASUM..NEWERSHASUM
\end{sphinxVerbatim}

\sphinxAtStartPar
After running this command, run a single \sphinxcode{\sphinxupquote{git commit}} to conclude the
reversal and save it in a single commit.


\end{findoutmore}

\sphinxAtStartPar
Let’s see how it looks like:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }revert\PYG{+w}{ }713e79d3✂SHA1
\PYG{g+go}{[main 6d3d93b] Revert \PYGZdq{}did a bad modification\PYGZdq{}}
\PYG{g+go}{ Date: Tue Jun 18 16:13:00 2019 +0000}
\PYG{g+go}{ 1 file changed, 1 deletion(\PYGZhy{})}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is the state of the file in which we reverted a modification:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }cat\PYG{+w}{ }Gitjoke2.txt
\PYG{g+go}{Knock knock. Who\PYGZsq{}s there? Git.}
\PYG{g+go}{Git\PYGZhy{}who?}
\PYG{g+go}{Sorry, \PYGZsq{}who\PYGZsq{} is not a git command \PYGZhy{} did you mean \PYGZsq{}show\PYGZsq{}?}
\end{sphinxVerbatim}

\sphinxAtStartPar
It does not contain the bad modification anymore. And this is what happened in
the history of the dataset:

\fvset{hllines={, 6, 7, 8, 20,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }log\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{3}
\PYG{g+go}{commit 6d3d93b9✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    Revert \PYGZdq{}did a bad modification\PYGZdq{}}

\PYG{g+go}{    This reverts commit 713e79d3✂SHA1.}

\PYG{g+go}{commit 04536a1e✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    add note on helpful git resource}

\PYG{g+go}{commit 713e79d3✂SHA1}
\PYG{g+go}{Author: Elena Piscopia \PYGZlt{}elena@example.net\PYGZgt{}}
\PYG{g+go}{Date:   Tue Jun 18 16:13:00 2019 +0000}

\PYG{g+go}{    did a bad modification}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

\sphinxAtStartPar
The commit that introduced the bad modification is still present, but it
transparently gets undone with the most recent commit. At the same time, the
good modification of \sphinxcode{\sphinxupquote{notes.txt}} was not influenced in any way. The
\sphinxcode{\sphinxupquote{git revert}} command is thus a transparent and safe way of undoing past
changes. Note though that this command can only be used efficiently if the
commits in your datasets history are meaningful, independent units \textendash{} having
several unrelated modifications in a single commit may make an easy solution
with \sphinxcode{\sphinxupquote{git revert}} impossible and instead require a complex
\sphinxcode{\sphinxupquote{ checkout}}, \sphinxcode{\sphinxupquote{ revert}}, or \sphinxcode{\sphinxupquote{ rebase}} operation.

\sphinxAtStartPar
Finally, let’s take a look at the state of the dataset after this operation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{untracked: Gitjoke1.txt (file)}
\PYG{g+go}{untracked: Gitjoke3.txt (file)}
\PYG{g+go}{untracked: apdffile.pdf (file)}
\end{sphinxVerbatim}

\sphinxAtStartPar
As you can see, unsurprisingly, the \sphinxcode{\sphinxupquote{git revert}} command had no
effects on anything else but the specified commit, and previously untracked
files are still present.

\index{resolve merge conflict@\spxentry{resolve merge conflict}!with Git@\spxentry{with Git}}\index{with Git@\spxentry{with Git}!resolve merge conflict@\spxentry{resolve merge conflict}}\ignorespaces 

\section{Oh no! I’m in a merge conflict!}
\label{\detokenize{basics/101-137-history:oh-no-i-m-in-a-merge-conflict}}\label{\detokenize{basics/101-137-history:index-8}}
\sphinxAtStartPar
When working with the history of a dataset, especially when rewriting
the history with an interactive rebase or when reverting commits, it is
possible to run into so\sphinxhyphen{}called \sphinxstyleemphasis{merge conflicts}.
Merge conflicts happen when Git needs assistance in deciding
which changes to keep and which to apply. It will require
you to edit the file the merge conflict is happening in with
a text editor, but such merge conflict are by far not as scary as
they may seem during the first few times of solving merge conflicts.

\sphinxAtStartPar
This section is not a guide on how to solve merge\sphinxhyphen{}conflicts, but a broad
overview on the necessary steps, and a pointer to a more comprehensive guide.
\begin{itemize}
\item {} 
\sphinxAtStartPar
The first thing to do if you end up in a merge conflict is
to read the instructions Git is giving you \textendash{} they are a useful guide.

\item {} 
\sphinxAtStartPar
Also, it is reassuring to remember that you can always get out of
a merge conflict by aborting the operation that led to it (e.g.,
\sphinxcode{\sphinxupquote{git rebase \sphinxhyphen{}\sphinxhyphen{}abort}}).

\item {} 
\sphinxAtStartPar
To actually solve a merge conflict, you will have to edit files: In the
documents the merge conflict applies to, Git marks the sections it needs
help with with markers that consists of \sphinxcode{\sphinxupquote{\textgreater{}}}, \sphinxcode{\sphinxupquote{\textless{}}}, and \sphinxcode{\sphinxupquote{=}}
signs and commit shasums or branch names.
There will be two marked parts, and you have to delete the one you do not
want to keep, as well as all markers.

\item {} 
\sphinxAtStartPar
Afterwards, run \sphinxcode{\sphinxupquote{git add \textless{}path/to/file\textgreater{}}} and finally a \sphinxcode{\sphinxupquote{git commit}}.

\end{itemize}

\sphinxAtStartPar
GitHub has an \sphinxhref{https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/addressing-merge-conflicts/resolving-a-merge-conflict-using-the-command-line}{excellent resource on how to deal with merge conflicts}.


\section{Summary}
\label{\detokenize{basics/101-137-history:summary}}
\sphinxAtStartPar
This guest lecture has given you a glimpse into how to work with the
history of your DataLad datasets.
To conclude this section, let’s remove all untracked contents from
the dataset. This can be done with \sphinxcode{\sphinxupquote{git clean}}: The command
\sphinxcode{\sphinxupquote{git clean \sphinxhyphen{}f}} swipes your dataset clean and removes any untracked
file.
\sphinxstylestrong{Careful! This is not revertible, and content lost with this commands cannot be recovered!}
If you want to be extra sure, run \sphinxcode{\sphinxupquote{git clean \sphinxhyphen{}fn}} beforehand \textendash{} this will
give you a list of the files that would be deleted.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }clean\PYG{+w}{ }\PYGZhy{}f
\PYG{g+go}{Removing Gitjoke1.txt}
\PYG{g+go}{Removing Gitjoke3.txt}
\PYG{g+go}{Removing apdffile.pdf}
\end{sphinxVerbatim}

\sphinxAtStartPar
Afterwards, the \sphinxcode{\sphinxupquote{datalad status}} returns nothing, indicating a
clean dataset state with no untracked files or modifications.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, if you want, apply your new knowledge about reverting commits
to remove the \sphinxcode{\sphinxupquote{Gitjoke2.txt}} file.

\sphinxstepscope

\index{get help@\spxentry{get help}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!get help@\spxentry{get help}}\ignorespaces 

\chapter{When things go wrong}
\label{\detokenize{basics/101-135-help:when-things-go-wrong}}\label{\detokenize{basics/101-135-help:help}}\label{\detokenize{basics/101-135-help:index-0}}\label{\detokenize{basics/101-135-help::doc}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{reading}.pdf}\hspace*{\fill}}

\sphinxAtStartPar
All DataLad errors or problems you encounter during \sphinxcode{\sphinxupquote{DataLad\sphinxhyphen{}101}} are intentional
and serve illustrative purposes. But what if you run into any DataLad errors
outside of this course?
Fortunately, the syllabus has a whole section on that, and on
one lazy, warm summer afternoon you flip through it.

\sphinxAtStartPar
You realize that you already know the most important things:
The number one advice on how to get help is
“Read the error message”.
The second advice it
“I’m not kidding: Read the error message”.
The third advice, finally, says
“Honestly, read the f***ing error message”.


\section{Help yourself}
\label{\detokenize{basics/101-135-help:help-yourself}}
\sphinxAtStartPar
If you run into a DataLad problem and you have followed the three
steps above, but the error message
\sphinxhref{https://xkcd.com/1833}{does not give you a clue on how to proceed},
the first you should do is
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
find out which \sphinxstyleemphasis{version} of DataLad you use

\item {} 
\sphinxAtStartPar
read the \sphinxstyleemphasis{help page} of the command that failed

\end{enumerate}

\sphinxAtStartPar
The first step is important in order to find out whether a
command failed due to using a wrong DataLad version. In order
to use this book and follow along, your DataLad version
should be \sphinxcode{\sphinxupquote{datalad\sphinxhyphen{}0.19}} or higher, for example.

\sphinxAtStartPar
To find out which version you are using, run

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }\PYGZhy{}\PYGZhy{}version
\PYG{g+go}{datalad 0.19.3}
\end{sphinxVerbatim}

\index{wtf@\spxentry{wtf}!DataLad command@\spxentry{DataLad command}}\index{DataLad command@\spxentry{DataLad command}!wtf@\spxentry{wtf}}\index{get system information@\spxentry{get system information}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!get system information@\spxentry{get system information}}\ignorespaces 
\sphinxAtStartPar
If you want a comprehensive overview of your full setup,
\sphinxcode{\sphinxupquote{datalad wtf}}%
\begin{footnote}[1]\sphinxAtStartFootnote
\sphinxcode{\sphinxupquote{wtf}} in \sphinxcode{\sphinxupquote{datalad wtf}} could stand for many things. “Why the Face?”
“Wow, that’s fantastic!”, “What’s this for?”, “What to fix”, “What the FAQ”,
“Where’s the fire?”, “Wipe the floor”, “Welcome to fun”,
“Waste Treatment Facility”, “What’s this foolishness”, “What the fruitcake”, …
Pick a translation of your choice and make running this command more joyful.
%
\end{footnote} is the command to turn to. Running this command will
generate a report about the DataLad installation and configuration.
The output below shows an excerpt.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }wtf
\PYG{g+gp}{\PYGZsh{} }WTF
\PYG{g+gp}{\PYGZsh{}}\PYG{c+c1}{\PYGZsh{} configuration \PYGZlt{}SENSITIVE, report disabled by configuration\PYGZgt{}}
\PYG{g+gp}{\PYGZsh{}}\PYG{c+c1}{\PYGZsh{} credentials}
\PYG{g+go}{  \PYGZhy{} keyring:}
\PYG{g+go}{    \PYGZhy{} active\PYGZus{}backends:}
\PYG{g+go}{      \PYGZhy{} PlaintextKeyring with no encyption v.1.0 at /home/me/.local/share/python\PYGZus{}keyring/keyring\PYGZus{}pass.cfg}
\PYG{g+go}{    \PYGZhy{} config\PYGZus{}file: /home/me/.config/python\PYGZus{}keyring/keyringrc.cfg}
\PYG{g+go}{    \PYGZhy{} data\PYGZus{}root: /home/me/.local/share/python\PYGZus{}keyring}
\PYG{g+gp}{\PYGZsh{}}\PYG{c+c1}{\PYGZsh{} datalad}
\end{sphinxVerbatim}

\sphinxAtStartPar
This lengthy output will report all information that might
be relevant \textendash{} from DataLad to {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} or Python
up to your operating system.

\sphinxAtStartPar
The second step, finding and reading the help page of the command
in question, is important in order to find out how the
command that failed is used. Are arguments specified correctly?
Does the help list any caveats?

\sphinxAtStartPar
There are multiple ways to find help on DataLad commands.
You could turn to the \sphinxhref{https://docs.datalad.org}{documentation}.
Alternatively, to get help right inside the terminal,
run any command with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}h}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}help}} option (shown
as an excerpt here):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }get\PYG{+w}{ }\PYGZhy{}\PYGZhy{}help
\PYG{g+go}{Usage: datalad get [\PYGZhy{}h] [\PYGZhy{}s LABEL] [\PYGZhy{}d PATH] [\PYGZhy{}r] [\PYGZhy{}R LEVELS] [\PYGZhy{}n]}
\PYG{g+go}{                   [\PYGZhy{}D DESCRIPTION] [\PYGZhy{}\PYGZhy{}reckless [auto|ephemeral|shared\PYGZhy{}...]]}
\PYG{g+go}{                   [\PYGZhy{}J NJOBS] [\PYGZhy{}\PYGZhy{}version]}
\PYG{g+go}{                   [PATH [PATH ...]]}

\PYG{g+go}{Get any dataset content (files/directories/subdatasets).}

\PYG{g+go}{This command only operates on dataset content. To obtain a new independent}
\PYG{g+go}{dataset from some source use the CLONE command.}

\PYG{g+go}{By default this command operates recursively within a dataset, but not}
\PYG{g+go}{across potential subdatasets, i.e. if a directory is provided, all files in}
\PYG{g+go}{the directory are obtained. Recursion into subdatasets is supported too. If}
\PYG{g+go}{enabled, relevant subdatasets are detected and installed in order to}
\PYG{g+go}{fulfill a request.}

\PYG{g+go}{NOTE}
\PYG{g+go}{  Power\PYGZhy{}user info: This command uses git annex get to fulfill}
\PYG{g+go}{  file handles.}

\PYG{g+go}{*Examples*}

\PYG{g+go}{Get a single file::}

\PYG{g+gp}{   \PYGZpc{} }datalad\PYG{+w}{ }get\PYG{+w}{ }\PYGZlt{}path/to/file\PYGZgt{}

\PYG{g+go}{Get (clone) a registered subdataset, but don\PYGZsq{}t retrieve data::}

\PYG{g+gp}{   \PYGZpc{} }datalad\PYG{+w}{ }get\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYGZlt{}path/to/subds\PYGZgt{}

\PYG{g+go}{positional arguments:}
\PYG{g+go}{  PATH                  path/name of the requested dataset component. The}
\PYG{g+go}{                        component must already be known to a dataset. To add}
\PYG{g+go}{                        new components to a dataset use the ADD command.}
\PYG{g+go}{                        Constraints: value must be a string or value must be}
\PYG{g+go}{                        NONE}

\PYG{g+go}{\PYGZhy{}✂\PYGZhy{}\PYGZhy{}✂\PYGZhy{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This, for example, is the help page on \sphinxcode{\sphinxupquote{datalad get}}, the same you would find in the documentation, but in your terminal (here heavily trimmed to only show the main components).
It contains a command description, a list
of all the available options with a short explanation of them, and
example commands. The two \sphinxstyleemphasis{arguments} sections provide a comprehensive
list of command arguments with details on their possibilities and
requirements. A first thing to check would be whether your command call
specified all of the required arguments.

\sphinxAtStartPar
To find examples for using particular commands take a look at the topic index at the end of this book.
The online\sphinxhyphen{}handbook offers a convenient full\sphinxhyphen{}text search that can point you to all relevant sections in no time.
An additional source of information is the \sphinxhref{https://knowledge-base.psychoinformatics.de}{PsyInf knowledge base}. It contains a curated
collection of solutions and workarounds that have not yet made it into other
documentation.


\section{Asking questions (right)}
\label{\detokenize{basics/101-135-help:asking-questions-right}}
\sphinxAtStartPar
If nothing you do on your own helps to solve the problem,
consider asking others. Check out \sphinxhref{https://neurostars.org}{neurostars}
and search for your problem \textendash{} likely,
\sphinxhref{https://xkcd.com/979}{somebody already encountered the same error before}
and fixed it, but if not, just ask a new question with a \sphinxcode{\sphinxupquote{datalad}} tag.

\sphinxAtStartPar
Make sure your question is as informative as it can be for others.
Include
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{context} \textendash{} what did you want to do and why?

\item {} 
\sphinxAtStartPar
the \sphinxstyleemphasis{problem} \textendash{} post the error message, and provide the
steps necessary to reproduce it. Do not shorten the error message, unless it contains sensitive information.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{technical details} \textendash{} what version of DataLad are you using, what version
of git\sphinxhyphen{}annex, and which git\sphinxhyphen{}annex repository type, what is your operating
system and \textendash{} if applicable \textendash{} Python version? \sphinxcode{\sphinxupquote{datalad wtf}} is your friend
to find all of this information.

\end{itemize}

\index{debugging@\spxentry{debugging}}\ignorespaces 

\section{Debugging like a DataLad\sphinxhyphen{}developer}
\label{\detokenize{basics/101-135-help:debugging-like-a-datalad-developer}}\label{\detokenize{basics/101-135-help:index-2}}
\sphinxAtStartPar
If you have read a command’s help from start to end, checked all software versions twice, even \sphinxhref{https://xkcd.com/2083}{asked colleagues to reproduce your problem (unsuccessfully)}, and you still don’t have any clue what is going on, then welcome to the debugging section!

\begin{figure}[tbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{debug}.pdf}
\caption{It’s not as bad as this ;\sphinxhyphen{})}\label{\detokenize{basics/101-135-help:id4}}\end{figure}

\sphinxAtStartPar
It is not always straightforward to see \sphinxstyleemphasis{why} a particular DataLad command has failed.
Given that operations with DataLad can be quite complicated, and could involve complexities such as different forms of authentication, different file systems, interactions with the environment, configurations, and other software, and \sphinxstyleemphasis{much} more, there are what may feel like an infinite amount of sources for the problem at hand.
The resulting error message, however, may not display the underlying cause correctly because the error message of whichever process failed is not propagated into the final result report.

\sphinxAtStartPar
In situations where there is no obvious reason for a command to fail, it can be helpful \textendash{} either for yourself or for further information to include in {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}} issues \textendash{} to start \sphinxhref{https://xkcd.com/1722}{debugging}, or \sphinxstyleemphasis{logging at a higher granularity} than is the default.
This allows you to gain more insights into the actions DataLad and its underlying tools are taking, where \sphinxstyleemphasis{exactly} they fail, and to even play around with the program at the state of the failure.

\sphinxAtStartPar
{\hyperref[\detokenize{glossary:term-debugging}]{\sphinxtermref{\DUrole{xref,std,std-term}{Debugging}}}} and {\hyperref[\detokenize{glossary:term-logging}]{\sphinxtermref{\DUrole{xref,std,std-term}{logging}}}} are not as complex as these terms may sound if you have never consciously debugged.

\sphinxAtStartPar
Procedurally, it can be as easy as adding an additional flag to a command call, and cognitively, it can be as easy as engaging your visual system in a visual search task for the color red or the word “error”, or reading more DataLad output than you are used to.
We will start with the general concepts, and then end with a peek at reaching into DataLad’s internals.


\subsection{Logging}
\label{\detokenize{basics/101-135-help:logging}}\label{\detokenize{basics/101-135-help:id2}}
\sphinxAtStartPar
In order to gain more insights into the steps performed by a program and capture as many details as possible for troubleshooting an error, you can turn to {\hyperref[\detokenize{glossary:term-logging}]{\sphinxtermref{\DUrole{xref,std,std-term}{logging}}}}.
Logging simply refers to the fact that DataLad and its underlying tools tell you what they are doing:
This information can be coarse, such as a mere \sphinxcode{\sphinxupquote{{[}INFO{]} Downloading \textless{}some\_url\textgreater{} into \textless{}some\_target\textgreater{}}}, or fine\sphinxhyphen{}grained, such as \sphinxcode{\sphinxupquote{{[}DEBUG{]} Resolved dataset for status reporting: \textless{}dataset\textgreater{}}}.
The {\hyperref[\detokenize{glossary:term-log-level}]{\sphinxtermref{\DUrole{xref,std,std-term}{log level}}}} in brackets at the beginning of the line indicates how many details DataLad shares with you.

\sphinxAtStartPar
Note that {\hyperref[\detokenize{glossary:term-logging}]{\sphinxtermref{\DUrole{xref,std,std-term}{logging}}}} is not a sealed book, and happens automatically during the execution of any DataLad command.
While you were reading this book, you have seen a lot of log messages already.
Anything printed to your terminal preceded by \sphinxcode{\sphinxupquote{{[}INFO{]}}}, for example, is a log message (in this case, on the \sphinxcode{\sphinxupquote{info}} level).
When you are \sphinxstyleemphasis{consciously} logging, you simply set the log\sphinxhyphen{}level to the desired amount of information, or increase the amount of verbosity until the output gives you a hint of what went wrong.
Likewise, adjusting the log\sphinxhyphen{}level also works the other way around, and lets you \sphinxstyleemphasis{decrease} the amount of information you receive in your terminal.
See the \textit{Find-out-more}~{\findoutmoreiconinline}\textit{\ref{fom-loglevels}} {\hyperref[\detokenize{basics/101-135-help:fom-loglevels}]{\sphinxcrossref{\DUrole{std,std-ref}{on the different log\sphinxhyphen{}levels}}}} (\autopageref*{\detokenize{basics/101-135-help:fom-loglevels}}) for a complete description.

\index{log level@\spxentry{log level}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!log level@\spxentry{log level}}\index{configuration item@\spxentry{configuration item}!datalad.log.level@\spxentry{datalad.log.level}}\index{configure verbosity of command output@\spxentry{configure verbosity of command output}!with DataLad@\spxentry{with DataLad}}\index{with DataLad@\spxentry{with DataLad}!configure verbosity of command output@\spxentry{configure verbosity of command output}}\ignorespaces \begin{findoutmore}[label={fom-loglevels}, before title={\thetcbcounter\ }, float, floatplacement=tbp, check odd page=true]{Log levels}
\label{\detokenize{basics/101-135-help:fom-loglevels}}

\sphinxAtStartPar
Log levels provide the means to adjust how much information you want, and are described in human readable terms, ordered by the severity of the failures or problems reported.
The following log levels can be chosen from:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{critical}: Only catastrophes are reported. Currently, there is nothing inside of DataLad that would log at this level, so setting the log level to \sphinxstyleemphasis{critical} will result in getting no details at all, not even about errors or failures.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{error}: With this log level you will receive reports on any errors that occurred within the program during command execution.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{warning}: At this log level, the command execution will report on usual situations and anything that \sphinxstyleemphasis{might} be a problem, in addition to report anything from the \sphinxstyleemphasis{error} log level. .

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{info}: This log level will include reports by the program that indicate normal behavior and serve to keep you up to date about the current state of things, in additions to warning and error logging messages.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{debug}: This log level is very useful to troubleshoot a problem, and results in DataLad telling you \sphinxstyleemphasis{a lot} about what it is doing.

\end{itemize}

\sphinxAtStartPar
Other than log \sphinxstyleemphasis{levels}, you can also adjust the amount of information provided with numerical granularity. Instead of specifying a log level, provide an integer between 1 and 50, with lower values denoting more debugging information.

\sphinxAtStartPar
Raising the log level (e.g, to \sphinxcode{\sphinxupquote{error}}, or \sphinxcode{\sphinxupquote{40}}) will decrease the amount of information and output you will receive, while lowering it (e.g., to \sphinxcode{\sphinxupquote{debug}} or \sphinxcode{\sphinxupquote{10}}) will increase it.

\bigskip

\sphinxAtStartPar
\sphinxstylestrong{Configure log levels}

\medskip

\sphinxAtStartPar
The log level can also be set (for different scopes) using the \sphinxcode{\sphinxupquote{datalad.log.level}} configuration variable, or the corresponding environment variable \sphinxcode{\sphinxupquote{DATALAD\_LOG\_LEVEL}}.

\sphinxAtStartPar
To set the log level for a single command, for example, set it in front of the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nv}{DATALAD\PYGZus{}LOG\PYGZus{}LEVEL}\PYG{o}{=}debug\PYG{+w}{ }datalad\PYG{+w}{ }status
\end{sphinxVerbatim}

\sphinxAtStartPar
And to set the log level for the rest of the shell session, export it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }\PYG{n+nb}{export}\PYG{+w}{ }\PYG{n+nv}{DATALAD\PYGZus{}LOG\PYGZus{}LEVEL}\PYG{o}{=}debug
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }status
\PYG{g+gp}{\PYGZdl{} }...
\end{sphinxVerbatim}

\sphinxAtStartPar
You can find out a bit more on environment variable {\hyperref[\detokenize{basics/101-123-config2:fom-envvar}]{\sphinxcrossref{\DUrole{std,std-ref}{in the Findoutmore on environment variables}}}} (\autopageref*{\detokenize{basics/101-123-config2:fom-envvar}}).
The configuration variable can be used to set the log level on a user (global) or system\sphinxhyphen{}wide level with the \sphinxcode{\sphinxupquote{git config}} command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git\PYG{+w}{ }config\PYG{+w}{ }\PYGZhy{}\PYGZhy{}global\PYG{+w}{ }datalad.log.level\PYG{+w}{ }debug
\end{sphinxVerbatim}


\end{findoutmore}

\sphinxAtStartPar
Setting a log level can be done in the form of an {\hyperref[\detokenize{glossary:term-environment-variable}]{\sphinxtermref{\DUrole{xref,std,std-term}{environment variable}}}}, a configuration, or with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}l}}/\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}log\sphinxhyphen{}level}} flag appended directly after the main \sphinxcode{\sphinxupquote{ datalad}} command.
To get extensive information on what \sphinxcode{\sphinxupquote{datalad status}} does underneath the hood, your command could look like this (but its output is shortened):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }datalad\PYG{+w}{ }\PYGZhy{}\PYGZhy{}log\PYGZhy{}level\PYG{+w}{ }debug\PYG{+w}{ }status
\PYG{g+go}{[DEBUG] Resolved dataset to report status: /home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101}
\PYG{g+go}{[DEBUG] Done query repo: [\PYGZsq{}ls\PYGZhy{}files\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZhy{}stage\PYGZsq{}, \PYGZsq{}\PYGZhy{}z\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZhy{}exclude\PYGZhy{}standard\PYGZsq{}, \PYGZsq{}\PYGZhy{}o\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZhy{}directory\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZhy{}no\PYGZhy{}empty\PYGZhy{}directory\PYGZsq{}]}
\PYG{g+go}{[DEBUG] Done AnnexRepo(/home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/recordings/longnow).get\PYGZus{}content\PYGZus{}info(...)}
\PYG{g+go}{[DEBUG] Run [\PYGZsq{}git\PYGZsq{}, \PYGZsq{}\PYGZhy{}c\PYGZsq{}, \PYGZsq{}diff.ignoreSubmodules=none\PYGZsq{}, \PYGZsq{}\PYGZhy{}c\PYGZsq{}, \PYGZsq{}core.quotepath=false\PYGZsq{}, \PYGZsq{}ls\PYGZhy{}files\PYGZsq{}, \PYGZsq{}\PYGZhy{}z\PYGZsq{}, \PYGZsq{}\PYGZhy{}m\PYGZsq{}, \PYGZsq{}\PYGZhy{}d\PYGZsq{}] (protocol\PYGZus{}class=GeneratorStdOutErrCapture) (cwd=/home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/recordings/longnow)}
\PYG{g+go}{[DEBUG] AnnexRepo(/home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/recordings/longnow).get\PYGZus{}content\PYGZus{}info(...)}
\PYG{g+go}{[DEBUG] Query repo: [\PYGZsq{}ls\PYGZhy{}tree\PYGZsq{}, \PYGZsq{}HEAD\PYGZsq{}, \PYGZsq{}\PYGZhy{}z\PYGZsq{}, \PYGZsq{}\PYGZhy{}r\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZhy{}full\PYGZhy{}tree\PYGZsq{}, \PYGZsq{}\PYGZhy{}l\PYGZsq{}]}
\PYG{g+go}{[DEBUG] Run [\PYGZsq{}git\PYGZsq{}, \PYGZsq{}\PYGZhy{}c\PYGZsq{}, \PYGZsq{}diff.ignoreSubmodules=none\PYGZsq{}, \PYGZsq{}\PYGZhy{}c\PYGZsq{}, \PYGZsq{}core.quotepath=false\PYGZsq{}, \PYGZsq{}ls\PYGZhy{}tree\PYGZsq{}, \PYGZsq{}HEAD\PYGZsq{}, \PYGZsq{}\PYGZhy{}z\PYGZsq{}, \PYGZsq{}\PYGZhy{}r\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZhy{}full\PYGZhy{}tree\PYGZsq{}, \PYGZsq{}\PYGZhy{}l\PYGZsq{}] (protocol\PYGZus{}class=GeneratorStdOutErrCapture) (cwd=/home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/recordings/longnow)}
\PYG{g+go}{[DEBUG] Done query repo: [\PYGZsq{}ls\PYGZhy{}tree\PYGZsq{}, \PYGZsq{}HEAD\PYGZsq{}, \PYGZsq{}\PYGZhy{}z\PYGZsq{}, \PYGZsq{}\PYGZhy{}r\PYGZsq{}, \PYGZsq{}\PYGZhy{}\PYGZhy{}full\PYGZhy{}tree\PYGZsq{}, \PYGZsq{}\PYGZhy{}l\PYGZsq{}]}
\PYG{g+go}{[DEBUG] Done AnnexRepo(/home/me/dl\PYGZhy{}101/DataLad\PYGZhy{}101/recordings/longnow).get\PYGZus{}content\PYGZus{}info(...)}
\PYG{g+go}{nothing to save, working tree clean}
\end{sphinxVerbatim}

\sphinxAtStartPar
This output is extensive and detailed, but it precisely shows the sequence of commands and arguments that are run prior to a failure or crash, and all additional information that is reported with the log levels \sphinxcode{\sphinxupquote{info}} or \sphinxcode{\sphinxupquote{debug}} can be very helpful to find out what is wrong.
Even if the vast amount of detail in output generated with \sphinxcode{\sphinxupquote{debug}} logging appears overwhelming, it can make sense to find out at which point an execution stalls, whether arguments, commands, or datasets reported in the debug output are what you expect them to be, and to forward all information into any potential GitHub issue you will be creating.

\sphinxAtStartPar
Finally, other than logging with a DataLad command, it sometimes can be useful to turn to {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} or {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} for logging.
For failing \sphinxcode{\sphinxupquote{datalad get}} calls, it may be useful to retry the retrieval using \sphinxcode{\sphinxupquote{git annex get \sphinxhyphen{}d \sphinxhyphen{}v \textless{}file\textgreater{}}}, where \sphinxcode{\sphinxupquote{\sphinxhyphen{}d}} (debug) and \sphinxcode{\sphinxupquote{\sphinxhyphen{}v}} (verbose) increase the amount of detail about the command execution and failure.
In rare cases where you suspect something might be wrong with Git, setting the environment variables \sphinxcode{\sphinxupquote{GIT\_TRACE}} and \sphinxcode{\sphinxupquote{GIT\_TRACE\_SETUP}} to \sphinxcode{\sphinxupquote{2}} prior to running a Git command will give you debugging output.


\subsection{Debugging}
\label{\detokenize{basics/101-135-help:debug}}\label{\detokenize{basics/101-135-help:id3}}
\sphinxAtStartPar
If the additional level of detail provided by logging messages is not enough, you can go further with actual {\hyperref[\detokenize{glossary:term-debugging}]{\sphinxtermref{\DUrole{xref,std,std-term}{debugging}}}}.
For this, add the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}dbg}} or \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}idbg}} flag to the main \sphinxcode{\sphinxupquote{ datalad}} command, as in \sphinxcode{\sphinxupquote{datalad \sphinxhyphen{}\sphinxhyphen{}dbg status}}.
Adding this flag will enter a \sphinxhref{https://docs.python.org/3/library/pdb.html}{Python} or \sphinxhref{https://ipython.org}{IPython debugger} when something unexpectedly crashes.
This allows you to debug the program right when it fails, inspect available variables and their values, or step back and forth through the source code.
Note that debugging experience is not a prerequisite when using DataLad \textendash{} although it is \sphinxhref{https://www.monkeyuser.com/2017/step-by-step-debugging}{an exciting life skill}.
\sphinxhref{https://docs.python.org/3/library/pdb.html\#debugger-commands}{The official Python docs} provide a good overview on the available debugger commands if you are interested in learning more about this.

\appendix

\sphinxstepscope


\chapter{Appendix}
\label{\detokenize{book_appendix:appendix}}\label{\detokenize{book_appendix::doc}}
\begin{figure}[tbp]
\centering

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{remote_designteam}.pdf}
\end{figure}

\sphinxstepscope


\section{Glossary}
\label{\detokenize{glossary:glossary}}\label{\detokenize{glossary:id1}}\label{\detokenize{glossary::doc}}\begin{description}
\sphinxlineitem{absolute path\index{absolute path@\spxentry{absolute path}|spxpagem}\phantomsection\label{\detokenize{glossary:term-absolute-path}}}
\index{file system concept@\spxentry{file system concept}!path (absolute)@\spxentry{path}\spxextra{absolute}}\ignorespaces 
\sphinxAtStartPar
The complete path from the root of the file system. On Unix\sphinxhyphen{}like systems, absolute paths always start with \sphinxcode{\sphinxupquote{/}}, and on Windows systems, they start with a \sphinxcode{\sphinxupquote{\textbackslash{}}} (likely prefixed by a disk identifier).
Examples: \sphinxcode{\sphinxupquote{/home/user/Pictures/xkcd\sphinxhyphen{}webcomics/530.png}}, \sphinxcode{\sphinxupquote{C:\textbackslash{}Users\textbackslash{}user\textbackslash{}Pictures\textbackslash{}xkcd\sphinxhyphen{}webcomics\textbackslash{}530.png}}. See also {\hyperref[\detokenize{glossary:term-relative-path}]{\sphinxtermref{\DUrole{xref,std,std-term}{relative path}}}}.

\sphinxlineitem{adjusted branch\index{adjusted branch@\spxentry{adjusted branch}|spxpagem}\phantomsection\label{\detokenize{glossary:term-adjusted-branch}}}
\index{adjusted branch@\spxentry{adjusted branch}!in adjusted mode@\spxentry{in adjusted mode}}\index{in adjusted mode@\spxentry{in adjusted mode}!adjusted branch@\spxentry{adjusted branch}}\index{adjusted branch@\spxentry{adjusted branch}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!adjusted branch@\spxentry{adjusted branch}}\ignorespaces 
\sphinxAtStartPar
A specially managed {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} in a dataset.
An adjusted branch presents a modified (adjusted) view on its
{\hyperref[\detokenize{glossary:term-corresponding-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{corresponding branch}}}}. The most common use of an adjusted branch
is a work tree where all files are “unlocked”.
Such a branch is named \sphinxcode{\sphinxupquote{adjusted/\textless{}branchname\textgreater{}(unlocked)}}, and
all files handled by {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} are immediately modifiable.
Instead of referencing data in the {\hyperref[\detokenize{glossary:term-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{annex}}}} with a {\hyperref[\detokenize{glossary:term-symlink}]{\sphinxtermref{\DUrole{xref,std,std-term}{symlink}}}},
unlocked files need to be copies of the data in the annex.
Files where no content is available locally are also files, but only
contain placeholder content. Some adjusted modes hide files without
available content entirely.
Adjusted branches are locally managed, and it is not meaningful to push
them to other dataset clones.
Adjusted branches primarily exist as the default branch on so\sphinxhyphen{}called
{\hyperref[\detokenize{glossary:term-crippled-file-system}]{\sphinxtermref{\DUrole{xref,std,std-term}{crippled file system}}}}s such as Windows.

\sphinxlineitem{adjusted mode\index{adjusted mode@\spxentry{adjusted mode}|spxpagem}\phantomsection\label{\detokenize{glossary:term-adjusted-mode}}}
\index{adjusted mode@\spxentry{adjusted mode}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!adjusted mode@\spxentry{adjusted mode}}\ignorespaces 
\sphinxAtStartPar
A repository mode that used an {\hyperref[\detokenize{glossary:term-adjusted-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{adjusted branch}}}} for the work tree.
This mode can be entered manually (see \sphinxcode{\sphinxupquote{git annex adjust}}), or automatically
when git\sphinxhyphen{}annex detects a file system with insufficient capabilities
(see {\hyperref[\detokenize{glossary:term-crippled-file-system}]{\sphinxtermref{\DUrole{xref,std,std-term}{crippled file system}}}}).

\sphinxlineitem{annex\index{annex@\spxentry{annex}|spxpagem}\phantomsection\label{\detokenize{glossary:term-annex}}}
\index{annex@\spxentry{annex}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!annex@\spxentry{annex}}\ignorespaces 
\sphinxAtStartPar
git\sphinxhyphen{}annex concept: a different word for {\hyperref[\detokenize{glossary:term-object-tree}]{\sphinxtermref{\DUrole{xref,std,std-term}{object\sphinxhyphen{}tree}}}}.

\sphinxlineitem{annex key\index{annex key@\spxentry{annex key}|spxpagem}\phantomsection\label{\detokenize{glossary:term-annex-key}}}
\index{file content identifier@\spxentry{file content identifier}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!file content identifier@\spxentry{file content identifier}}\index{annex key@\spxentry{annex key}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!annex key@\spxentry{annex key}}\ignorespaces 
\sphinxAtStartPar
Git\sphinxhyphen{}annex file content identifier. It is used for naming objects
in a dataset {\hyperref[\detokenize{glossary:term-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{annex}}}}. These identifiers follow a
\sphinxhref{https://git-annex.branchable.com/internals/key\_format}{strict naming scheme}.
However, various types of identifiers, so called
\sphinxhref{https://git-annex.branchable.com/backends}{backends} can be used. Most
backends are based on a {\hyperref[\detokenize{glossary:term-checksum}]{\sphinxtermref{\DUrole{xref,std,std-term}{checksum}}}}, thereby enabling content verification
and data integrity checks for files in an annex.

\sphinxlineitem{annex UUID\index{annex UUID@\spxentry{annex UUID}|spxpagem}\phantomsection\label{\detokenize{glossary:term-annex-UUID}}}
\index{location identifier@\spxentry{location identifier}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!location identifier@\spxentry{location identifier}}\index{annex uuid@\spxentry{annex uuid}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!annex uuid@\spxentry{annex uuid}}\ignorespaces 
\sphinxAtStartPar
A {\hyperref[\detokenize{glossary:term-UUID}]{\sphinxtermref{\DUrole{xref,std,std-term}{UUID}}}} assigned to an annex of each individual {\hyperref[\detokenize{glossary:term-clone}]{\sphinxtermref{\DUrole{xref,std,std-term}{clone}}}} of a dataset repository.
{\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} uses this UUID to track file content availability information.
The UUID is available under the configuration key \sphinxcode{\sphinxupquote{annex.uuid}} and is stored in the
configuration file of a local clone (\sphinxcode{\sphinxupquote{\textless{}dataset root\textgreater{}/.git/config}}).
A single dataset instance (i.e. a local clone) has exactly one annex UUID,
but other clones of the same dataset each have their own unique annex UUIDs.

\sphinxlineitem{bare Git repositories\index{bare Git repositories@\spxentry{bare Git repositories}|spxpagem}\phantomsection\label{\detokenize{glossary:term-bare-Git-repositories}}}
\index{bare repository@\spxentry{bare repository}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!bare repository@\spxentry{bare repository}}\ignorespaces 
\sphinxAtStartPar
A bare Git repository is a repository that contains the contents of the \sphinxcode{\sphinxupquote{.git}}
directory of regular DataLad datasets or Git repositories, but no worktree
or checkout. This has advantages: The repository is leaner, it is easier
for administrators to perform garbage collections, and it is required if you
want to push to it at all times. You can find out more on what bare repositories are and how to use them
\sphinxhref{https://git-scm.com/book/en/v2/Git-on-the-Server-Getting-Git-on-a-Server}{in the Git documentation}.

\sphinxlineitem{bash\index{bash@\spxentry{bash}|spxpagem}\phantomsection\label{\detokenize{glossary:term-bash}}}
\index{shell@\spxentry{shell}!bash@\spxentry{bash}}\ignorespaces 
\sphinxAtStartPar
A Unix {\hyperref[\detokenize{glossary:term-shell}]{\sphinxtermref{\DUrole{xref,std,std-term}{shell}}}} and command language.

\sphinxlineitem{Bitbucket\index{Bitbucket@\spxentry{Bitbucket}|spxpagem}\phantomsection\label{\detokenize{glossary:term-Bitbucket}}}
\index{dataset hosting@\spxentry{dataset hosting}!Bitbucket@\spxentry{Bitbucket}}\index{Bitbucket@\spxentry{Bitbucket}!dataset hosting@\spxentry{dataset hosting}}\ignorespaces 
\sphinxAtStartPar
Bitbucket is an online platform where one can store and share version
controlled projects using Git (and thus also DataLad project), similar
to {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}} or {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}. See \sphinxhref{https://bitbucket.org}{bitbucket.org}.

\sphinxlineitem{branch\index{branch@\spxentry{branch}|spxpagem}\phantomsection\label{\detokenize{glossary:term-branch}}}
\index{branch@\spxentry{branch}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!branch@\spxentry{branch}}\ignorespaces 
\sphinxAtStartPar
Git concept: A lightweight, independent history streak of your dataset. Branches can contain less,
more, or changed files compared to other branches, and one can {\hyperref[\detokenize{glossary:term-merge}]{\sphinxtermref{\DUrole{xref,std,std-term}{merge}}}} the changes
a branch contains into another branch.

\sphinxlineitem{checksum\index{checksum@\spxentry{checksum}|spxpagem}\phantomsection\label{\detokenize{glossary:term-checksum}}}
\index{checksum@\spxentry{checksum}|see{\textquotesingle{}shasum\textquotesingle{}}}\ignorespaces 
\sphinxAtStartPar
An alternative term to {\hyperref[\detokenize{glossary:term-shasum}]{\sphinxtermref{\DUrole{xref,std,std-term}{shasum}}}}.

\sphinxlineitem{clone\index{clone@\spxentry{clone}|spxpagem}\phantomsection\label{\detokenize{glossary:term-clone}}}
\index{clone@\spxentry{clone}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!clone@\spxentry{clone}}\ignorespaces 
\sphinxAtStartPar
Git concept: A copy of a {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} repository. In Git\sphinxhyphen{}terminology, all “installed” datasets
are clones.

\sphinxlineitem{commit\index{commit@\spxentry{commit}|spxpagem}\phantomsection\label{\detokenize{glossary:term-commit}}}
\index{commit@\spxentry{commit}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!commit@\spxentry{commit}}\ignorespaces 
\sphinxAtStartPar
Git concept: Adding selected changes of a file or dataset to the repository, and thus making these changes
part of the revision history of the repository. Should always have an informative {\hyperref[\detokenize{glossary:term-commit-message}]{\sphinxtermref{\DUrole{xref,std,std-term}{commit message}}}}.

\sphinxlineitem{commit message\index{commit message@\spxentry{commit message}|spxpagem}\phantomsection\label{\detokenize{glossary:term-commit-message}}}
\index{commit message@\spxentry{commit message}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!commit message@\spxentry{commit message}}\ignorespaces 
\sphinxAtStartPar
Git concept: A concise summary of changes you should attach to a \sphinxcode{\sphinxupquote{datalad save}} command. This summary will
show up in your {\hyperref[\detokenize{glossary:term-DataLad-dataset}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad dataset}}}} history.

\sphinxlineitem{compute node\index{compute node@\spxentry{compute node}|spxpagem}\phantomsection\label{\detokenize{glossary:term-compute-node}}}
\sphinxAtStartPar
A compute node is an individual computer, part of a {\hyperref[\detokenize{glossary:term-high-performance-computing}]{\sphinxtermref{\DUrole{xref,std,std-term}{high\sphinxhyphen{}performance computing}}}} or {\hyperref[\detokenize{glossary:term-high-throughput-computing}]{\sphinxtermref{\DUrole{xref,std,std-term}{high\sphinxhyphen{}throughput computing}}}} (HTC) cluster.

\sphinxlineitem{conda\index{conda@\spxentry{conda}|spxpagem}\phantomsection\label{\detokenize{glossary:term-conda}}}
\sphinxAtStartPar
A package, dependency, and environment management system for a number of programming languages.
Find out more at \sphinxhref{https://docs.conda.io}{docs.conda.io}.
It overlaps with {\hyperref[\detokenize{glossary:term-pip}]{\sphinxtermref{\DUrole{xref,std,std-term}{pip}}}} in functionality, but it is advised to not use both tools simultaneously for package management.

\sphinxlineitem{container\index{container@\spxentry{container}|spxpagem}\phantomsection\label{\detokenize{glossary:term-container}}}
\index{container concept@\spxentry{container concept}!container@\spxentry{container}|spxpagem}\ignorespaces 
\sphinxAtStartPar
A running instance of a {\hyperref[\detokenize{glossary:term-container-image}]{\sphinxtermref{\DUrole{xref,std,std-term}{container image}}}} image that is ready to use.

\sphinxlineitem{container image\index{container image@\spxentry{container image}|spxpagem}\phantomsection\label{\detokenize{glossary:term-container-image}}}
\index{container concept@\spxentry{container concept}!image@\spxentry{image}|spxpagem}\ignorespaces 
\sphinxAtStartPar
A container image is \sphinxstyleemphasis{built} from a {\hyperref[\detokenize{glossary:term-container-recipe}]{\sphinxtermref{\DUrole{xref,std,std-term}{container recipe}}}}.
It is a file system snapshot in a file, populated with software specified in the recipe, and some initial configuration.

\sphinxlineitem{container recipe\index{container recipe@\spxentry{container recipe}|spxpagem}\phantomsection\label{\detokenize{glossary:term-container-recipe}}}
\index{container concept@\spxentry{container concept}!recipe@\spxentry{recipe}|spxpagem}\ignorespaces 
\sphinxAtStartPar
A text file that lists all required components of the computational environment that a {\hyperref[\detokenize{glossary:term-software-container}]{\sphinxtermref{\DUrole{xref,std,std-term}{software container}}}} should contain.
It is made by a human user.

\sphinxlineitem{corresponding branch\index{corresponding branch@\spxentry{corresponding branch}|spxpagem}\phantomsection\label{\detokenize{glossary:term-corresponding-branch}}}
\index{corresponding branch@\spxentry{corresponding branch}!in adjusted mode@\spxentry{in adjusted mode}}\index{in adjusted mode@\spxentry{in adjusted mode}!corresponding branch@\spxentry{corresponding branch}}\ignorespaces 
\sphinxAtStartPar
A {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} underlying a particular {\hyperref[\detokenize{glossary:term-adjusted-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{adjusted branch}}}}.
Changes committed to an adjusted branch are propagated to its corresponding
branch. Only the corresponding branch is suitable for sharing with other
repository clones.

\sphinxlineitem{crippled file system\index{crippled file system@\spxentry{crippled file system}|spxpagem}\phantomsection\label{\detokenize{glossary:term-crippled-file-system}}}
\index{crippled file system@\spxentry{crippled file system}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!crippled file system@\spxentry{crippled file system}}\ignorespaces 
\sphinxAtStartPar
git\sphinxhyphen{}annex concept: A file system that does not allow making symlinks or removing write {\hyperref[\detokenize{glossary:term-permissions}]{\sphinxtermref{\DUrole{xref,std,std-term}{permissions}}}} from files. Examples for this are \sphinxhref{https://en.wikipedia.org/wiki/Design\_of\_the\_FAT\_file\_system}{FAT} (likely used by your USB sticks) or \sphinxhref{https://en.wikipedia.org/wiki/NTFS}{NTFS} (used on Windows systems of the last three decades).

\sphinxlineitem{DataLad dataset\index{DataLad dataset@\spxentry{DataLad dataset}|spxpagem}\phantomsection\label{\detokenize{glossary:term-DataLad-dataset}}}
\index{dataset@\spxentry{dataset}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!dataset@\spxentry{dataset}}\ignorespaces 
\sphinxAtStartPar
A DataLad dataset is a Git repository that may or may not have a data annex that is used to
manage data referenced in a dataset. In practice, most DataLad datasets will come with an annex.

\sphinxlineitem{DataLad extension\index{DataLad extension@\spxentry{DataLad extension}|spxpagem}\phantomsection\label{\detokenize{glossary:term-DataLad-extension}}}
\index{extension@\spxentry{extension}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!extension@\spxentry{extension}}\ignorespaces 
\sphinxAtStartPar
Python packages that equip DataLad with specialized commands. The online\sphinxhyphen{}handbook has an entire chapter that
gives an overview of available extensions contains demonstrations.

\sphinxlineitem{DataLad Gooey\index{DataLad Gooey@\spxentry{DataLad Gooey}|spxpagem}\phantomsection\label{\detokenize{glossary:term-DataLad-Gooey}}}
\sphinxAtStartPar
A {\hyperref[\detokenize{glossary:term-DataLad-extension}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad extension}}}} that provides DataLad with a graphical user interface. Find out more in its Documentation: \sphinxhref{https://docs.datalad.org/projects/gooey}{docs.datalad.org/projects/gooey}

\sphinxlineitem{DataLad subdataset\index{DataLad subdataset@\spxentry{DataLad subdataset}|spxpagem}\phantomsection\label{\detokenize{glossary:term-DataLad-subdataset}}}
\index{subdataset@\spxentry{subdataset}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!subdataset@\spxentry{subdataset}}\ignorespaces 
\sphinxAtStartPar
A DataLad dataset contained within a different DataLad dataset (the parent or {\hyperref[\detokenize{glossary:term-DataLad-superdataset}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad superdataset}}}}).

\sphinxlineitem{DataLad superdataset\index{DataLad superdataset@\spxentry{DataLad superdataset}|spxpagem}\phantomsection\label{\detokenize{glossary:term-DataLad-superdataset}}}
\index{superdataset@\spxentry{superdataset}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!superdataset@\spxentry{superdataset}}\ignorespaces 
\sphinxAtStartPar
A DataLad dataset that contains one or more levels of other DataLad datasets ({\hyperref[\detokenize{glossary:term-DataLad-subdataset}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad subdataset}}}}).

\sphinxlineitem{dataset ID\index{dataset ID@\spxentry{dataset ID}|spxpagem}\phantomsection\label{\detokenize{glossary:term-dataset-ID}}}
\index{dataset identifier@\spxentry{dataset identifier}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!dataset identifier@\spxentry{dataset identifier}}\index{configuration item@\spxentry{configuration item}!datalad.dataset.id@\spxentry{datalad.dataset.id}}\ignorespaces 
\sphinxAtStartPar
A {\hyperref[\detokenize{glossary:term-UUID}]{\sphinxtermref{\DUrole{xref,std,std-term}{UUID}}}} that identifies a dataset as a unit \textendash{} across its entire history and flavors.
This ID is stored in a dataset’s own configuration file (\sphinxcode{\sphinxupquote{\textless{}dataset root\textgreater{}/.datalad/config}})
under the configuration key \sphinxcode{\sphinxupquote{datalad.dataset.id}}.
As this configuration is stored in a file that is part of the Git
history of a dataset, this ID is identical for all {\hyperref[\detokenize{glossary:term-clone}]{\sphinxtermref{\DUrole{xref,std,std-term}{clone}}}}s of a dataset and across all
its versions.

\sphinxlineitem{Debian\index{Debian@\spxentry{Debian}|spxpagem}\phantomsection\label{\detokenize{glossary:term-Debian}}}
\sphinxAtStartPar
A common Linux distribution. \sphinxhref{https://www.debian.org/index.en.html}{More information at www.debian.org}.

\sphinxlineitem{debugging\index{debugging@\spxentry{debugging}|spxpagem}\phantomsection\label{\detokenize{glossary:term-debugging}}}
\sphinxAtStartPar
Finding and resolving problems within a computer program.
To learn about debugging a failed execution of a DataLad command, take a look at the section {\hyperref[\detokenize{basics/101-135-help:debug}]{\sphinxcrossref{\DUrole{std,std-ref}{Debugging}}}} (\autopageref*{\detokenize{basics/101-135-help:debug}}).

\sphinxlineitem{Docker\index{Docker@\spxentry{Docker}|spxpagem}\phantomsection\label{\detokenize{glossary:term-Docker}}}
\sphinxAtStartPar
\sphinxhref{https://www.docker.com}{Docker} is a containerization software that can package software into {\hyperref[\detokenize{glossary:term-software-container}]{\sphinxtermref{\DUrole{xref,std,std-term}{software container}}}}s, similar to {\hyperref[\detokenize{glossary:term-Singularity}]{\sphinxtermref{\DUrole{xref,std,std-term}{Singularity}}}}.
Find out more on \sphinxhref{https://en.wikipedia.org/wiki/Docker\_(software)}{Wikipedia}.

\sphinxlineitem{Docker\sphinxhyphen{}Hub\index{Docker\sphinxhyphen{}Hub@\spxentry{Docker\sphinxhyphen{}Hub}|spxpagem}\phantomsection\label{\detokenize{glossary:term-Docker-Hub}}}
\index{hub@\spxentry{hub}!Docker@\spxentry{Docker}}\index{Docker@\spxentry{Docker}!hub@\spxentry{hub}}\ignorespaces 
\sphinxAtStartPar
\sphinxhref{https://hub.docker.com}{Docker Hub} is a library for {\hyperref[\detokenize{glossary:term-Docker}]{\sphinxtermref{\DUrole{xref,std,std-term}{Docker}}}} {\hyperref[\detokenize{glossary:term-container-image}]{\sphinxtermref{\DUrole{xref,std,std-term}{container image}}}}s.
Among other things, it hosts and builds Docker container images.
You can can \sphinxstyleemphasis{pull} {\hyperref[\detokenize{glossary:term-container-image}]{\sphinxtermref{\DUrole{xref,std,std-term}{container image}}}}s built from a publicly shared {\hyperref[\detokenize{glossary:term-container-recipe}]{\sphinxtermref{\DUrole{xref,std,std-term}{container recipe}}}} from it.

\sphinxlineitem{DOI\index{DOI@\spxentry{DOI}|spxpagem}\phantomsection\label{\detokenize{glossary:term-DOI}}}
\sphinxAtStartPar
A digital object identifier (DOI) is a character string used to permanently identify
a resource and link to in on the web. A DOI will always refer to the one resource
it was assigned to, and only that one.

\sphinxlineitem{extractor\index{extractor@\spxentry{extractor}|spxpagem}\phantomsection\label{\detokenize{glossary:term-extractor}}}
\index{metadata extractor@\spxentry{metadata extractor}!DataLad concept@\spxentry{DataLad concept}}\ignorespaces 
\sphinxAtStartPar
DataLad concept: A metadata extractor of the {\hyperref[\detokenize{glossary:term-DataLad-extension}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad extension}}}} \sphinxcode{\sphinxupquote{datalad\sphinxhyphen{}metalad}}
enables DataLad to extract and aggregate special types of metadata.

\sphinxlineitem{environment variable\index{environment variable@\spxentry{environment variable}|spxpagem}\phantomsection\label{\detokenize{glossary:term-environment-variable}}}
\index{operating system concept@\spxentry{operating system concept}!environment variable@\spxentry{environment variable}|spxpagem}\ignorespaces 
\sphinxAtStartPar
A variable made up of a name/value pair. Programs using a given environment variable will use its associated value for their execution.
See the {\hyperref[\detokenize{basics/101-123-config2:fom-envvar}]{\sphinxcrossref{\DUrole{std,std-ref}{Find\sphinxhyphen{}out\sphinxhyphen{}more on environment variables}}}} (\autopageref*{\detokenize{basics/101-123-config2:fom-envvar}}) for details.

\sphinxlineitem{ephemeral clone\index{ephemeral clone@\spxentry{ephemeral clone}|spxpagem}\phantomsection\label{\detokenize{glossary:term-ephemeral-clone}}}
\index{clone (ephemeral)@\spxentry{clone}\spxextra{ephemeral}!DataLad concept@\spxentry{DataLad concept}}\ignorespaces 
\sphinxAtStartPar
dataset clones that share the annex with the dataset they were cloned from, without {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} being aware of it.
On a technical level, this is achieved via symlinks.
They can be created with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}reckless ephemeral}} option of \sphinxcode{\sphinxupquote{datalad clone}}.

\sphinxlineitem{force\sphinxhyphen{}push\index{force\sphinxhyphen{}push@\spxentry{force\sphinxhyphen{}push}|spxpagem}\phantomsection\label{\detokenize{glossary:term-force-push}}}
\index{push (forced)@\spxentry{push}\spxextra{forced}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!push (forced)@\spxentry{push}\spxextra{forced}}\ignorespaces 
\sphinxAtStartPar
Git concept; Enforcing a \sphinxcode{\sphinxupquote{git push}} command with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}force}}
option. Find out more in the
\sphinxhref{https://git-scm.com/docs/git-push\#Documentation/git-push.txt---force}{documentation of git push}.

\sphinxlineitem{fork\index{fork@\spxentry{fork}|spxpagem}\phantomsection\label{\detokenize{glossary:term-fork}}}
\index{fork@\spxentry{fork}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!fork@\spxentry{fork}}\ignorespaces 
\sphinxAtStartPar
Git concept on repository hosting sites (GitHub, GitLab, Gin, …);
\sphinxhref{https://docs.github.com/en/get-started/quickstart/fork-a-repo}{A fork is a copy of a repository on a web\sphinxhyphen{}based Git repository hosting site}.

\sphinxlineitem{GIN\index{GIN@\spxentry{GIN}|spxpagem}\phantomsection\label{\detokenize{glossary:term-GIN}}}
\index{dataset hosting@\spxentry{dataset hosting}!GIN@\spxentry{GIN}|spxpagem}\ignorespaces 
\sphinxAtStartPar
A web\sphinxhyphen{}based repository store for data management that you can use to host and
share datasets. Find out more about GIN \sphinxhref{https://gin.g-node.org/G-Node/Info/wiki}{at gin.g\sphinxhyphen{}node.org}.

\sphinxlineitem{Git\index{Git@\spxentry{Git}|spxpagem}\phantomsection\label{\detokenize{glossary:term-Git}}}
\sphinxAtStartPar
A version control system to track changes made to small\sphinxhyphen{}sized files over time. You can find out
more about Git in \sphinxhref{https://git-scm.com/book/en/v2}{the (free) GitPro book}
or \sphinxhref{https://try.github.io}{interactive Git tutorials} on {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}.

\sphinxlineitem{git\sphinxhyphen{}annex\index{git\sphinxhyphen{}annex@\spxentry{git\sphinxhyphen{}annex}|spxpagem}\phantomsection\label{\detokenize{glossary:term-git-annex}}}
\sphinxAtStartPar
A distributed file synchronization system, enabling sharing and synchronizing collections
of large files. It allows managing files with {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}}, without checking the file content into Git.

\sphinxlineitem{git\sphinxhyphen{}annex branch\index{git\sphinxhyphen{}annex branch@\spxentry{git\sphinxhyphen{}annex branch}|spxpagem}\phantomsection\label{\detokenize{glossary:term-git-annex-branch}}}
\index{git\sphinxhyphen{}annex branch@\spxentry{git\sphinxhyphen{}annex branch}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\index{git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}!git\sphinxhyphen{}annex branch@\spxentry{git\sphinxhyphen{}annex branch}}\ignorespaces 
\sphinxAtStartPar
This {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} exists in your dataset if the dataset contains
an {\hyperref[\detokenize{glossary:term-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{annex}}}}.  The git\sphinxhyphen{}annex branch is completely unconnected to any
other branch in your dataset, and contains different types of log files.
Its contents are used for git\sphinxhyphen{}annex’s internal tracking of the dataset
and its annexed contents.
The branch is managed by {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}, and you should not tamper with
it unless you absolutely know what you are doing.

\sphinxlineitem{Git config file\index{Git config file@\spxentry{Git config file}|spxpagem}\phantomsection\label{\detokenize{glossary:term-Git-config-file}}}
\index{configuration file@\spxentry{configuration file}!Git concept@\spxentry{Git concept}}\ignorespaces 
\sphinxAtStartPar
A file in which {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} stores configuration option. Such a file usually exists on
the system, user, and repository (dataset) level.

\sphinxlineitem{GitHub\index{GitHub@\spxentry{GitHub}|spxpagem}\phantomsection\label{\detokenize{glossary:term-GitHub}}}
\index{dataset hosting@\spxentry{dataset hosting}!GitHub@\spxentry{GitHub}}\ignorespaces 
\sphinxAtStartPar
GitHub is an online platform where one can store and share version controlled projects
using Git (and thus also DataLad project). See \sphinxhref{https://github.com}{GitHub.com}.

\sphinxlineitem{gitk\index{gitk@\spxentry{gitk}|spxpagem}\phantomsection\label{\detokenize{glossary:term-gitk}}}
\index{gitk@\spxentry{gitk}!Git command@\spxentry{Git command}}\index{Git command@\spxentry{Git command}!gitk@\spxentry{gitk}}\ignorespaces 
\sphinxAtStartPar
A repository browser that displays changes in a repository or a selected set of commits. It
visualizes a commit graph, information related to each commit, and the files in the trees
of each revision.

\sphinxlineitem{GitLab\index{GitLab@\spxentry{GitLab}|spxpagem}\phantomsection\label{\detokenize{glossary:term-GitLab}}}
\index{dataset hosting@\spxentry{dataset hosting}!GitLab@\spxentry{GitLab}}\ignorespaces 
\sphinxAtStartPar
An online platform to host and share software projects version controlled with {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}},
similar to {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}. See \sphinxhref{https://about.gitlab.com}{Gitlab.com}.

\sphinxlineitem{globbing\index{globbing@\spxentry{globbing}|spxpagem}\phantomsection\label{\detokenize{glossary:term-globbing}}}
\index{command line concept@\spxentry{command line concept}!globbing@\spxentry{globbing}}\ignorespaces 
\sphinxAtStartPar
A powerful pattern matching function of a shell. Allows to match the names of multiple files
or directories. The most basic pattern is \sphinxcode{\sphinxupquote{*}}, which matches any number of character, such
that \sphinxcode{\sphinxupquote{ls *.txt}} will list all \sphinxcode{\sphinxupquote{.txt}} files in the current directory.
You can read about more about Pattern Matching in
\sphinxhref{https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html\#Pattern-Matching}{Bash’s Docs}.

\sphinxlineitem{high\sphinxhyphen{}performance computing\index{high\sphinxhyphen{}performance computing@\spxentry{high\sphinxhyphen{}performance computing}|spxpagem}\phantomsection\label{\detokenize{glossary:term-high-performance-computing}}}\sphinxlineitem{HPC\index{HPC@\spxentry{HPC}|spxpagem}\phantomsection\label{\detokenize{glossary:term-HPC}}}
\sphinxAtStartPar
Aggregating computing power from a bond of computers in a way that delivers higher performance than a typical desktop computer in order to solve computing tasks that require high computing power or demand a lot of disk space or memory.

\sphinxlineitem{high\sphinxhyphen{}throughput computing\index{high\sphinxhyphen{}throughput computing@\spxentry{high\sphinxhyphen{}throughput computing}|spxpagem}\phantomsection\label{\detokenize{glossary:term-high-throughput-computing}}}\sphinxlineitem{HTC\index{HTC@\spxentry{HTC}|spxpagem}\phantomsection\label{\detokenize{glossary:term-HTC}}}
\sphinxAtStartPar
A computing environment build from a bond of computers and tuned to deliver large amounts of computational power to allow parallel processing of independent computational jobs. For more information, see \sphinxhref{https://en.wikipedia.org/wiki/High-throughput\_computing}{Wikipedia}.

\sphinxlineitem{http\index{http@\spxentry{http}|spxpagem}\phantomsection\label{\detokenize{glossary:term-http}}}
\index{protocol@\spxentry{protocol}!http@\spxentry{http}}\ignorespaces 
\sphinxAtStartPar
Hypertext Transfer Protocol; A protocol for file transfer over a network.

\sphinxlineitem{https\index{https@\spxentry{https}|spxpagem}\phantomsection\label{\detokenize{glossary:term-https}}}
\index{protocol@\spxentry{protocol}!https@\spxentry{https}}\ignorespaces 
\sphinxAtStartPar
Hypertext Transfer Protocol Secure; A protocol for file transfer over a network.

\sphinxlineitem{logging\index{logging@\spxentry{logging}|spxpagem}\phantomsection\label{\detokenize{glossary:term-logging}}}
\sphinxAtStartPar
Automatic protocol creation of software processes, for example in order to gain insights into errors. To learn about logging to troubleshoot problems or remove or increase the amount of information printed to your terminal during the execution of a DataLad command, take a look at the section {\hyperref[\detokenize{basics/101-135-help:logging}]{\sphinxcrossref{\DUrole{std,std-ref}{Logging}}}} (\autopageref*{\detokenize{basics/101-135-help:logging}}).

\sphinxlineitem{log level\index{log level@\spxentry{log level}|spxpagem}\phantomsection\label{\detokenize{glossary:term-log-level}}}
\index{log level@\spxentry{log level}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!log level@\spxentry{log level}}\ignorespaces 
\sphinxAtStartPar
Adjusts the amount of verbosity during {\hyperref[\detokenize{glossary:term-logging}]{\sphinxtermref{\DUrole{xref,std,std-term}{logging}}}}.

\sphinxlineitem{main\index{main@\spxentry{main}|spxpagem}\phantomsection\label{\detokenize{glossary:term-main}}}
\index{main branch@\spxentry{main branch}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!main branch@\spxentry{main branch}}\ignorespaces 
\sphinxAtStartPar
Git concept: For the longest time, \sphinxcode{\sphinxupquote{master}} was the name of the default {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} in a dataset. More recently, the name \sphinxcode{\sphinxupquote{main}} is used. If you are not sure, you can find out if your default branch is \sphinxcode{\sphinxupquote{main}} or \sphinxcode{\sphinxupquote{master}} by running \sphinxcode{\sphinxupquote{git branch}}.

\sphinxlineitem{Makefile\index{Makefile@\spxentry{Makefile}|spxpagem}\phantomsection\label{\detokenize{glossary:term-Makefile}}}
\sphinxAtStartPar
Makefiles are recipes on how to create a digital object for the build automation tool \sphinxhref{https://en.wikipedia.org/wiki/Make\_(software)}{Make}.
They are used to build programs, but also to manage projects where some files must be automatically updated from others whenever the others change.

\sphinxlineitem{manpage\index{manpage@\spxentry{manpage}|spxpagem}\phantomsection\label{\detokenize{glossary:term-manpage}}}
\sphinxAtStartPar
Abbreviation of “manual page”. For most Unix programs, the command \sphinxcode{\sphinxupquote{man \textless{}program\sphinxhyphen{}name\textgreater{}}} will open a {\hyperref[\detokenize{glossary:term-pager}]{\sphinxtermref{\DUrole{xref,std,std-term}{pager}}}} with this commands documentation. If you have installed DataLad as a Debian package, \sphinxcode{\sphinxupquote{man}} will allow you to open DataLad manpages in your terminal.

\sphinxlineitem{master\index{master@\spxentry{master}|spxpagem}\phantomsection\label{\detokenize{glossary:term-master}}}
\index{master branch@\spxentry{master branch}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!master branch@\spxentry{master branch}}\ignorespaces 
\sphinxAtStartPar
Git concept: For the longest time, \sphinxcode{\sphinxupquote{master}} was the name of the default {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} in a dataset. More recently, the name \sphinxcode{\sphinxupquote{main}} is used. If you are not sure, you can find out if your default branch is \sphinxcode{\sphinxupquote{main}} or \sphinxcode{\sphinxupquote{master}} by running \sphinxcode{\sphinxupquote{git branch}}.

\sphinxlineitem{merge\index{merge@\spxentry{merge}|spxpagem}\phantomsection\label{\detokenize{glossary:term-merge}}}
\index{merge@\spxentry{merge}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!merge@\spxentry{merge}}\ignorespaces 
\sphinxAtStartPar
Git concept: to integrate the changes of one {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}}/{\hyperref[\detokenize{glossary:term-sibling}]{\sphinxtermref{\DUrole{xref,std,std-term}{sibling}}}}/ … into
a different branch.

\sphinxlineitem{merge request\index{merge request@\spxentry{merge request}|spxpagem}\phantomsection\label{\detokenize{glossary:term-merge-request}}}
\index{merge request@\spxentry{merge request}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!merge request@\spxentry{merge request}}\ignorespaces 
\sphinxAtStartPar
See {\hyperref[\detokenize{glossary:term-pull-request}]{\sphinxtermref{\DUrole{xref,std,std-term}{pull request}}}}.

\sphinxlineitem{metadata\index{metadata@\spxentry{metadata}|spxpagem}\phantomsection\label{\detokenize{glossary:term-metadata}}}
\sphinxAtStartPar
“Data about data”: Information about one or more aspects of data used to summarize
basic information, for example means of create of the data, creator or author, size,
or purpose of the data. For example, a digital image may include metadata that
describes how large the picture is, the color depth, the image resolution, when the image
was created, the shutter speed, and other data.

\sphinxlineitem{nano\index{nano@\spxentry{nano}|spxpagem}\phantomsection\label{\detokenize{glossary:term-nano}}}
\index{nano@\spxentry{nano}!terminal command@\spxentry{terminal command}}\index{terminal command@\spxentry{terminal command}!nano@\spxentry{nano}}\ignorespaces 
\sphinxAtStartPar
A common text\sphinxhyphen{}editor.

\sphinxlineitem{object\sphinxhyphen{}tree\index{object\sphinxhyphen{}tree@\spxentry{object\sphinxhyphen{}tree}|spxpagem}\phantomsection\label{\detokenize{glossary:term-object-tree}}}
\index{object tree@\spxentry{object tree}!git\sphinxhyphen{}annex concept@\spxentry{git\sphinxhyphen{}annex concept}}\ignorespaces 
\sphinxAtStartPar
git\sphinxhyphen{}annex concept: The place where {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}} stores available file contents. Files that are annexed get
a {\hyperref[\detokenize{glossary:term-symlink}]{\sphinxtermref{\DUrole{xref,std,std-term}{symlink}}}} added to {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} that points to the file content. A different word for {\hyperref[\detokenize{glossary:term-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{annex}}}}.

\sphinxlineitem{Open Science Framework\index{Open Science Framework@\spxentry{Open Science Framework}|spxpagem}\phantomsection\label{\detokenize{glossary:term-Open-Science-Framework}}}\sphinxlineitem{OSF\index{OSF@\spxentry{OSF}|spxpagem}\phantomsection\label{\detokenize{glossary:term-OSF}}}
\sphinxAtStartPar
An open source software project that facilitates open collaboration in science research.

\sphinxlineitem{pager\index{pager@\spxentry{pager}|spxpagem}\phantomsection\label{\detokenize{glossary:term-pager}}}
\index{command line concept@\spxentry{command line concept}!pager@\spxentry{pager}}\ignorespaces 
\sphinxAtStartPar
A \sphinxhref{https://en.wikipedia.org/wiki/Terminal\_pager}{terminal paper} is a program to view file contents in the {\hyperref[\detokenize{glossary:term-terminal}]{\sphinxtermref{\DUrole{xref,std,std-term}{terminal}}}}. Popular examples are the programs \sphinxcode{\sphinxupquote{less}} and \sphinxcode{\sphinxupquote{more}}. Some terminal output can be opened automatically in a pager, for example the output of a \sphinxcode{\sphinxupquote{git log}} command. You can use the arrow keys to navigate and scroll in the pager, and the letter \sphinxcode{\sphinxupquote{q}} to exit it.

\sphinxlineitem{permissions\index{permissions@\spxentry{permissions}|spxpagem}\phantomsection\label{\detokenize{glossary:term-permissions}}}
\index{file system concept@\spxentry{file system concept}!permissions@\spxentry{permissions}}\ignorespaces 
\sphinxAtStartPar
Access rights assigned by most file systems that determine whether a user can view (\sphinxcode{\sphinxupquote{read permission}}),
change (\sphinxcode{\sphinxupquote{write permission}}), or execute (\sphinxcode{\sphinxupquote{execute permission}}) a specific content.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{read permissions}} grant the ability to a file, or the contents (file names) in a directory.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{write permissions}} grant the ability to modify a file. When content is stored in the
{\hyperref[\detokenize{glossary:term-object-tree}]{\sphinxtermref{\DUrole{xref,std,std-term}{object\sphinxhyphen{}tree}}}} by {\hyperref[\detokenize{glossary:term-git-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{git\sphinxhyphen{}annex}}}}, your previously granted write permission for this
content is revoked to prevent accidental modifications.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{execute permissions}} grant the ability to execute a file. Any script that should be an executable
needs to get such permission.

\end{itemize}

\sphinxlineitem{pip\index{pip@\spxentry{pip}|spxpagem}\phantomsection\label{\detokenize{glossary:term-pip}}}
\index{pip@\spxentry{pip}!terminal command@\spxentry{terminal command}}\index{terminal command@\spxentry{terminal command}!pip@\spxentry{pip}}\ignorespaces 
\sphinxAtStartPar
A Python package manager. Short for “Pip installs Python”. \sphinxcode{\sphinxupquote{pip install \textless{}package name\textgreater{}}}
searches the Python package index \sphinxhref{https://pypi.org}{PyPi} for a
package and installs it while resolving any potential dependencies.

\sphinxlineitem{pipe\index{pipe@\spxentry{pipe}|spxpagem}\phantomsection\label{\detokenize{glossary:term-pipe}}}
\index{operating system concept@\spxentry{operating system concept}!pipe@\spxentry{pipe}|spxpagem}\ignorespaces 
\sphinxAtStartPar
Unix concept: A mechanism for providing the output of one command ({\hyperref[\detokenize{glossary:term-stdout}]{\sphinxtermref{\DUrole{xref,std,std-term}{stdout}}}}) as the input of a next command ({\hyperref[\detokenize{glossary:term-stdin}]{\sphinxtermref{\DUrole{xref,std,std-term}{stdin}}}}) in a Unix terminal. The standard syntax are multiple commands, separated by vertical bars (the “pipes”, “|”). Read more \sphinxhref{https://en.wikipedia.org/wiki/Pipeline\_(Unix)}{on Wikipedia}.

\sphinxlineitem{provenance\index{provenance@\spxentry{provenance}|spxpagem}\phantomsection\label{\detokenize{glossary:term-provenance}}}
\sphinxAtStartPar
A record that describes entities and processes that were involved in producing or influencing
a digital resource. It provides a critical foundation for assessing authenticity, enables trust,
and allows reproducibility.

\sphinxlineitem{publication dependency\index{publication dependency@\spxentry{publication dependency}|spxpagem}\phantomsection\label{\detokenize{glossary:term-publication-dependency}}}
\index{publication dependency@\spxentry{publication dependency}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!publication dependency@\spxentry{publication dependency}}\ignorespaces 
\sphinxAtStartPar
DataLad concept: An existing {\hyperref[\detokenize{glossary:term-sibling}]{\sphinxtermref{\DUrole{xref,std,std-term}{sibling}}}} is linked to a new sibling
so that the existing sibling is always published prior to the new sibling.
The existing sibling could be a {\hyperref[\detokenize{glossary:term-special-remote}]{\sphinxtermref{\DUrole{xref,std,std-term}{special remote}}}} to publish file
contents stored in the dataset {\hyperref[\detokenize{glossary:term-annex}]{\sphinxtermref{\DUrole{xref,std,std-term}{annex}}}} automatically with every
\sphinxcode{\sphinxupquote{datalad push}} to the new sibling. Publication dependencies can be
set with the option \sphinxcode{\sphinxupquote{publish\sphinxhyphen{}depends}} in the commands
\sphinxcode{\sphinxupquote{datalad siblings}}, \sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling}}, and
\sphinxcode{\sphinxupquote{datalad create\sphinxhyphen{}sibling\sphinxhyphen{}github/gitlab}}.

\sphinxlineitem{pull request\index{pull request@\spxentry{pull request}|spxpagem}\phantomsection\label{\detokenize{glossary:term-pull-request}}}
\index{pull request@\spxentry{pull request}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!pull request@\spxentry{pull request}}\ignorespaces 
\sphinxAtStartPar
Also known as {\hyperref[\detokenize{glossary:term-merge-request}]{\sphinxtermref{\DUrole{xref,std,std-term}{merge request}}}}. Contributions to Git repositories/DataLad datasets can be proposed to be {\hyperref[\detokenize{glossary:term-merge}]{\sphinxtermref{\DUrole{xref,std,std-term}{merge}}}}d into the dataset by “requesting a pull/update” from the dataset maintainer to obtain a proposed change from a dataset clone or sibling. It is implemented as a feature in repository hosting sites such as {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}, {\hyperref[\detokenize{glossary:term-GIN}]{\sphinxtermref{\DUrole{xref,std,std-term}{Gin}}}}, or {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}.

\sphinxlineitem{ref\index{ref@\spxentry{ref}|spxpagem}\phantomsection\label{\detokenize{glossary:term-ref}}}
\index{ref@\spxentry{ref}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!ref@\spxentry{ref}}\ignorespaces 
\sphinxAtStartPar
Git concept. A “Git Reference”, typically shortened to “ref”, is a text file containing a {\hyperref[\detokenize{glossary:term-commit}]{\sphinxtermref{\DUrole{xref,std,std-term}{commit}}}} {\hyperref[\detokenize{glossary:term-shasum}]{\sphinxtermref{\DUrole{xref,std,std-term}{shasum}}}} as a human\sphinxhyphen{}readable reference to a specific version of your dataset or Git repository. Thanks to refs, Git users do not need to memorize or type shasums when switching between dataset states, and can use simple names instead: For example, a {\hyperref[\detokenize{glossary:term-branch}]{\sphinxtermref{\DUrole{xref,std,std-term}{branch}}}} such as \sphinxcode{\sphinxupquote{main}} is a ref, and a {\hyperref[\detokenize{glossary:term-tag}]{\sphinxtermref{\DUrole{xref,std,std-term}{tag}}}} is one, too. In both cases, those refs are text files that contain the shasum of the commit at the tip of a branch, or the shasum of the commit you added the tag to. Refs are organized in the directory \sphinxcode{\sphinxupquote{.git/refs}} and Git commands and configurations can use refs to perform updating operations or determine their behavior. More details can be found at \sphinxhref{https://git-scm.com/book/en/v2/Git-Internals-Git-References}{at git\sphinxhyphen{}scm.com}

\sphinxlineitem{relative path\index{relative path@\spxentry{relative path}|spxpagem}\phantomsection\label{\detokenize{glossary:term-relative-path}}}
\index{file system concept@\spxentry{file system concept}!path (relative)@\spxentry{path}\spxextra{relative}}\ignorespaces 
\sphinxAtStartPar
A path related to the present working directory. Relative paths never start with \sphinxcode{\sphinxupquote{/}} or \sphinxcode{\sphinxupquote{\textbackslash{}}}.
Examples on Unix and Windows: \sphinxcode{\sphinxupquote{../Pictures/xkcd\sphinxhyphen{}webcomics/530.png}}, \sphinxcode{\sphinxupquote{..\textbackslash{}Pictures\textbackslash{}xkcd\sphinxhyphen{}webcomics\textbackslash{}530.png}}. See also {\hyperref[\detokenize{glossary:term-absolute-path}]{\sphinxtermref{\DUrole{xref,std,std-term}{absolute path}}}}.

\sphinxlineitem{remote\index{remote@\spxentry{remote}|spxpagem}\phantomsection\label{\detokenize{glossary:term-remote}}}
\index{remote@\spxentry{remote}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!remote@\spxentry{remote}}\ignorespaces 
\sphinxAtStartPar
Git\sphinxhyphen{}terminology: A repository (and thus also {\hyperref[\detokenize{glossary:term-DataLad-dataset}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad dataset}}}}) that a given repository
tracks. A {\hyperref[\detokenize{glossary:term-sibling}]{\sphinxtermref{\DUrole{xref,std,std-term}{sibling}}}} is DataLad’s equivalent to a remote.

\sphinxlineitem{Remote Indexed Archive (RIA) store\index{Remote Indexed Archive (RIA) store@\spxentry{Remote Indexed Archive (RIA) store}|spxpagem}\phantomsection\label{\detokenize{glossary:term-Remote-Indexed-Archive-RIA-store}}}
\index{Remote Indexed Archive@\spxentry{Remote Indexed Archive}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!Remote Indexed Archive@\spxentry{Remote Indexed Archive}}\index{RIA store@\spxentry{RIA store}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!RIA store@\spxentry{RIA store}}\ignorespaces 
\sphinxAtStartPar
A Remote Indexed Archive (RIA) Store is a flexible and scalable dataset storage
solution, useful for collaborative, back\sphinxhyphen{}up, or storage workflows. Read more
about RIA stores in the online version of the handbook.

\sphinxlineitem{run procedure\index{run procedure@\spxentry{run procedure}|spxpagem}\phantomsection\label{\detokenize{glossary:term-run-procedure}}}
\index{run procedure@\spxentry{run procedure}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!run procedure@\spxentry{run procedure}}\ignorespaces 
\sphinxAtStartPar
DataLad concept: An executable (such as a script) that can be called with the
\sphinxcode{\sphinxupquote{datalad run\sphinxhyphen{}procedure}} command and performs modifications or routine
tasks in datasets. Procedures can be written by users, or come with DataLad and
its extensions. Find out more in section {\hyperref[\detokenize{basics/101-124-procedures:procedures}]{\sphinxcrossref{\DUrole{std,std-ref}{Configurations to go}}}} (\autopageref*{\detokenize{basics/101-124-procedures:procedures}})

\sphinxlineitem{run record\index{run record@\spxentry{run record}|spxpagem}\phantomsection\label{\detokenize{glossary:term-run-record}}}
\index{run record@\spxentry{run record}!DataLad concept@\spxentry{DataLad concept}}\index{DataLad concept@\spxentry{DataLad concept}!run record@\spxentry{run record}}\ignorespaces 
\sphinxAtStartPar
A command summary of a \sphinxcode{\sphinxupquote{datalad run}} command, generated by DataLad and included
in the commit message.

\sphinxlineitem{sed\index{sed@\spxentry{sed}|spxpagem}\phantomsection\label{\detokenize{glossary:term-sed}}}
\index{sed@\spxentry{sed}!terminal command@\spxentry{terminal command}}\index{terminal command@\spxentry{terminal command}!sed@\spxentry{sed}}\ignorespaces 
\sphinxAtStartPar
A Unix stream editor to parse and transform text. Find out more
\sphinxhref{https://en.wikipedia.org/wiki/Sed}{here} and in its
\sphinxhref{https://www.gnu.org/software/sed/manual/sed.html}{documentation}.

\sphinxlineitem{shasum\index{shasum@\spxentry{shasum}|spxpagem}\phantomsection\label{\detokenize{glossary:term-shasum}}}
\sphinxAtStartPar
A hexadecimal number, 40 digits long, that is produced by a secure hash algorithm, and
is used by {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} to identify {\hyperref[\detokenize{glossary:term-commit}]{\sphinxtermref{\DUrole{xref,std,std-term}{commit}}}}s. A shasum is a type of {\hyperref[\detokenize{glossary:term-checksum}]{\sphinxtermref{\DUrole{xref,std,std-term}{checksum}}}}.

\sphinxlineitem{shebang\index{shebang@\spxentry{shebang}|spxpagem}\phantomsection\label{\detokenize{glossary:term-shebang}}}
\sphinxAtStartPar
The characters \sphinxcode{\sphinxupquote{\#!}} at the very top of a script. One can specify the interpreter (i.e., the
software that executes a script of yours, such as Python) after with it such as in
\sphinxcode{\sphinxupquote{\#! /usr/bin/python}}.
If the script has executable {\hyperref[\detokenize{glossary:term-permissions}]{\sphinxtermref{\DUrole{xref,std,std-term}{permissions}}}}, it is henceforth able to call the interpreter itself.
Instead of \sphinxcode{\sphinxupquote{python code/myscript.py}} one can just run \sphinxcode{\sphinxupquote{code/myscript}} if \sphinxcode{\sphinxupquote{myscript}} has
executable {\hyperref[\detokenize{glossary:term-permissions}]{\sphinxtermref{\DUrole{xref,std,std-term}{permissions}}}} and a correctly specified shebang.

\sphinxlineitem{shell\index{shell@\spxentry{shell}|spxpagem}\phantomsection\label{\detokenize{glossary:term-shell}}}
\sphinxAtStartPar
A command line language and programming language. See also {\hyperref[\detokenize{glossary:term-terminal}]{\sphinxtermref{\DUrole{xref,std,std-term}{terminal}}}}.

\sphinxlineitem{special remote\index{special remote@\spxentry{special remote}|spxpagem}\phantomsection\label{\detokenize{glossary:term-special-remote}}}
\sphinxAtStartPar
git\sphinxhyphen{}annex concept: A protocol that defines the underlying transport of annexed files
to and from places that are not {\hyperref[\detokenize{glossary:term-Git}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git}}}} repositories (e.g., a cloud service or
external machines such as HPC systems).

\sphinxlineitem{squash\index{squash@\spxentry{squash}|spxpagem}\phantomsection\label{\detokenize{glossary:term-squash}}}
\index{squash@\spxentry{squash}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!squash@\spxentry{squash}}\ignorespaces 
\sphinxAtStartPar
Git concept; Squashing is a Git operation which rewrites history by taking
a range of commits and squash them into a single commit. For more information
on rewriting Git history, checkout section {\hyperref[\detokenize{basics/101-137-history:history}]{\sphinxcrossref{\DUrole{std,std-ref}{Git things done}}}} (\autopageref*{\detokenize{basics/101-137-history:history}}) and the
\sphinxhref{https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History}{Git documentation}.

\sphinxlineitem{SSH\index{SSH@\spxentry{SSH}|spxpagem}\phantomsection\label{\detokenize{glossary:term-SSH}}}
\index{concepts@\spxentry{concepts}!SSH@\spxentry{SSH}}\ignorespaces 
\sphinxAtStartPar
Secure shell (SSH) is a network protocol to link one machine (computer),
the \sphinxstyleemphasis{client}, to a different local or remote machine, the \sphinxstyleemphasis{server}. See also: {\hyperref[\detokenize{glossary:term-SSH-server}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH server}}}}.

\sphinxlineitem{SSH key\index{SSH key@\spxentry{SSH key}|spxpagem}\phantomsection\label{\detokenize{glossary:term-SSH-key}}}
\index{concepts@\spxentry{concepts}!SSH key@\spxentry{SSH key}}\index{SSH@\spxentry{SSH}!key@\spxentry{key}}\ignorespaces 
\sphinxAtStartPar
An SSH key is an access credential in the SSH protocol that can be used to login
from one system to remote servers and services, such as from your private
computer to an {\hyperref[\detokenize{glossary:term-SSH-server}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH server}}}}, without supplying your username or password
at each visit. To use an SSH key for authentication, you need to generate a
key pair on the system you would like to use to access a remote system or service
(most likely, your computer).
The pair consists of a \sphinxstyleemphasis{private} and a \sphinxstyleemphasis{public} key. The public key is shared
with the remote server, and the private key is used to authenticate your machine
whenever you want to access the remote server or service.
Services such as {\hyperref[\detokenize{glossary:term-GitHub}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitHub}}}}, {\hyperref[\detokenize{glossary:term-GitLab}]{\sphinxtermref{\DUrole{xref,std,std-term}{GitLab}}}}, and {\hyperref[\detokenize{glossary:term-GIN}]{\sphinxtermref{\DUrole{xref,std,std-term}{Gin}}}} use SSH keys and the SSH protocol
to ease access to repositories. This
\sphinxhref{https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent}{tutorial by GitHub}
is a detailed step\sphinxhyphen{}by\sphinxhyphen{}step instruction to generate and use SSH keys for authentication.

\sphinxlineitem{SSH server\index{SSH server@\spxentry{SSH server}|spxpagem}\phantomsection\label{\detokenize{glossary:term-SSH-server}}}
\index{SSH@\spxentry{SSH}!server@\spxentry{server}}\ignorespaces 
\sphinxAtStartPar
An remote or local computer that users can log into using the {\hyperref[\detokenize{glossary:term-SSH}]{\sphinxtermref{\DUrole{xref,std,std-term}{SSH}}}} protocol.

\sphinxlineitem{stdin\index{stdin@\spxentry{stdin}|spxpagem}\phantomsection\label{\detokenize{glossary:term-stdin}}}
\index{operating system concept@\spxentry{operating system concept}!stdin@\spxentry{stdin}|spxpagem}\ignorespaces 
\sphinxAtStartPar
Unix concept: One of the three \sphinxhref{https://en.wikipedia.org/wiki/Standard\_streams}{standard input/output streams}
in programming. Standard input (\sphinxcode{\sphinxupquote{stdin}}) is a stream from which a program
reads its input data.

\sphinxlineitem{stderr\index{stderr@\spxentry{stderr}|spxpagem}\phantomsection\label{\detokenize{glossary:term-stderr}}}
\index{operating system concept@\spxentry{operating system concept}!stderr@\spxentry{stderr}|spxpagem}\ignorespaces 
\sphinxAtStartPar
Unix concept: One of the three \sphinxhref{https://en.wikipedia.org/wiki/Standard\_streams}{standard input/output streams}
in programming. Standard error (\sphinxcode{\sphinxupquote{stderr}}) is a stream to which a program
outputs error messages, independent from standard output.

\sphinxlineitem{stdout\index{stdout@\spxentry{stdout}|spxpagem}\phantomsection\label{\detokenize{glossary:term-stdout}}}
\index{operating system concept@\spxentry{operating system concept}!stdout@\spxentry{stdout}|spxpagem}\ignorespaces 
\sphinxAtStartPar
Unix concept: One of the three \sphinxhref{https://en.wikipedia.org/wiki/Standard\_streams}{standard input/output streams}
in programming. Standard output (\sphinxcode{\sphinxupquote{stdout}}) is a stream to which a program
writes its output data.

\sphinxlineitem{symlink\index{symlink@\spxentry{symlink}|spxpagem}\phantomsection\label{\detokenize{glossary:term-symlink}}}
\index{file system concept@\spxentry{file system concept}!symlink@\spxentry{symlink}}\ignorespaces 
\sphinxAtStartPar
A symbolic link (also symlink or soft link) is a reference to another file or path in the form
of a relative path. Windows users are familiar with a similar concept: shortcuts.

\sphinxlineitem{sibling\index{sibling@\spxentry{sibling}|spxpagem}\phantomsection\label{\detokenize{glossary:term-sibling}}}
\sphinxAtStartPar
DataLad concept: A dataset clone that a given {\hyperref[\detokenize{glossary:term-DataLad-dataset}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad dataset}}}} knows about. Changes can be
retrieved and pushed between a dataset and its sibling. It is the
equivalent of a {\hyperref[\detokenize{glossary:term-remote}]{\sphinxtermref{\DUrole{xref,std,std-term}{remote}}}} in Git.

\sphinxlineitem{Singularity\index{Singularity@\spxentry{Singularity}|spxpagem}\phantomsection\label{\detokenize{glossary:term-Singularity}}}
\sphinxAtStartPar
\sphinxhref{https://sylabs.io/docs}{Singularity} is a containerization software that can package software into {\hyperref[\detokenize{glossary:term-software-container}]{\sphinxtermref{\DUrole{xref,std,std-term}{software container}}}}s.
It is a useful alternative to {\hyperref[\detokenize{glossary:term-Docker}]{\sphinxtermref{\DUrole{xref,std,std-term}{Docker}}}} as it can run on shared computational infrastructure.
Find out more on \sphinxhref{https://en.wikipedia.org/wiki/Singularity\_(software)}{Wikipedia}.

\sphinxlineitem{Singularity\sphinxhyphen{}Hub\index{Singularity\sphinxhyphen{}Hub@\spxentry{Singularity\sphinxhyphen{}Hub}|spxpagem}\phantomsection\label{\detokenize{glossary:term-Singularity-Hub}}}
\sphinxAtStartPar
\sphinxhref{https://singularity-hub.org}{singularity\sphinxhyphen{}hub.org} was a Singularity container portal.
Among other things, it hosts Singularity container images.
You can can \sphinxstyleemphasis{pull} {\hyperref[\detokenize{glossary:term-container-image}]{\sphinxtermref{\DUrole{xref,std,std-term}{container image}}}}s built from it.

\sphinxlineitem{software container\index{software container@\spxentry{software container}|spxpagem}\phantomsection\label{\detokenize{glossary:term-software-container}}}
\sphinxAtStartPar
Computational containers are cut\sphinxhyphen{}down virtual machines that allow you to package software libraries and their dependencies in precise versions into a bundle that can be shared with others.
They are running instances of a {\hyperref[\detokenize{glossary:term-container-image}]{\sphinxtermref{\DUrole{xref,std,std-term}{container image}}}}.
On your own and other’s machines, the container constitutes a secluded software environment that contains the exact software environment that you specified but does not effect any software outside of the container.
Unlike virtual machines, software containers do not have their own operating system and instead use basic services of the underlying operating system of the computer they run on (in a read\sphinxhyphen{}only fashion).
This makes them lightweight and portable.
By sharing software environments with containers, such as {\hyperref[\detokenize{glossary:term-Docker}]{\sphinxtermref{\DUrole{xref,std,std-term}{Docker}}}} or {\hyperref[\detokenize{glossary:term-Singularity}]{\sphinxtermref{\DUrole{xref,std,std-term}{Singularity}}}} containers, others (and also yourself) have easy access to software without the need to modify the software environment of the machine the container runs on.

\sphinxlineitem{submodule\index{submodule@\spxentry{submodule}|spxpagem}\phantomsection\label{\detokenize{glossary:term-submodule}}}
\index{submodule@\spxentry{submodule}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!submodule@\spxentry{submodule}}\ignorespaces 
\sphinxAtStartPar
Git concept: a submodule is a Git repository embedded inside another Git repository. A
{\hyperref[\detokenize{glossary:term-DataLad-subdataset}]{\sphinxtermref{\DUrole{xref,std,std-term}{DataLad subdataset}}}} is known as a submodule in the {\hyperref[\detokenize{glossary:term-Git-config-file}]{\sphinxtermref{\DUrole{xref,std,std-term}{Git config file}}}}.

\sphinxlineitem{tab completion\index{tab completion@\spxentry{tab completion}|spxpagem}\phantomsection\label{\detokenize{glossary:term-tab-completion}}}
\index{command line concept@\spxentry{command line concept}!tab completion@\spxentry{tab completion}}\ignorespaces 
\sphinxAtStartPar
Also known as command\sphinxhyphen{}line completion. A common shell feature in which
the program automatically fills in partially types commands upon
pressing the \sphinxcode{\sphinxupquote{TAB}} key.

\sphinxlineitem{tag\index{tag@\spxentry{tag}|spxpagem}\phantomsection\label{\detokenize{glossary:term-tag}}}
\index{tag@\spxentry{tag}!Git concept@\spxentry{Git concept}}\index{Git concept@\spxentry{Git concept}!tag@\spxentry{tag}}\ignorespaces 
\sphinxAtStartPar
Git concept: A mark on a commit that can help to identify commits. You can attach
a tag with a name of your choice to any commit by supplying the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}version\sphinxhyphen{}tag \textless{}TAG\sphinxhyphen{}NAME\textgreater{}}}
option to \sphinxcode{\sphinxupquote{datalad save}}.

\sphinxlineitem{the DataLad superdataset ///\index{the DataLad superdataset ///@\spxentry{the DataLad superdataset ///}|spxpagem}\phantomsection\label{\detokenize{glossary:term-the-DataLad-superdataset}}}
\sphinxAtStartPar
DataLad provides unified access to a large amount of data at an open data
collection found at \sphinxhref{https://datasets.datalad.org}{datasets.datalad.org}.
This collection is known as “The DataLad superdataset” and under its shortcut,
\sphinxcode{\sphinxupquote{///}}. You can install the superdataset \textendash{} and subsequently query its content via metadata
search \textendash{} by running \sphinxcode{\sphinxupquote{datalad clone ///}}.

\sphinxlineitem{tig\index{tig@\spxentry{tig}|spxpagem}\phantomsection\label{\detokenize{glossary:term-tig}}}
\index{tig@\spxentry{tig}!terminal command@\spxentry{terminal command}}\index{terminal command@\spxentry{terminal command}!tig@\spxentry{tig}}\ignorespaces 
\sphinxAtStartPar
A text\sphinxhyphen{}mode interface for git that allows you to easily browse through your commit history.
It is not part of git and needs to be installed. Find out more \sphinxhref{https://jonas.github.io/tig}{here}.

\sphinxlineitem{terminal\index{terminal@\spxentry{terminal}|spxpagem}\phantomsection\label{\detokenize{glossary:term-terminal}}}
\sphinxAtStartPar
The terminal (sometimes also called a shell, console, or CLI) is an interactive, text based interface that allows you to access your computer’s functionality.
The most common command\sphinxhyphen{}line shells use {\hyperref[\detokenize{glossary:term-bash}]{\sphinxtermref{\DUrole{xref,std,std-term}{bash}}}} or c\sphinxhyphen{}shell.
You can get a short intro to the terminal and useful commands in the section {\hyperref[\detokenize{intro/howto:howto}]{\sphinxcrossref{\DUrole{std,std-ref}{The command line}}}} (\autopageref*{\detokenize{intro/howto:howto}}).

\sphinxlineitem{Ubuntu\index{Ubuntu@\spxentry{Ubuntu}|spxpagem}\phantomsection\label{\detokenize{glossary:term-Ubuntu}}}
\sphinxAtStartPar
A common Linux distribution. \sphinxhref{https://ubuntu.com}{More information here}.

\sphinxlineitem{UUID\index{UUID@\spxentry{UUID}|spxpagem}\phantomsection\label{\detokenize{glossary:term-UUID}}}
\sphinxAtStartPar
Universally Unique Identifier. It is a character string used for \sphinxstyleemphasis{unambiguous}
identification, formatted according to a specific standard. This
identification is not only unambiguous and unique on a system, but indeed \sphinxstyleemphasis{universally}
unique \textendash{} no UUID exists twice anywhere \sphinxstyleemphasis{on the planet}.
Every DataLad dataset has a UUID that identifies a dataset uniquely as a whole across
its entire history and flavors called {\hyperref[\detokenize{glossary:term-dataset-ID}]{\sphinxtermref{\DUrole{xref,std,std-term}{Dataset ID}}}} that looks similar to
this \sphinxcode{\sphinxupquote{0828ac72\sphinxhyphen{}f7c8\sphinxhyphen{}11e9\sphinxhyphen{}917f\sphinxhyphen{}a81e84238a11}}. This dataset ID will only exist once,
identifying only one particular dataset on the planet. Note that this does not
require all UUIDs to be known in some central database \textendash{} the fact that no UUID
exists twice is achieved by mere probability: The chance of a UUID being duplicated
is so close to zero that it is negligible.

\sphinxlineitem{version control\index{version control@\spxentry{version control}|spxpagem}\phantomsection\label{\detokenize{glossary:term-version-control}}}
\sphinxAtStartPar
Processes and tools to keep track of changes to documents or other collections of information.

\sphinxlineitem{vim\index{vim@\spxentry{vim}|spxpagem}\phantomsection\label{\detokenize{glossary:term-vim}}}
\index{vim@\spxentry{vim}!terminal command@\spxentry{terminal command}}\index{terminal command@\spxentry{terminal command}!vim@\spxentry{vim}}\ignorespaces 
\sphinxAtStartPar
A text editor, often the default in UNIX operating systems. If you are not used to using it,
but ended up in it accidentally: press \sphinxcode{\sphinxupquote{ESC}} \sphinxcode{\sphinxupquote{:}} \sphinxcode{\sphinxupquote{q}} \sphinxcode{\sphinxupquote{!}} \sphinxcode{\sphinxupquote{Enter}} to exit without saving.
Here is help: \sphinxhref{https://www.openvim.com}{A vim tutorial} and
\sphinxhref{https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration}{how to configure the default editor for git}.

\sphinxlineitem{virtual environment\index{virtual environment@\spxentry{virtual environment}|spxpagem}\phantomsection\label{\detokenize{glossary:term-virtual-environment}}}
\sphinxAtStartPar
A specific Python installation with packages of your choice, kept in a self\sphinxhyphen{}contained directory tree, and not interfering with the system\sphinxhyphen{}wide installations.
Virtual environments are an easy solution to create several different Python environments and come in handy if you want to have a cleanly structured software setup and several applications with software requirements that would conflict with each other in a single system: You can have one virtual environment with package A in version X, and a second one with package A in version Y.
There are several tools that create virtual environments such as the built\sphinxhyphen{}in \sphinxcode{\sphinxupquote{venv}} module, the \sphinxcode{\sphinxupquote{virtualenv}} module, or {\hyperref[\detokenize{glossary:term-conda}]{\sphinxtermref{\DUrole{xref,std,std-term}{conda}}}}.
Virtual environments are light\sphinxhyphen{}weight and you can switch between them fast.

\sphinxlineitem{WSL\index{WSL@\spxentry{WSL}|spxpagem}\phantomsection\label{\detokenize{glossary:term-WSL}}}
\sphinxAtStartPar
The Windows Subsystem for Linux, a compatibility layer for running Linux distributions on recent versions of Windows. Find out more \sphinxhref{https://en.wikipedia.org/wiki/Windows\_Subsystem\_for\_Linux}{here}.

\sphinxlineitem{zsh\index{zsh@\spxentry{zsh}|spxpagem}\phantomsection\label{\detokenize{glossary:term-zsh}}}
\index{shell@\spxentry{shell}!zsh@\spxentry{zsh}}\ignorespaces 
\sphinxAtStartPar
A Unix shell.

\end{description}

\sphinxstepscope


\section{Acknowledgements}
\label{\detokenize{acknowledgements:acknowledgements}}\label{\detokenize{acknowledgements::doc}}
\sphinxAtStartPar
The DataLad software and its documentation are the joint work of more than 100 individuals.
We are deeply grateful for these contributions to free and open source software (FOSS) and documentation.
Likewise we are grateful to the many more people that produce and maintain the FOSS ecosystem that DataLad is built on.
We are particularly indebted to Joey Hess, the author of the git\sphinxhyphen{}annex software, without which DataLad would not be what it is today.

\sphinxAtStartPar
The DataLad project received support through the following grants:
\begin{itemize}
\item {} 
\sphinxAtStartPar
US\sphinxhyphen{}German collaboration in computational neuroscience (CRCNS) project “DataGit: converging catalogues, warehouses, and deployment logistics into a federated ‘data distribution’” (Halchenko/Hanke), co\sphinxhyphen{}funded by the US National Science Foundation (NSF 1429999) and the German Federal Ministry of Education and Research (BMBF 01GQ1411).

\item {} 
\sphinxAtStartPar
CRCNS US\sphinxhyphen{}German Data Sharing “DataLad \sphinxhyphen{} a decentralized system for integrated discovery, management, and publication of digital objects of science” (Halchenko/Pestilli/Hanke), co\sphinxhyphen{}funded by the US National Science Foundation (NSF 1912266) and the German Federal Ministry of Education and Research (BMBF 01GQ1905).

\item {} 
\sphinxAtStartPar
Helmholtz Research Center Jülich, FDM challenge 2022

\item {} 
\sphinxAtStartPar
German federal state of Saxony\sphinxhyphen{}Anhalt and the European Regional Development Fund (ERDF), Project: Center for Behavioral Brain Sciences, Imaging Platform

\item {} 
\sphinxAtStartPar
ReproNim project (NIH 1P41EB019936\sphinxhyphen{}01A1).

\item {} 
\sphinxAtStartPar
Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under grant SFB 1451 (431549029, INF project)

\item {} 
\sphinxAtStartPar
European Union’s Horizon 2020 research and innovation programme under grant agreements
\begin{itemize}
\item {} 
\sphinxAtStartPar
Human Brain Project SGA3 (H2020\sphinxhyphen{}EU.3.1.5.3, grant no. 945539)

\item {} 
\sphinxAtStartPar
VirtualBrainCloud (H2020\sphinxhyphen{}EU.3.1.5.3, grant no. 826421)

\end{itemize}

\end{itemize}

\sphinxstepscope

\index{copyright@\spxentry{copyright}}\index{licenses@\spxentry{licenses}}\ignorespaces 

\section{Copyright and licenses}
\label{\detokenize{licenses:copyright-and-licenses}}\label{\detokenize{licenses:index-0}}\label{\detokenize{licenses::doc}}
\sphinxAtStartPar
This book is made available under the terms of the \sphinxhref{https://creativecommons.org/licenses/by-sa/4.0}{Creative Commons Attribution\sphinxhyphen{}ShareAlike 4.0 International Public License (CC\sphinxhyphen{}BY\sphinxhyphen{}SA)}.
The copyright holders for the book content are the respective individual contributors of particular content, as recorded in the version history of the online\sphinxhyphen{}handbook’s Git repository.

\sphinxAtStartPar
This book may contain copyrighted and/or trademarked materials, the use of which may not have been specifically authorized by the respective owner.
These are included for educational purposes in an effort to explain issues relevant to decentralized data management and other topics covered in this book.
We believe that this constitutes a “fair use” of the materials as provided for in section 107 of the US Copyright Law.
Use of these materials that go beyond “fair use” may require permissions to be obtained from the respective owner.
These copyright/trademark holders are not affiliated with the authors or any of the authors’ representatives.
They do not sponsor or endorse the contents, materials, or processes discussed within this book.

\sphinxAtStartPar
The remainder of this sections amends the general copyright and license declaration of the book with additional information on used 3rd\sphinxhyphen{}party materials.


\subsection{unDraw illustrations}
\label{\detokenize{licenses:undraw-illustrations}}
\sphinxAtStartPar
This book includes numerous illustrations obtained from Katerina Limpitsouni’s undraw project (\sphinxurl{https://undraw.co}), covered by the following terms:
\begin{quote}

\sphinxAtStartPar
Copyright 2023 Katerina Limpitsouni

\sphinxAtStartPar
All images, assets and vectors published on unDraw can be used for free.
You can use them for noncommercial and commercial purposes.
You do not need to ask permission from or provide credit to the creator or unDraw.

\sphinxAtStartPar
More precisely, unDraw grants you an nonexclusive, worldwide copyright license to download, copy, modify, distribute, perform, and use the assets provided from unDraw for free, including for commercial purposes, without permission from or attributing the creator or unDraw.
This license does not include the right to compile assets, vectors or images from unDraw to replicate a similar or competing service, in any form or distribute the assets in packs or otherwise.
This extends to automated and non\sphinxhyphen{}automated ways to link, embed, scrape, search or download the assets included on the website without our consent.

\sphinxAtStartPar
Regarding brand logos that are included:

\sphinxAtStartPar
Are registered trademarks of their respected owners.
Are included on a promotional basis and do not represent an association with unDraw or its users.
Do not indicate any kind of endorsement of the trademark holder towards unDraw, nor vice versa.
Are provided with the sole purpose to represent the actual brand/service/company that has registered the trademark and must not be used otherwise.
\end{quote}


\subsection{YODA illustration}
\label{\detokenize{licenses:yoda-illustration}}
\sphinxAtStartPar
The “YODA” cartoon used in chapter {\hyperref[\detokenize{basics/basics-yoda:chapter-yoda}]{\sphinxcrossref{\DUrole{std,std-ref}{You will find only what you bring in}}}} (\autopageref*{\detokenize{basics/basics-yoda:chapter-yoda}}) is derived from \sphinxurl{https://openclipart.org/detail/227445/yoda}, which was made available under \sphinxhref{http://creativecommons.org/publicdomain/zero/1.0}{CC0} terms.


\subsection{Fonts}
\label{\detokenize{licenses:fonts}}
\sphinxAtStartPar
This book uses the following fonts, listed grouped by their respective licenses.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{http://scripts.sil.org/OFL}{SIL Open Font License}
\begin{itemize}
\item {} 
\sphinxAtStartPar
InsonsolataDN\sphinxhyphen{}(Regular, Bold)

\item {} 
\sphinxAtStartPar
Lato

\item {} 
\sphinxAtStartPar
STIXGeneral\sphinxhyphen{}(Regular, Italic, Bold), STIXMathSans\sphinxhyphen{}Regular

\item {} 
\sphinxAtStartPar
Font Awesome; via \sphinxurl{https://github.com/xdanaux/fontawesome-latex}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://tug.org/fonts/licenses/GUST-FONT-LICENSE.txt}{GUST Font license}
\begin{itemize}
\item {} 
\sphinxAtStartPar
LMSans(DemiCond10\sphinxhyphen{}Regular, 10\sphinxhyphen{}Bold)

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://creativecommons.org/licenses/by/4.0/}{CC\sphinxhyphen{}BY 4.0 License}
\begin{itemize}
\item {} 
\sphinxAtStartPar
CCIcons; via \sphinxurl{https://github.com/ummels/ccicons}

\end{itemize}

\end{itemize}


\subsection{Box icons}
\label{\detokenize{licenses:box-icons}}
\sphinxAtStartPar
The icons used to annotate boxes were obtained from svgrepo.com and have the following licenses.
\begin{itemize}
\item {} 
\sphinxAtStartPar
The \sphinxhref{https://www.svgrepo.com/svg/368334/window}{“Window” SVG vector} for Windows Wits is released in the \sphinxhref{https://creativecommons.org/public-domain/cc0/}{public domain}.

\item {} 
\sphinxAtStartPar
The \sphinxhref{https://www.svgrepo.com/svg/23335/idea-and-creativity-symbol-of-a-lightbulb}{“Idea and creativity symbol of a lightbulb SVG vector”} for Find\sphinxhyphen{}out\sphinxhyphen{}more’s is released in the \sphinxhref{https://creativecommons.org/public-domain/cc0/}{public domain}.

\item {} 
\sphinxAtStartPar
The icon for Gitusernotes is derived from the \sphinxhref{https://www.svgrepo.com/svg/443850/gui-git-pull-request}{“Git Pull Request SVG Vector”}, which is released under the \sphinxhref{https://mit-license.org/}{MIT License}.

\end{itemize}

\sphinxstepscope

\index{Conda@\spxentry{Conda}|see{\textquotesingle{}with Conda\textquotesingle{}}}\ignorespaces 
\index{DataLad@\spxentry{DataLad}|see{\textquotesingle{}with DataLad\textquotesingle{}}}\ignorespaces 
\index{git\sphinxhyphen{}annex@\spxentry{git\sphinxhyphen{}annex}|see{\textquotesingle{}with git\sphinxhyphen{}annex\textquotesingle{}}}\ignorespaces 
\index{pip@\spxentry{pip}|see{\textquotesingle{}with pip\textquotesingle{}}}\ignorespaces 
\index{Python@\spxentry{Python}|see{\textquotesingle{}with Python\textquotesingle{}}}\ignorespaces 
\index{CentOS@\spxentry{CentOS}|see{\textquotesingle{}on Redhat/Fedora\textquotesingle{}}}\ignorespaces 
\index{Debian@\spxentry{Debian}|see{\textquotesingle{}on Debian/Ubuntu\textquotesingle{}}}\ignorespaces 
\index{Fedora@\spxentry{Fedora}|see{\textquotesingle{}on Redhat/Fedora\textquotesingle{}}}\ignorespaces 
\index{high\sphinxhyphen{}performance computing@\spxentry{high\sphinxhyphen{}performance computing}|see{\textquotesingle{}HPC\textquotesingle{}}}\ignorespaces 
\index{high\sphinxhyphen{}throughput computing@\spxentry{high\sphinxhyphen{}throughput computing}|see{\textquotesingle{}HTC\textquotesingle{}}}\ignorespaces 
\index{HPC@\spxentry{HPC}|see{\textquotesingle{}on HPC\textquotesingle{}}}\ignorespaces 
\index{Mac@\spxentry{Mac}|see{\textquotesingle{}on Mac\textquotesingle{}}}\ignorespaces 
\index{RedHat@\spxentry{RedHat}|see{\textquotesingle{}on Redhat/Fedora\textquotesingle{}}}\ignorespaces 
\index{terminal@\spxentry{terminal}|see{\textquotesingle{}in a terminal\textquotesingle{}}}\ignorespaces 
\index{Ubuntu@\spxentry{Ubuntu}|see{\textquotesingle{}on Debian/Ubuntu\textquotesingle{}}}\ignorespaces 
\index{Windows@\spxentry{Windows}|see{\textquotesingle{}on Windows\textquotesingle{}}}\ignorespaces 
\index{WSL2@\spxentry{WSL2}|see{\textquotesingle{}on WSL2\textquotesingle{}}}\ignorespaces 
\index{here\sphinxhyphen{}document@\spxentry{here\sphinxhyphen{}document}|see{\textquotesingle{}heredoc\textquotesingle{}}}\ignorespaces 
\index{shell commands@\spxentry{shell commands}|see{\textquotesingle{}terminal commands\textquotesingle{}}}\ignorespaces 
\sphinxstepscope


\chapter{DataLad cheat sheet}
\label{\detokenize{basics/101-136-cheatsheet:datalad-cheat-sheet}}\label{\detokenize{basics/101-136-cheatsheet:cheat}}\label{\detokenize{basics/101-136-cheatsheet:id1}}\label{\detokenize{basics/101-136-cheatsheet::doc}}
\sphinxAtStartPar
The following page provides a cheat sheet with an overview of the most
important DataLad commands. A high\sphinxhyphen{}resolution version of this cheatsheet is
available for download at
\sphinxurl{https://github.com/datalad-handbook/artwork/raw/main/src/datalad-cheatsheet.pdf}

% force the cheatsheet on an even-numbered page
\clearpage{\thispagestyle{empty}\cleardoublepage}
{\thispagestyle{empty}%

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{datalad-cheatsheet_p1}.png}

} % end empty page style
\newpage
\clearpage{\thispagestyle{empty}\cleardoublepage}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
